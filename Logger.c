/*.$file${.::Logger.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: Logger.qm
* File:  ${.::Logger.c}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-SP-170817A
* Issued to   : Covidien LP
* Framework(s): qpc
* Support ends: 2022-08-17
* Product(s)  :
* Signia Powered Stapler
*/
/*.$endhead${.::Logger.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifdef __cplusplus  /* header compatible with C++ project */
extern "C"
{
#endif

/* ========================================================================== */
/**
 * \addtogroup Logger
 * \{
 *
 * \brief   Active Object for Signia Event Logging.
 *
 * \details This module is responsible for collecting and organizing all
 *             event logs. It supports storing the logs to the File system
 *             and sending the logs to Debug terminals/consoles.
 *
 * \copyright 2021 Covidien - Surgical Innovations. All Rights Reserved.
 *
 * \file    Logger.c
 *
 * ========================================================================== */
/******************************************************************************/
/*                             Include                                        */
/******************************************************************************/
#include "Common.h"
#include "FileSys.h"
#include "L2_Uart.h"
#include "ActiveObject.h"
#include "Rdf.h"
#include "L3_GpioCtrl.h"
#include "FaultHandler.h"
#include "L4_ConsoleManager.h"
#include "Signia_AdapterEvents.h"
#include "Signia_AdapterManager.h"
#include "L4_HandleDefn.h"
#include "Signia_ChargerManager.h"
#include "L4_ConsoleCommands.h"
#include "L4_BlobHandler.h"
#include "L3_Battery.h"
#include "Version.h"
#include "TestManager.h"

/******************************************************************************/
/*                             Global Constant Definitions(s)                 */
/******************************************************************************/

/******************************************************************************/
/*                             Global Variable Definitions(s)                 */
/******************************************************************************/

/******************************************************************************/
/*                             Local Define(s) (Macros)                       */
/******************************************************************************/
#define LOG_GROUP_IDENTIFIER    (LOG_GROUP_LOGGER)
#define LOGGER_STACK_SIZE       (512u)                /* Logger Stack Size*/
#define LOGGER_EVQ_SIZE         MAX_NUM_LOG_ENTRIES   /* Event queue size */

#define DEBUG_UART              (UART4)              ///< Debug UART Port
#define DEBUG_UART_BAUD         (115200u)            ///< Debug UART Baud Rate

#define MAX_NUM_LOG_ENTRIES     (EVENT_MSG_BUF_RDF_MAX + EVENT_MSG_BUF_PRINTF_MAX + EVENT_MSG_BUF_1_MAX + EVENT_MSG_BUF_2_MAX)  ///< Max Log Entries possible
#define LEN_CR_LF_NULL          (3u)                 ///< 3 bytes for CR+LF+Null
#define ROTATE_LOG_TIMEOUT      (60000u)             ///< 1 minute timeout
#define UART_TIMEOUT_MSEC       (MSEC_100)           ///< Uart Send Time out in mS

#define DATA_PATH_IGNORE_PREFIX_LENGTH    (15u)          // Don't print the prefix to the data path
#define DATE_STR_LENGTH                   (23u)

#define FLUSH_EVENT_LOG_TIMER_INTERVAL_SHORT    (100u)
#define FLUSH_EVENT_LOG_TIMER_INTERVAL_LONG     (1000u)

#define MAX_DIR_LIMIT           (0xFFDDu)            ///< Max Directories Limit [65501]
#define MAX_RDF_FILE_LIMIT      (0xFFFFu)            ///< Max RDF File number Limit

#define MAX_SUBDIR_PER_MAINDIR  (50u)                ///< Max Subdirectories within a main dir
#define SDCARD_ROOT_DIR         ("sdcard:0:")        ///< SD Card Root Dir
#define SDCARD_ROOT_DIR_LENGTH  (9u)                 ///< number of characters in SDCARD_ROOT_DIR
#define DATA_DIR                ("data")             ///< Data Level 1 Dir name
#define SETTINGS_DIR            ("settings")         ///< Settings: Level 1 Dir name
#define EVENT_LOG_NAME          ("eventLog.txt")     ///< Event Log Name
#define SECURITY_LOG_NAME       ("securityLog.txt")  ///< Security Log Name
#define SYNOPSIS_FILE_NAME      ("\\synopsis.txt")

#define HANDLE_SERIAL_NUMBER_LEN_MAX    (17u)    	///< Maximal length of handle serial number string (16 char + null)
#define SYSTEM_LOG_DATA_MAX             (100u)   	///< Maximum length of System Log Data
#define OW_SECTION_SIZE                 (16u)    	///< One wire each Memory Section Size
#define OW_MEM_MAX_STRING_LENGTH        (32)     	///< Max String length

/* Note - LOG_FILE_PATH_NAME_LEN not set to maximum, set to minimum length to reduce stack overhead.*/
#define LOG_FILE_PATH_NAME_LEN         	(8u)                    ///< Log file path name length.
#undef  ENABLE_RDF_DEL                  			///< Debug purpose only - Remove for production

/******************************************************************************/
/*                             Global Variable Definitions(s)                 */
/******************************************************************************/
OS_STK      LoggerStack[LOGGER_STACK_SIZE + MEMORY_FENCE_SIZE_DWORDS];         /* Stack for AO */

/******************************************************************************/
/*                    Local Type Definition(s)  / Function Prototypes         */
/******************************************************************************/
/* ask QM to declare the Logger class --------------------------------------*/

/*.$declare${AOs::Logger} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Logger} ..........................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */

    /// Timer object
    QTimeEvt Timer;

/* public: */
    FS_FILE  *pEventLogFile;
    uint32_t RotateLogTime;
    bool     EventLogIsDirty;
    FS_ERR   FsErr;
    uint8_t  ActiveDataDirPath[FS_CFG_MAX_PATH_NAME_LEN];
    FS_FILE *pSecurityLogFile;
    bool SecurityLogIsDirty;

/* private: */

    /// Timer object
    QTimeEvt SDCardPresenceTimer;
} Logger;

/* protected: */
static QState Logger_initial(Logger * const me, void const * const par);

/* ========================================================================== */
static QState Logger_Startup(Logger * const me, QEvt const * const e);

/* ========================================================================== */
static QState Logger_Operate(Logger * const me, QEvt const * const e);
/*.$enddecl${AOs::Logger} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static void DebugUartSend(uint8_t *pu8DataToSend, uint16_t u16BytesCount);
static void SendMessageToLog(Logger * const me, LOG_FILE eLogFile, uint8_t *pu8String, uint16_t StringLenIn);
static bool RotateEventLog(Logger * const me);
static bool CreateSDCardDataDirectories(Logger * const me);
static bool SearchOldRdfFiles(FS_FILE_SIZE CleanupSize);
static bool DeleteOldRdfFiles(FS_FILE_SIZE CleanupSize, uint16_t u16IdxLevelOne, uint16_t u16IdxLevelTwo);

/******************************************************************************/
/*                             Local Constant Definition(s)                   */
/******************************************************************************/

/******************************************************************************/
/*                             Local Variable Definition(s)                   */
/******************************************************************************/
/* Instantiate the Logger active object (and local data)--------------------*/
static Logger      LocalLogger;                            /* Local data */
QActive *const     AO_Logger = &LocalLogger.super;         /* Opaque pointer to Logger Active Object */

/// \todo 02-01-2022 KIA - code has random failures if these 2 buffers are in external sram. Why?
#pragma location=".sram"
static QEvt const *LoggerEventQueue[LOGGER_EVQ_SIZE];      /* Event Queue for AO */

static uint8_t    *AOname = "Logger";

static uint8_t  SdhcLEDCnt = 0;                                 // Counter for Led on SDHC card
/// \todo 11/19/2021 DAZ - This should be part of Local data structure: (struct Logger)

static bool     LoggerInitialized = false;                      // True if logger system initialized
static bool     LoggerDisabled = false;                         // True if logger system disabled

static QEvt FakeTimeout = { TIMEOUT_SIG, 0, 0 };                // Fake timeout signal
//static FS_FILE      *mpEventLogFile;                                ///< Logger Eventlog file pointer.       \todo 05/28/2021 DAZ - Should be in local data structure.
//static uint8_t       mActiveDataDirPath[FS_CFG_MAX_PATH_NAME_LEN];  ///< Current Active Data Directory Path. \todo 05/28/2021 DAZ - Should be in local data structure.
FS_FILE_SIZE         MemSize;                                       ///< calculated RDF memory size

static int8_t  pDirPath[FS_CFG_MAX_PATH_NAME_LEN]; /* Eventlog Dir Path */
static char    pFilePath[LOG_FILE_PATH_NAME_LEN]; /* Eventlog Full File Path */
static int8_t  sHandleSerialNumber[HANDLE_SERIAL_NUMBER_LEN_MAX];
static char    DateStr[DATE_STR_LENGTH];
/******************************************************************************/
/*                             Local Function(s)                              */
/******************************************************************************/
/* Local helper functions for Logger: */
/* ========================================================================== */
/**
 * \brief   Sends the data to Debug UART
 *
 * \details This function Logs the message to Debug UART.
 *
 * \param   *pu8DataToSend - Data to send.
 * \param   u16BytesCount - Byte count to send.
 *
 * \return  None
 *
 * ========================================================================== */
static void DebugUartSend(uint8_t *pu8DataToSend, uint16_t u16BytesCount)
{
    uint32_t u32Timeout;        /* Max time to wait for transmit free */
    uint16_t u16BytesSent;      /* Bytes Sent Count */

    /* Send the data only after initialization */
    if (LoggerInitialized)
    {
        /* 100 mS for a start */
        u32Timeout = OSTimeGet() + UART_TIMEOUT_MSEC;

        u16BytesSent = 0;

        do
        {   /* Timeout? or Uart Error? */
            if (OSTimeGet() >= u32Timeout)
            {
                break;
            }

            /* Send the buffer to Debug UART */
            (void)L2_UartWriteBlock(DEBUG_UART, pu8DataToSend + u16BytesSent, u16BytesCount, &u16BytesSent);

            /* Update the count */
            u16BytesCount -= u16BytesSent;

        } while (u16BytesCount);
    }
}

/* ========================================================================== */
/**
 * \brief   Sends Log message to Debug Terminals / Consoles and Filesystem.
 *
 * \details This function logs the message to Debug terminals and Filesystem.
 *          This function can be used, when there is a need to log messages
 *          quickly without waiting for the MsgQ availability.
 *
 * \todo    01/27/21 GK - Add an entry to send the message to USB/Wifi console.
 * \todo    01/27/21 GK - Remove the IAR Terminal I/O option once MCP debugging is available.
 *
 * \todo    05/27/21 DAZ - Investigate possibility of publishing string to USB/WiFi.
 *
 * \param   me          - Pointer to local data store
 * \param   pu8String   - Data string to Log.
 * \param   StringLenIn - Byte count to Log.
 *
 * \return  None
 *
 * ========================================================================== */
static void SendMessageToLog(Logger * const me, LOG_FILE eLogFile, uint8_t *pu8String, uint16_t StringLenIn)
{
    FS_FILE *pLogFile;

    pLogFile = NULL;

    do
    {   /* Is the String Valid? */
        if (NULL == pu8String)
        {
            /* Nope */
            break;
        }

#ifdef DEBUG_CODE
        /* Send the String to IAR Terminal I/O */
        printf("%.*s", StringLenIn, pu8String);
#endif
        /* Yes, Send the string to the Debug UART. */
        DebugUartSend((uint8_t *)pu8String, StringLenIn);

        /* Message for EventLog ? */
        if( EVENT_LOG_FILE == eLogFile)
        {
            pLogFile = me->pEventLogFile;
        }
        /* Message for SecurityLog ? */
        if( SECURITY_LOG_FILE == eLogFile)
        {
            pLogFile = me->pSecurityLogFile;
        }
        /// \todo 02/17/2022 CPK call to L4_ConsoleMgrSendRequest to be reviewed during other MCP commands review - added to support blackbox testing
        if ((!L4_ConsoleMgrInitDone()) && (L4_CommStatusActive()))
        {
            /* console manager initialized and we have an active connection */
            L4_ConsoleMgrSendRequest(COMM_CONN_ACTIVE, SERIALCMD_DEBUG_STR,(uint8_t *)pu8String, MAX_LOG_STRING_LEN);
        }
        /* Do we have a valid Log file handle? */
        if (NULL == pLogFile)
        {
            /* Nope */
            break;
        }
        /* Send the string to the Filesystem */
        (void)FsWrite(pLogFile, pu8String, StringLenIn, NULL);

    } while (false);
}

/* ========================================================================== */
/**
 * \brief  Rotates the Event Log.
 *
 * \details This function rotates the log. For time being, it just closes
 *          and opens the Eventlog, but in future we could encrypt, archive etc.
 *
 * \note    This function depends on the working directory being set. (FS_WorkingDirSet())

 * \param   me          - Pointer to local data store
 *
 * \return  bool - Error status: True if failure, false if success
 *
 * ========================================================================== */
static bool RotateEventLog(Logger * const me)
{
    FS_ERR  FsErr;                               /* FS Status Return */
    bool    Status;                              /* Function error status. True if error. */

    /* Start with Error status */
    Status = true;

    do
    {
        /* Do we have an active Data Directory Path? (Working directory set) */
        FS_WorkingDirGet(pFilePath, LOG_FILE_PATH_NAME_LEN, &FsErr);
        if ('0' == pFilePath[0])
        {
            /* Nope */
            break;
        }

        /* Do we have valid file? */
        if (NULL != me->pEventLogFile)
        {
            /* Close the Log. */
            FsClose(me->pEventLogFile);
        }

        /* Open the log in the current working directory */
        FsErr = FsOpen(&me->pEventLogFile, EVENT_LOG_NAME, FS_MODE_A);

        /* Any Error */
        if (FS_ERR_NONE != FsErr)
        {
            Log(ERR, "Logger: RotateEventLog, FsOpen Failed");
            break;
        }

        /* Success */
        Status = false;

    } while (false);

    return Status;
}

/* ========================================================================== */
/**
 * \brief  Creates the Security Log in the current working directory. Security log file is located
 *         on the SD_CARD for security event purposes.
 *
 * \details This function creates the log. For time being, it just closes
 *          and opens the Securitylog, but in future we could encrypt, archive etc.
 *          This file is used to Log events related to "Device Additions(1-wire, USB,charger etc..)
 *          and un-authenticated devices.
 *
 * \note    This function depends on the working directory being set. (FS_WorkingDirSet())

 * \param   me          - Pointer to local data store
 *
 * \return  bool - Error status: True if failure, false if success
 *
 * ========================================================================== */
static bool CreateSecurityLog(Logger * const me)
{
    FS_ERR  FsErr;                               /* FS Status Return */
    bool    Status;                              /* Function error status. True if error. */

    /* Start with Error status */
    Status = true;

    do
    {
        /* Do we have an active Data Directory Path? (Working directory set) */
        FS_WorkingDirGet(pFilePath, LOG_FILE_PATH_NAME_LEN, &FsErr);
        if ('0' == pFilePath[0])
        {
            /* Nope */
            break;
        }

        /* Do we have valid file? */
        if (NULL != me->pSecurityLogFile)
        {
            /* Close the Log. */
            FsClose(me->pSecurityLogFile);
        }

        /* Open the log in the current working directory */
        FsErr = FsOpen(&me->pSecurityLogFile, SECURITY_LOG_NAME, FS_MODE_A);

        /* Any Error */
        if (FS_ERR_NONE != FsErr)
        {
            Log(ERR, "Logger: CreateSecurityLog, FsOpen Failed");
            break;
        }

        /* Success */
        Status = false;

    } while (false);

    return Status;
}

/* ========================================================================== */
/**
 * \brief  This function reads the Handle Serial Number.
 *
 * \details This function reads the Handle Serial Number from MemoryLayoutHandle_Ver2 structure.
 * in case of failure, Handle Serial Number string will be null
 * \todo    09/26/21 SAK - To add the real function to get Handle serial number.
 * So far, it simply returns some artificial string.
 *
 * \param  pointer to Handle Serial Number string
 *
 * \return  < None >
 *
 * ========================================================================== */
static void GetHandleSerialNumber(int8_t *pSerialNumber)
{
    AM_HANDLE_IF *pHandleData; /* Handle Data */

    // Get Handle Data
    pHandleData = Signia_GetHandleIF();

    // Copy the Handle Lot Number to requested pSerialNumber
    memcpy(pSerialNumber, pHandleData->Data.LotNumber, ONEWIRE_LOT_NUMBER_LENGTH);
}

/* ========================================================================== */
/**
 * \brief  This function creates the System Log file.
 *
 * \details This function creates the System Log file in the root directory of SD card.
 *
 * \todo    09/26/21 SAK - Add the real function to get Handle serial number.
 *
 * \param   < None >
 *
 * \return  false in case of success, and true in case of failure
 *
 * ========================================================================== */
bool CreateSystemLogFile(void)
{
    FS_ERR          fsErr;
    FS_FILE         *pFile;
    bool            bStatus;            /* Function error status. True if error. */
    uint32_t        index;
    char            SerialNumber[HANDLE_SERIAL_NUMBER_LEN_MAX];
    char            sSystemLogData[SYSTEM_LOG_DATA_MAX];                // Variable to write System Log data
    uint16_t        BattChargeCycleCount;                               // Variable to store Cycle Count
    FS_SDCARD_INFO  SDInfo;                                         // SD Card info
    AM_HANDLE_IF    *pHandle;
    BLOB_POINTERS   SystemLogBlobPointers;
    unsigned char   HandleOneWireMemory[ONEWIRE_MEMORY_TOTAL_SIZE];
    char            sOneWire[OW_MEM_MAX_STRING_LENGTH];
    unsigned char   LastClamshellAddress[DEV_ADDR_LENGTH];
    uint32_t        OnewireIndex;
    uint32_t        MemoryIndex;

    pHandle = (AM_HANDLE_IF *)Signia_AdapterManagerDeviceHandle (AM_DEVICE_HANDLE);

    bStatus = true;               /* Initialize to return Error */
    pFile = NULL;
    MemoryIndex = 0;

    do
    {
        if (!FsIsInitialized())
        {
            Log(DBG, "Logger: CreateSystemLogFile: Filesys Not Initialized");
            break;
        }

        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        memset(sHandleSerialNumber, NULL, HANDLE_SERIAL_NUMBER_LEN_MAX);

        GetHandleSerialNumber(sHandleSerialNumber);

        for (index=0; index<HANDLE_SERIAL_NUMBER_LEN_MAX; index++)
        {
            // filename must be alphanumeric
            if ( ((sHandleSerialNumber[index] >= '0') && (sHandleSerialNumber[index] <= '9')) ||
                 ((sHandleSerialNumber[index] >= 'A') && (sHandleSerialNumber[index] <= 'Z')) ||
				 ((sHandleSerialNumber[index] >= 'a') && (sHandleSerialNumber[index] <= 'z')) )
            {
                SerialNumber[index] = sHandleSerialNumber[index];  // copy the string, character by character
            }
            else
            {
                SerialNumber[index] = '\0';  // not alphanumeric, add NULL character to terminate the string
                break;
            }
        }

        if ( (0 == index) || (HANDLE_SERIAL_NUMBER_LEN_MAX <= index) )  // no serial number
        {
            Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath), "%s\\Syslog.txt", SDCARD_ROOT_DIR);
        }
        else
        {
            Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath), "%s\\Syslog_%s.txt", SDCARD_ROOT_DIR, SerialNumber);
        }

        if ('\0' == pDirPath[0])
        {
            fsErr = FS_ERR_NAME_NULL;
            break;
        }

        /* Open the file in Write Mode*/
        fsErr = FsOpen(&pFile, pDirPath, FS_MODE_W);
        if (FS_ERR_NONE != fsErr)
        {
            FsLogErr(fsErr);
            break;
        }

        Log(REQ,"System Log file created: %s", pDirPath+SDCARD_ROOT_DIR_LENGTH+1);  // do not print the full path, only the filename

        if(NULL != pHandle)
        {
            memset(sSystemLogData, NULL, SYSTEM_LOG_DATA_MAX);

            /* Battery Charge Cycle Count */
            L3_BatteryGetChgrCntCycle(&BattChargeCycleCount);

            /* Log Charge Cycle Count */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_CHRG_CYC_CNT=%d \r\n", BattChargeCycleCount);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Log Charge Cycle Limit (300) */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_CHRG_CYC_LMT=%d \r\n", BATT_MAX_CHARGECYCLECOUNT);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get SD Card Information */
            //        H_SD_USE_MEM  = Value MB (320 MB)
            //        H_SD_FREE_MEM = Value MB (7055 MB)
            //        H_SD_MANU     = Value (SanDisk)
            FsGetInfoSDCard(&SDInfo);

            /* Log Manufacturer of SD Card (right now we get Manufacturing ID 0x03 it's belong to SanDisk) */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_SD_MANU=%d \r\n", SDInfo.u8ManufID);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Log SD card Used Memory */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_SD_USE_MEM=%u MB \r\n", SDInfo.u32UsedSpace);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Log SD card Free Memory */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_SD_FREE_MEM=%u MB \r\n", SDInfo.u32FreeSpace);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Handle SW Version */
            /* Log Handle Software Version */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_SW_VER=%s \r\n", PLATFORM_VERSION);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Country Code and Log into System Log */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_COUNTRY=%d \r\n", pHandle->FlashData.CountryCode);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Hardware Version and Log into System Log */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_HW_VER=%d \r\n", pHandle->VersionNumber);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Software Part Number and Log into System Log */
            L4_GetBlobPointers(&SystemLogBlobPointers);
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_SW_PN=%s \r\n", SystemLogBlobPointers.StoredBlobHeader.BlobAgileNumber);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Handle Serial No and Log into System Log */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_SN=%s \r\n", sHandleSerialNumber);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Handle Procedure Count and Log into System Log */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_FIRE_CNT=%d \r\n", pHandle->Data.FireCount);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Handle Fire Limit and Log into System Log */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_FIRE_LMT=%d \r\n", pHandle->Data.FireLimit);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Handle Procedure Count and Log into System Log */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_PROC_CNT=%d \r\n", pHandle->Data.ProcedureCount);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Handle Procedure Limit and Log into System Log */
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_PROC_LMT=%u \r\n", pHandle->Data.ProcedureLimit);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Copy the Last stored clamshell and Log into System Log */
            memcpy(LastClamshellAddress, &(pHandle->Data.LastClamshellAddress), sizeof(pHandle->Data.LastClamshellAddress));
            BinaryArrayToHexString(LastClamshellAddress, ONEWIRE_ADDR_LENGTH, SerialNumber, HANDLE_SERIAL_NUMBER_LEN_MAX, true, true);
            Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "SHELL_OW_ID=0x%s \r\n", SerialNumber);
            FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);

            /* Get Handle OW Memomy Map and Log into System Log */
            memcpy(HandleOneWireMemory, &pHandle->Data, ONEWIRE_MEMORY_TOTAL_SIZE);

            for(OnewireIndex = 0; OnewireIndex < ONEWIRE_MEMORY_TOTAL_SIZE; OnewireIndex += OW_SECTION_SIZE)
            {
                BinaryArrayToHexString(&HandleOneWireMemory[OnewireIndex], OW_SECTION_SIZE, sOneWire, OW_MEM_MAX_STRING_LENGTH, true, false);
                Str_FmtPrint((CPU_CHAR *)sSystemLogData, sizeof(sSystemLogData), "H_OW_MEM_%d=0x%s \r\n", MemoryIndex, sOneWire);
                FsWrite(pFile, (uint8_t *)sSystemLogData, (uint32_t)Str_Len((CPU_CHAR *) sSystemLogData), NULL);
                MemoryIndex++;
            }

            Log(REQ, "System Log File Parameters logged Successfully");
        }
        else
        {
            Log(REQ, "Error Logging System Log File Parameters");
        }

        /* Close the File*/
        fsErr = FsClose(pFile);
        if (FS_ERR_NONE != fsErr)
        {
            FsLogErr(fsErr);
            break;
        }

        bStatus = false;
    } while (false);

    return bStatus;
}

/* ========================================================================== */
/**
 * \brief  This function creates the Event Log directory.
 *
 * \details This function creates the Event log directory structure in the SD card.
 *
 * \todo    01/27/21 GK - This function might delay the booting due to multiple
 *                        FsQueryDir() calls. Perform time analysis.
 *
 * \todo    01/30/21 GK - Revisit the files and folders’ date & time settings once
 *                        after RTC / Clk code is ready. Now it defaults to 1/1/2000
 *                        12:00 AM. [uC/FS usermanual - [F3-1(6)] uC/FS uses the date
 *                        and time information from uC/Clk to update files and
 *                        directories with the proper creation/modification/access
 *                        time].
 *
 * \param   me - Pointer to local data store
 *
 * \return  None
 *
 * ========================================================================== */
static bool CreateSDCardDataDirectories(Logger * const me)
{
    bool            bStatus;            /* Function error status. True if error. */
    FS_ERR          eFsErr;             /* FS Status Return */
    FS_ENTRY_INFO   xFindInfo;          /* FS Directory Info */
    uint16_t        u16IdxLevelOne;     /* Data folder Index One [e.g.: data_000001] */
    uint16_t        u16IdxLevelTwo;     /* Data folder Index Two [e.g.: 000001] */

    /* Start with Error status */
    bStatus = true;

    do
    {   /* Is the Filesystem Initialized? */
        if (!FsIsInitialized())
        {
            Log(DBG, "Logger: Filesys Not Initialized, Exit");
            break;
        }

        /* Change to "sdcard:0:\\" directory */
        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath), "%s\\", SDCARD_ROOT_DIR);
        eFsErr = FsChangeDir(pDirPath);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(DBG, "Logger: FsChangeDir '%s', Failed", SDCARD_ROOT_DIR);
            break;
        }

        /* Query for "data" folder */
        eFsErr = FsQueryDir(DATA_DIR, &xFindInfo);
        if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
        {
            /* We dont have "data" folder, create it. */
            eFsErr = FsMakeDir(DATA_DIR);
            if (FS_ERR_NONE != eFsErr)
            {
                Log(DBG, "Logger: FsMakeDir '%s', Failed", DATA_DIR);
                break;
            }
        }
        /* Query for "settings" folder */
        eFsErr = FsQueryDir(SETTINGS_DIR, &xFindInfo);
        if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
        {
            /* We dont have "settings" folder, create it. */
            eFsErr = FsMakeDir(SETTINGS_DIR);
            if (FS_ERR_NONE != eFsErr)
            {
                Log(DBG, "Logger: FsMakeDir '%s', Failed", SETTINGS_DIR);
                break;
            }
        }
        /* Change to "sdcard:0:\\data" directory */
        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath), "%s\\%s", SDCARD_ROOT_DIR, DATA_DIR);
        eFsErr = FsChangeDir(pDirPath);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(DBG, "Logger: FsChangeDir '%s', Failed", SDCARD_ROOT_DIR);
            break;
        }

        /* Look for proper L1 & L2 folders */
        u16IdxLevelOne = 1u;
        u16IdxLevelTwo = 0u;

        /* Lets check for "sdcard:0:\\data\\data_000001" folder */
        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath), "%s_%06d",
                     DATA_DIR, u16IdxLevelOne);
        eFsErr = FsQueryDir(pDirPath, &xFindInfo);
        if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
        {
            /* No data directories created yet.
            Create the first L1 directory. "sdcard:0:\\data\data_000001"*/
            memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
            Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                         "%s\\%s\\%s_%06d",
                         SDCARD_ROOT_DIR, DATA_DIR, DATA_DIR, u16IdxLevelOne);
            eFsErr = FsMakeDir(pDirPath);
            if (FS_ERR_NONE != eFsErr)
            {
                Log(DBG, "Logger: FsMakeDir '%s', Failed", pDirPath);
                break;
            }
        }
        else
        {
            /* If we are here, then we know "sdcard:0:\\data\data_000001" already exists because of the above test. */

            /* Now lets find the LAST L1 directory, "sdcard:0:\\data\data_XXXXXX" */
            for (u16IdxLevelOne = MAX_SUBDIR_PER_MAINDIR + 1u;
                 u16IdxLevelOne < MAX_DIR_LIMIT;
                 u16IdxLevelOne += MAX_SUBDIR_PER_MAINDIR)
            {
                /* Lets check for "data_000051, data_000101, data_000151 etc" folders */
                memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
                Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                             "%s_%06d",
                             DATA_DIR, u16IdxLevelOne);
                eFsErr = FsQueryDir(pDirPath, &xFindInfo);
                if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
                {
                    break;
                }
            }

            /* Got the Non Existing L1 index, Go back to the last existing L1 directory. */
            u16IdxLevelOne -= MAX_SUBDIR_PER_MAINDIR;

            /* If we are here, then we know the proper L1 Directory. */

            /* Now lets find the LAST L2 directory, "sdcard:0:\\data\data_XXXXXX\XXXXXX" */
            for (u16IdxLevelTwo = 0;
                 u16IdxLevelTwo < MAX_DIR_LIMIT;
                 u16IdxLevelTwo++)
            {
                /* Lets check for "000051, 000052, 000054 etc", or "000101, 000102, 000103 etc" folders */
                memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
                Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                             "%s_%06d\\%06d",
                             DATA_DIR, u16IdxLevelOne, u16IdxLevelTwo + u16IdxLevelOne);
                eFsErr = FsQueryDir(pDirPath, &xFindInfo);
                if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
                {
                    break;
                }
            }

            /* Check if the L2 Directory Maxxed out the number of L1 directories. */
            if (u16IdxLevelTwo >= MAX_SUBDIR_PER_MAINDIR)
            {
                /* Yes */
                u16IdxLevelTwo = 0u;

                /* Yes, Create a new L1 Directory and move to it */
                u16IdxLevelOne += MAX_SUBDIR_PER_MAINDIR;
                memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
                Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                             "%s_%06d",
                             DATA_DIR, u16IdxLevelOne);
                eFsErr = FsMakeDir(pDirPath);
                if (FS_ERR_NONE != eFsErr)
                {
                    Log(DBG, "Logger: FsMakeDir '%s', Failed", pDirPath);
                    break;
                }
            }
        }

        /* If we are here, then we know the proper L2 Directory. */

        /* Create a new L2 Directory "sdcard:0:\\data\\data_XXXXXX\XXXXXX" directory */
        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                     "%s\\%s\\%s_%06d\\%06d",
                     SDCARD_ROOT_DIR, DATA_DIR, DATA_DIR, u16IdxLevelOne, u16IdxLevelTwo + u16IdxLevelOne);
        eFsErr = FsMakeDir(pDirPath);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(DBG, "Logger: FsMakeDir '%s', Failed", pDirPath);
            break;
        }

        /* Change to newly created L2 directory. */
        eFsErr = FsChangeDir(pDirPath);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(DBG, "Logger: FsChangeDir '%s', Failed", pDirPath);
            break;
        }

        /* Copy the current active directory path to the Global path */
        Str_Copy_N((CPU_CHAR *)&me->ActiveDataDirPath, (CPU_CHAR *)pDirPath, FS_CFG_MAX_PATH_NAME_LEN);

        /* Success */
        bStatus = false;

    } while (false);

    return bStatus;
}

/* ========================================================================== */
/**
 * \brief  This function initiates cleanup of older RDF files on SD Card.
 *
 * \details This function initiates cleanup of older RDF files. Number of RDF files to be deleted
 *          is dependent on the "Requested Cleanup size" passed to this function. This function
 *          is being run as a seperate task to reduce the processing overhead and startup time.
 *
 * \todo    02/12/21 CPK - This function could be moved to rdf.c
 *
 * \param   pRdfCleanupSize - Pointer to the memory size that needs to be cleaned up.
 *
 * \return  None
 *
 * ========================================================================== */
void CleanupOldRdfFiles(void *pRdfCleanupSize)
{
    FS_ERR          eFsErr;             /* FS Status Return */
    FS_ENTRY_INFO   xFindInfo;          /* FS Directory Info */
    uint8_t         OsError;        /* OS errors */

    /* initialize computed Memsize  */
    MemSize = 0x0;

    do
    {
         /* Change to "sdcard:0:\\" directory */
        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath), "%s\\", SDCARD_ROOT_DIR);
        eFsErr = FsChangeDir(pDirPath);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(DBG, "Logger: FsChangeDir '%s', Failed", SDCARD_ROOT_DIR);
            break;
        }

        /* Query for "data" folder */
        eFsErr = FsQueryDir(DATA_DIR, &xFindInfo);
        if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
        {
            /* We dont have "data" folder.. break */
            {
                Log(DBG, "Logger: FsQueryDir '%s', Failed", DATA_DIR);
                break;
            }
        }

        /* Change to "sdcard:0:\\data" directory */
        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath), "%s\\%s", SDCARD_ROOT_DIR, DATA_DIR);
        eFsErr = FsChangeDir(pDirPath);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(DBG, "Logger: FsChangeDir '%s', Failed", SDCARD_ROOT_DIR);
            break;
        }
        else
        {
            /* Search for rdf files in Level1 and Level2 Data folders   */
            SearchOldRdfFiles(*((uint32 *)pRdfCleanupSize));
        }
    } while (false);

    /* wait for the task to be deleted */
    while ( true )
    {
        OSTimeDly(SEC_10);
        /* Delete cleanup task */
        OsError = OSTaskDel(TASK_PRIORITY_CLEANUP);
        if ( OS_ERR_NONE == OsError )
        {
            Log(DBG, "RDF Cleanup: Deleted Cleanup task");
        }
    }
}

/* ========================================================================== */
/**
 * \brief  This function  deletes older RDF files on SD Card.
 *
 * \details This function iterates through all the Data directories and finds Older RDF files
 *          and deletes them from SD Card. Number of RDF files to be deleted is dependent
 *          on the "Requested Cleanup size" passed to this function. After the cleanup is
 *          completed a signal is posted to the Logger AO.
 *
 * \todo    02/12/21 CPK - This function could be moved to rdf.c
 *
 * \param   CleanupSize - memory size that needs to be cleaned up. Used to decide the cleanup completion.
 *
 * \return  None
 *
 * ========================================================================== */
static bool SearchOldRdfFiles(FS_FILE_SIZE CleanupSize)
{
    uint16_t        u16IdxLevelOne;     /* Data folder Index One [e.g.: data_000001] */
    uint16_t        u16IdxLevelTwo;     /* Data folder Index Two [e.g.: 000001] */
    FS_ERR          eFsErr;             /* FS Status Return */
    FS_ENTRY_INFO   xFindInfo;                              /* FS Directory Info */
    bool CleanupDone;                                       /* Flag indicating cleanup done */

    CleanupDone = false;
    Log(DBG, "RDF Cleanup: Cleanup Task Started");

    do
    {
        /* If we are here, then we must be in "sdcard:0:\\data" directory . */
        /* Look for proper L1 & L2 folders */
        u16IdxLevelOne = 1u;
        u16IdxLevelTwo = 0u;
        /* Now lets find the LAST L1 directory, "sdcard:0:\\data\data_XXXXXX" */
        for (u16IdxLevelOne =  1u;
             ((u16IdxLevelOne < MAX_DIR_LIMIT) && (!CleanupDone));
             u16IdxLevelOne += MAX_SUBDIR_PER_MAINDIR)
        {
            /* Lets check for "data_000051, data_000101, data_000151 etc" folders */
            memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
            Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                         "%s_%06d",
                         DATA_DIR, u16IdxLevelOne);
            eFsErr = FsQueryDir(pDirPath, &xFindInfo);
            if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
            {
                Log(DBG, "Logger: L1 FsChangeDir '%s', Failed", pDirPath);
                break; /* break if L1 folder not found */
            }

            /* If we are here, then we know the proper L1 Directory. */
            /* Now lets find the L2 directory, "sdcard:0:\\data\data_XXXXXX\XXXXXX" */
            for (u16IdxLevelTwo = u16IdxLevelOne;
                 u16IdxLevelTwo < (u16IdxLevelOne + MAX_SUBDIR_PER_MAINDIR);
                 u16IdxLevelTwo++)
            {
                if ( CleanupDone )
                {
                    break;
                }
                /* Search RDF files in "000051, 000052, 000054 etc", or "000101, 000102, 000103 etc" folders */
                memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
                Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                             "%s_%06d\\%06d",
                             DATA_DIR, u16IdxLevelOne, u16IdxLevelTwo );
                eFsErr = FsQueryDir(pDirPath, &xFindInfo);

                if (eFsErr == FS_ERR_ENTRY_NOT_FOUND)
                {
                    Log(DBG, "Logger: L2 FsChangeDir '%s', Failed", pDirPath);
                    break;
                }
                else
                {
                    /* Valid Data folder found - if we are here search and delete rdf files */
                    CleanupDone = DeleteOldRdfFiles(CleanupSize, u16IdxLevelOne, u16IdxLevelTwo);
                } /* Else - Valid L2 folder found*/
            } /* Search Valid L2 Directory*/
        } /* Search Valid L1 Directory*/
    } while ( false );

return false;
}

/* ========================================================================== */
/**
 * \brief  This function deletes older RDF files on SD Card.
 *
 * \details This function iterates through specified Data directories and finds Older RDF files
 *          and deletes them from SD Card. Number of RDF files to be deleted is dependent
 *          on the "Requested Cleanup size" passed to this function. After the cleanup is
 *          completed a signal is posted to the Logger AO.
 *
 * \todo    02/12/21 CPK - This function could be moved to rdf.c
 *
 * \param   CleanupSize - memory size that needs to be cleaned up. Used to decide the cleanup completion.
 * \param   u16IdxLevelOne - Directory level1 indicating Data_xxxxxx folder in Data directory.
 * \param   u16IdxLevelTwo - Directory level2 indicating Data_xxxxxx\yyyyyy\ folder in Data_xxxxxx directory.
 *
 * \return  completion status based on the  memory deleted(MemSize) compared to actual memory to be cleanedup(CleanupSize)
 *
 * ========================================================================== */
static bool DeleteOldRdfFiles(FS_FILE_SIZE CleanupSize, uint16_t u16IdxLevelOne, uint16_t u16IdxLevelTwo)
{
    FS_ERR          eFsErr;                                 /* FS Status Return */
    uint16_t        RdfFileNumber;                          /* rdf file name */
    FS_ENTRY_INFO   RdfFileInfo;                            /* rdf Info */
    FS_FILE         *pFile;                                 /* rdf file pointer */
    bool CleanupDone;                                       /* Flag indicating cleanup done */

    pFile = NULL;
    CleanupDone = false;
    /* RDF files are sequentually named as 00000.rdf, 00001.rdf etc.  */
    RdfFileNumber = 0x0;

    do
    {
        memset(pDirPath, NUL, FS_CFG_MAX_PATH_NAME_LEN);
        Str_FmtPrint((CPU_CHAR *)pDirPath, sizeof(pDirPath),
                     "%s_%06d\\%06d\\%05d.rdf",
                     DATA_DIR, u16IdxLevelOne, u16IdxLevelTwo,RdfFileNumber);
        /*  RDF File exists ? */
        eFsErr = FsOpen(&pFile, pDirPath, FS_MODE_R);
        if (FS_ERR_NONE != eFsErr)
        {
            /* break - we dint find the sequential RDF File name */
            break;
        }

        FsClose(pFile);
        /* Read rdf file size and increment total memory cleanedup */
        FsGetInfo(pDirPath, &RdfFileInfo);
        /// \todo 12/02/2021 CPK Remove below macro - Debug purpose only to prevent accidental deletion
        #ifdef ENABLE_RDF_DEL
        FsDelete(pDirPath);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(DBG, " RDF Cleanup: RDF-File '%s'Delete, Failed");
            /* break if we dont find the sequential RDF File name */
            break;
        }
        #endif
        MemSize += RdfFileInfo.Size;
        Log(DBG, " RDF Cleanup: Deleted RDF-File '%s File_Size %ld",pDirPath, RdfFileInfo.Size);

        if ( MemSize > CleanupSize)
        {
            /*  memory cleanup size acheived - post signal about the completion */
            CleanupDone = true;
            Log(DBG, "RDF Cleanup: ------------------------------------------------------------");
            Log(DBG, "RDF Cleanup: Cleanup Finished");
            Log(DBG, "RDF Cleanup: %d.RDF Files Deleted, Memory Requested %ld , Memory Added %ld", RdfFileNumber,CleanupSize,MemSize);
            Log(DBG, "RDF Cleanup: ------------------------------------------------------------");
            MemSize = 0x0;
            /* Allow Enough time to allow handle to startup and be able to receive signals */
            OSTimeDly(SEC_10);
            break;
        }
        /* This is low priority background task - allow time for other tasks */
        OSTimeDly(SEC_1);
        RdfFileNumber++;
    } while ( MAX_RDF_FILE_LIMIT > RdfFileNumber); /* While we are still searching */
return CleanupDone;
}

/* ========================================================================== */
/**
 * \brief   Append log synopsis to a file.
 *
 * \details This function writes the file path and current date/time to a file
 *
 * \param   me - Pointer to local data store
 *
 * \todo 11/11/2021 DAZ - Don't know why we need this. I think it wants to be static.
 *
 * \return  None
 *
 * ========================================================================== */
static void LogWriteSynopsis(Logger * const me)
{
    FS_ERR         FsErr;
    FS_FILE       *pTempFile;
    CLK_DATE_TIME  DateTime;

    if (me->ActiveDataDirPath[0] != 0)
    {
        pTempFile = FSFile_Open(SYNOPSIS_FILE_NAME, FS_FILE_ACCESS_MODE_WR | FS_FILE_ACCESS_MODE_CREATE, &FsErr);   // Open the file
        if (FS_ERR_NONE == FsErr)
        {
            FSFile_PosSet(pTempFile, 0, FS_FILE_ORIGIN_END, &FsErr);    // Append to the file
            if (FsErr == FS_ERR_NONE)
            {
                // Write output path and time/date
                FSFile_Wr(pTempFile, &me->ActiveDataDirPath[DATA_PATH_IGNORE_PREFIX_LENGTH], strlen((char const *)&me->ActiveDataDirPath[DATA_PATH_IGNORE_PREFIX_LENGTH]), &FsErr);

                Clk_GetDateTime(&DateTime);
                Clk_DateTimeToStr(&DateTime, CLK_STR_FMT_YYYY_MM_DD_HH_MM_SS, DateStr, sizeof(DateStr) - 1);
                FSFile_Wr(pTempFile, "   ", 3, &FsErr);
                FSFile_Wr(pTempFile, DateStr, strlen(DateStr), &FsErr);
                FSFile_Wr(pTempFile, "\r\n", 2, &FsErr);
            }

            FSFile_Close(pTempFile, &FsErr);
        }
    }
}

/* ========================================================================== */
/**
 * \brief   Initialize the FileSystem Support for the Logger Module.
 *
 * \details This function initializes the FileSystem Support for the Logger
 *          module. A separate init, decouples the common init, so that
 *          if there are any errors during Filesystem initialization,
 *          the logger can log those messages via Debug UART.
 *
 * \param   me - Pointer to local data store
 *
 * \return  None
 *
 * ========================================================================== */
static void LogFsInit(Logger * const me)
{
    FS_ERR  eFsErr;                             /* FS Status Return */

    do
    {   /* Create New Event Log Directory */
        if (CreateSDCardDataDirectories(me))
        {
            Log(ERR, "Logger: LogFsInit, CreateSDCardDataDirectories, Failed");
            break;
        }

        /* Create a New Event Log */
        if (RotateEventLog(me))
        {
            Log(ERR, "Logger: LogFsInit, RotateEventLog, Failed");
            break;
        }

        /* Do we have a valid Event Log file? */
        if (NULL != me->pEventLogFile)
        {
            /* Log the file creation */
            Log(REQ, "Logger: File Opened, \"%s\"", EVENT_LOG_NAME);
        }

        /* Create a New Security Log */
        if (CreateSecurityLog(me))
        {
            Log(ERR, "Logger: LogFsInit, CreateSecurityLog, Failed");
            break;
        }

        /* Do we have a valid Security Log file? */
        if (NULL != me->pSecurityLogFile)
        {
            /* Log the file creation */
            Log(REQ, "Logger: File Opened, \"%s\"", SECURITY_LOG_NAME);
        }

        /* Get the current working directory */
        eFsErr = FsGetCWDir(pDirPath, FS_CFG_MAX_PATH_NAME_LEN);
        if (FS_ERR_NONE != eFsErr)
        {
            Log(ERR, "Logger: LogFsInit, FsGetCWDir Failed");
            break;
        }

        /* Log the new path details. */
        Log(REQ, "Logger: Data Path, \"%s\"", pDirPath);

        Log(REQ, "Logger: Logging to Filesys, Started.");

    } while (false);
}


/* ask QM to define the Logger class -----------------------------------------*/

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::Logger} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Logger} ..........................................................*/
/*.${AOs::Logger::SM} ......................................................*/
static QState Logger_initial(Logger * const me, void const * const par) {
    /*.${AOs::Logger::SM::initial} */
    /*
        Note: All code in the top level initial transition runs in the context of the task that calls
              the constructor function (LoggerCtor()), rather than the AO's context (TCB/stack frame).
              Further, this continues until the entry code of the state pointed to by the initial transition
              completes. (If that state contains an initial transition, execution continues in the caller's
              context until the bottom state's entry code is executed)

              This is of importance only if operations during this time might cause the invoking task's stack
              to overflow, or there is some TCB specific information required by an operation happening at this
              time.

              Further, since other active objects may not have been instantiated yet, do not post to other AOs
              during this time.

              After the initial state entry code has been executed, all other invocations of the AO will
              happen in the AO's context.

              One way to force a context change is to point the initial transition to a dummy state which
              arms a timer. When the timer times out & sends an event to the state, it will be executing
              in the AO's context. That event can then transition to the next state, whose entry code will
              be run in the AO's context.
    */

    /* ========================================================================== */
    /**
     * \brief   Logger initial transition
     *
     * \details This function is the entry point to the state machine for the
     *          Logger active object. It initializes the RDF file and opens
     *          the event log. After initializing the event log file it transitions
     *          to the Startup state.
     *
     * \param   me - Pointer to local data store
     * \param   e  - Pointer to present event
     *
     * \return  State transition status. (Q_HANDLED(), Q_SUPER(), Q_UNHANDLED())
     *
     * ========================================================================== */

    (void)par; /* unused parameter */

    // Issue fake timeout event as 1st event in the queue to
    // force a context switch in the Startup state to finish initialization in the Logger context.
    AO_Post(AO_Logger, &FakeTimeout, NULL);

    L2_UartInit(DEBUG_UART, DEBUG_UART_BAUD);    // Set up debug uart

    // Print the startup message. We aren't REALLY initialized yet, but we want this to
    // appear before any log messages that FSInit/CreateSystemLogFile/LogFsInit may issue.
    Log(REQ, "Logger: Initialized");
    /* Logger is initialized, log version */
    Log(REQ, "Signia Platform Version: %s\n", PLATFORM_VERSION);
    Log(DBG, "Log message example =         4,     1,    427,     3,        100: example");
    Log(DBG, "Log message format  = Log Level, Group, Line #, index, time(msec): message");

    me->EventLogIsDirty = false;  // Nothing logged yet

    // Subscribe to SD card in/out signals
    AO_Subscribe(AO_Logger, P_SD_CARD_INSERTED_SIG);
    AO_Subscribe(AO_Logger, P_SD_CARD_REMOVED_SIG);
    return Q_TRAN(&Logger_Startup);
}

/**
 * \brief   This is the startup state for the Logger Active Object
 *
 * \details This state processes a dummy timeout event posted to the Logger AO
 *          by its initial transition. The dummy timeout event is posted by the
 *          initial transition to insure that it is the 1st event in the queue.
 *          When this event is processed, it is running in the Logger AO context.
 *          This is the 1st time this occurrs, so initialization that must be run
 *          in the Logger context (instead of the system startup context) is
 *          performed here. (In this case, the setting of the working directory
 *          in the file system).
 *
 *          This construct is due to the nature of the Micrium port for QPC.
 *
 * \sa      FS_WorkingDirSet documentation in Micrium. (fs.c)
 *
 * \param   me - Pointer to local data store
 * \param   e  - Pointer to present event
 *
 * \return  State transition status: Q_HANDLED(), Q_UNHANDLED(), Q_TRAN(), Q_SUPER()
 *
 * ========================================================================== */
/*.${AOs::Logger::SM::Startup} .............................................*/
static QState Logger_Startup(Logger * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Logger::SM::Startup::TIMEOUT} */
        case TIMEOUT_SIG: {
            // This event does not come from a timer, but rather is
            // posted by the initial transition. This is done to insure
            // that this is the first event in the queue, before any
            // log or RDF requests can be issued.

            // When this event is executed, this is the 1st time the
            // logger code is running in the logger context.

            // The working directory is set here before any RDF events
            // can be processed. The working directory must be set
            // for the active task.

            FS_ERR FsErr;    // Error return

            FS_WorkingDirSet((char *)&me->ActiveDataDirPath, &FsErr);    // Set working directory
            status_ = Q_TRAN(&Logger_Operate);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * \brief   This is the running state for the Logger Active Object
 *
 * \details The Logger object handles both Event & RDF (streaming) data logging.
 *          It responds to the following signals:
 *             - TIMEOUT_SIG
 *             - P_SD_CARD_INSERTED_SIG
 *             - P_SD_CARD_REMOVED_SIG
 *             - RDF_OPEN_SIG
 *             - RDF_DATA_SIG
 *             - RDF_CLOSE_SIG
 *             - PRINTF_SIG
 *
 * \param   me - Pointer to local data store
 * \param   e  - Pointer to present event
 *
 * \return  State transition status: Q_HANDLED(), Q_UNHANDLED(), Q_TRAN(), Q_SUPER()
 *
 * ========================================================================== */
/*.${AOs::Logger::SM::Operate} .............................................*/
static QState Logger_Operate(Logger * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Logger::SM::Operate} */
        case Q_ENTRY_SIG: {
            FsInit();
            LogFsInit(me);                // Create log file directory structure as required & create event log file
            LogWriteSynopsis(me);         // Update synopsis file w/ datestamp of newly created folder

            AO_TimerArm(&me->SDCardPresenceTimer, ROTATE_LOG_TIMEOUT, ROTATE_LOG_TIMEOUT); // Start rotate timer
            AO_TimerArm(&me->Timer, FLUSH_EVENT_LOG_TIMER_INTERVAL_LONG, 0);  //KA: cs 1587 uses the line above

            LoggerInitialized = true;

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate} */
        case Q_EXIT_SIG: {
            AO_TimerDisarm(&me->Timer);     // Not really required - just to be sure & illustrate usage
            AO_TimerDisarm(&me->SDCardPresenceTimer); // Not really required - just to be sure & illustrate usage
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::P_SD_CARD_INSERTED} */
        case P_SD_CARD_INSERTED_SIG: {
            if (!LoggerDisabled)
            {
                FSDev_Open("sdcard:0:", (void *)0, &me->FsErr);
                FSVol_Open("sdcard:0:", "sdcard:0:", 0, &me->FsErr);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::P_SD_CARD_REMOVED} */
        case P_SD_CARD_REMOVED_SIG: {
            FSVol_Close("sdcard:0:", &me->FsErr);
            FSDev_Close("sdcard:0:", &me->FsErr);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::RDF_OPEN} */
        case RDF_OPEN_SIG: {
            if (!LoggerDisabled)
            {
                RdfProcessOpenSignal(e);
                SdhcLEDCnt++;
                L3_GpioCtrlSetSignal(GPIO_SDHC0_LED);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::RDF_DATA} */
        case RDF_DATA_SIG: {
            #if REPORT_TIME_GREATER_THAN
            static uint32_t MaxTime = 0;
            #endif

            if (!LoggerDisabled)
            {
                #if REPORT_TIME_GREATER_THAN            // Keep track of maximum time spent logging an RDF record
                uint32_t ElapsedTime;
                uint32_t StartTime = OSTimeGet();
                #endif

                RdfProcessDataSignal(e);

                #if REPORT_TIME_GREATER_THAN
                ElapsedTime = OSTimeGet() - StartTime;
                if (ElapsedTime > REPORT_TIME_GREATER_THAN)
                {
                     Log(DBG, "SD Card elapsedTime = %d", ElapsedTime);

                    if (ElapsedTime > MaxTime)
                    {
                        MaxTime = ElapsedTime;
                        Log(DBG, "SD Card maxTime   = %d", MaxTime);
                    }
                }
                #endif
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::RDF_CLOSE} */
        case RDF_CLOSE_SIG: {
            RdfProcessCloseSignal(e);
            if (--SdhcLEDCnt == 0)
            {
                L3_GpioCtrlClearSignal(GPIO_SDHC0_LED);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::PRINTF} */
        case PRINTF_SIG: {
            QEVENT_LOG_MSG *pLog;

            pLog = (QEVENT_LOG_MSG *)e;

            AO_TimerRearm(&me->Timer, FLUSH_EVENT_LOG_TIMER_INTERVAL_LONG);    // Restart timer. Do not timeout till period of no message activity

            SendMessageToLog(me, EVENT_LOG_FILE, pLog->Msg, strlen((char *)pLog->Msg));

            if (!me->EventLogIsDirty)        // File not dirty yet. Turn on SDHC LED
            {
                SdhcLEDCnt++;
                L3_GpioCtrlSetSignal(GPIO_SDHC0_LED);
                me->EventLogIsDirty = true;  // File is now dirty (pending flush)
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::TIMEOUT} */
        case TIMEOUT_SIG: {
            if (me->EventLogIsDirty)
            {
                // timeout occured, close file to save, then reopen
                FSFile_Close(me->pEventLogFile, &me->FsErr);  // Close event log to flush it & reopen if logging enabled.
                if (!LoggerDisabled)
                {
                    me->pEventLogFile = FSFile_Open(EVENT_LOG_NAME, FS_FILE_ACCESS_MODE_WR | FS_FILE_ACCESS_MODE_APPEND | FS_FILE_ACCESS_MODE_CREATE, &me->FsErr);
                    me->EventLogIsDirty = false;
                }
                else
                {
                    me->pEventLogFile = NULL;
                    if (--SdhcLEDCnt == 0)
                    {
                        L3_GpioCtrlClearSignal(GPIO_SDHC0_LED);
                    }
                    me->EventLogIsDirty = false;
                }

                // reset timer
                AO_TimerArm(&me->Timer, FLUSH_EVENT_LOG_TIMER_INTERVAL_LONG, 0);
            }

            if (me->SecurityLogIsDirty)
            {
                // timeout occurred, close file to save, then reopen
                FSFile_Close(me->pSecurityLogFile, &me->FsErr);  // Close event log to flush it & reopen if logging enabled.

                if (!LoggerDisabled)
                {
                    me->pSecurityLogFile = FSFile_Open(SECURITY_LOG_NAME, FS_FILE_ACCESS_MODE_WR | FS_FILE_ACCESS_MODE_APPEND | FS_FILE_ACCESS_MODE_CREATE, &me->FsErr);
                    me->SecurityLogIsDirty = false;
                }
                else
                {
                    me->pSecurityLogFile = NULL;
                    me->SecurityLogIsDirty = false;
                }
            }
            // Old timeout processing RotateEventLog(); // Don't know what this is?
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::SECURITY_LOG} */
        case SECURITY_LOG_SIG: {
            QEVENT_LOG_MSG *pLog;

            pLog = (QEVENT_LOG_MSG *)e;

            AO_TimerRearm(&me->Timer, FLUSH_EVENT_LOG_TIMER_INTERVAL_LONG);    // Restart timer. Do not timeout till period of no message activity

            SendMessageToLog(me, SECURITY_LOG_FILE, pLog->Msg, strlen((char *)pLog->Msg));

            if (!me->SecurityLogIsDirty)
            {
                me->SecurityLogIsDirty = true;  // File is now dirty (pending flush)
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Logger::SM::Operate::SD_CARD_PRESENCE_TIMEOUT} */
        case SD_CARD_PRESENCE_TIMEOUT_SIG: {
            /*  The HANDLE software shall enter SD_CARD_EM if the micro SD_CARD is not present during HANDLE_STARTUP
                and checked every 60 +/- 5 seconds thereafter */
            if (FS_ERR_NONE != FsIsSDCardPresent())
            {
                Log(REQ, "FileSys: SD Card Not Present");
                FaultHandlerSetFault(SDCARD_NOTPRESENT, SET_ERROR);
            }
            else
            {
               Log(REQ, "FileSys: SD Card Present");
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::Logger} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/******************************************************************************/
/*                             Global Function(s)                             */
/******************************************************************************/

/*.$define${AOs::LoggerCtor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * \brief   Constructor for the Logger Active Object
 *
 * \details Establishes the Active Object (AO) and executes the initial transition
 *          and state entry code. Other AO specific objects, such as timers, may
 *          be instantiated here.
 * \n \n
 *          The Logger "constructor" is provided outside of the Logger class,
 *          so that it can be used independently from the class. This is part
 *          of the "opaque pointer" design idiom.
 * \n \n
 *          Establishing the AO encompasses the following activities:
 *              - Initialize and register the task control block with Micrium.
 *                  - Set the stack
 *                  - Set the priority
 *                  - Set the name
 *              - Initialize and register the active object control block with QP/C.
 *                  - Set the event queue
 *                  - Pass user defined initialization parameters
 *
 * \note    The initial transition and state entry code (the 1st time) are executed
 *          in the calling task's context so care must be taken to consider the calling
 *          task's stack constraints and task dependent defaults, if any, when writing
 *          that code. This is usually not a problem, but when using certain features of
 *          Micrium (such as the file system), Micrium keeps certain configuration information
 *          in the task control block.
 *
 * \param   < None >
 *
 * \return  None
 *
 * ========================================================================== */
/*.${AOs::LoggerCtor} ......................................................*/
void LoggerCtor(void) {
    Logger *me = (Logger *)AO_Logger;

    AO_TimerCtor(&me->Timer, &me->super, TIMEOUT_SIG);  // Build timer
    AO_TimerCtor(&me->SDCardPresenceTimer, &me->super, SD_CARD_PRESENCE_TIMEOUT_SIG);  // Build timer

    AO_Start(AO_Logger,                             // Pointer to QActive object (AO)
             Q_STATE_CAST(&Logger_initial),         // Pointer to initial transition
             TASK_PRIORITY_LOG,                  // Task priority
             LoggerEventQueue,                      // Pointer to event queue
             LOGGER_EVQ_SIZE,                       // Size of event queue (in entries) This could be Q_DIM(MotorDevStubs_queueSto
             LoggerStack,                           // Pointer to stack (bottom)
             LOGGER_STACK_SIZE,                     // Stack size This could be Q_TIM(MotorDevStubs
             NULL,                                  // Pointer to object specific initialization parameters
             AOname);                               // Pointer to name of active object
}
/*.$enddef${AOs::LoggerCtor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* ========================================================================== */
/**
 * \brief   Creates the Log message and sends for logging.
 *
 * \details Main public function for the logging. It does the following
 *          - Checks the input Log level, Log Group
 *          - Creates the prefix string
 *              - [1-digit Debug Level],
 *              - [2-digit Group Identifier],
 *              - [4-digit Line Number],
 *              - [5-digit Log Count - Rollover Acceptable],
 *              - [System uptime in Milli secs]:
 *          - Appends the [Log String] to the prefix string
 *          - Push the string to circular buffer.
 *          - Posts the Log Msg Request to Log Msg Queue.
 *
 * \param   eLogFile  - Indicates the Log file the message to be Logged. LOG_FILE enumerates various Log files
 * \param   eLogLevel - Log Level Enum
 * \param   eLogGroup - Log Group Enum [By default it will be LOG_GROUP_IDENTIFIER,
 *                      every module shall define LOG_GROUP_IDENTIFIER to an enum as
 *                      per LOG_GROUP [eg: define LOG_GROUP_IDENTIFIER LOG_GROUP_MAIN]
 * \param   u16LineNumber - Line number from where the Log message originated
 * \param   *pcFormatString - Formated string [variadic arguments]
 *
 * \return  None
 *
 * ========================================================================== */
void LogMsg(LOG_FILE eLogFile, LOG_LEVEL eLogLevel, LOG_GROUP eLogGroup,
            uint16_t u16LineNumber, const char *pcFormatString, ...)
{
    OS_CPU_SR       cpu_sr;                             // Status register for critical section
    va_list         xArguments;                         /* variadic arguments */
    uint32_t        u32MilliSeconds;                    /* Millisecs up time */
    uint16_t        u16StringLen;                       /* String Length */
    QEVENT_LOG_MSG  *pLogMsg;                           /* Pointer to log message signal */
    static uint16_t u16LogCounter;                      /* Logger Counter, Rollover allowed. */

    do
    {   /* Validate inputs & Is Logger Initialized? */
        if ((eLogLevel >= LOG_LEVEL_LAST) ||
            (eLogGroup >= LOG_GROUP_LAST))
        {
            break;
        }

#ifndef DEBUG_CODE
        /* For clinical release, skip DEV & TRC logs. */
        if (eLogLevel < DBG)
        {
            break;
        }
#endif
        /* Get the time in milliseconds */
        u32MilliSeconds = SigTime();

/// \todo 05/27/2021 DAZ - Can we defer parsing to Logger object?
/// \todo 05/27/2021 DAZ - Post or publish parsed string? (If done here rather than AO)

        /* Get new log record - Message for Event Log ? */
        if (EVENT_LOG_FILE == eLogFile )
        {
            pLogMsg = AO_EvtNew(PRINTF_SIG, sizeof(QEVENT_LOG_MSG));
        }

        /* Get new log record - Message for Security Log ? */
        else if (SECURITY_LOG_FILE == eLogFile )
        {
            pLogMsg = AO_EvtNew(SECURITY_LOG_SIG, sizeof(QEVENT_LOG_MSG));
        }
        else  /*dummy else */
        {
            /* Do Nothing */
        }

        BREAK_IF(NULL == pLogMsg);                             // EvtNew failed.

        /* Clear the buffer */
        memset(&pLogMsg->Msg, NUL, MAX_LOG_STRING_LEN);        //  \todo - Do we need this?

        OS_ENTER_CRITICAL();    /// \todo 11/11/2021 DAZ -  I think these functions are not reentrant

        /* Create the Prefix string. */
        u16StringLen = Str_FmtPrint((CPU_CHAR *)(pLogMsg->Msg), MAX_LOG_STRING_LEN, "%1.1d,%2.2d,%4.4d,%5.5d,%d: ",    // \todo: Meaning of% 5.5d? Doesn't seem to be forcing fixed width fields. Maybe %05d?
                                    eLogLevel, eLogGroup, u16LineNumber, ++u16LogCounter, u32MilliSeconds);

        /* Hook for Logger Count value Rollover Check */
        TM_Hook(HOOK_LOGCNTROLLOVER, &u16LogCounter);

        /* Take control of the Var Args. */
        va_start(xArguments, pcFormatString);

        /* Create the Log String, limit the length */
        vsnprintf((char *)&pLogMsg->Msg + u16StringLen,
                  (MAX_LOG_STRING_LEN - (u16StringLen + LEN_CR_LF_NULL)), pcFormatString, xArguments);

        /* End the arguments. */
        va_end(xArguments);

        OS_EXIT_CRITICAL();

        /* Concatenate CR & LF */
        Str_Cat_N((char *)pLogMsg->Msg, STR_CR_LF, sizeof(pLogMsg->Msg));

        /* NOTE: As written, does not wait for free space in the queue. The assumption is there is always enough space.
                 AO_Post does not currently retuurn an error, but this can be changed. Old code didn't wait for levels < REQ. */

        /* Post the signal */
        AO_Post(AO_Logger, &pLogMsg->Event, NULL);

    } while (false);
}

/// \todo 11/15/2021 DAZ - This functionality came from Legacy. Don't know if there is a use for it yet.
/// \todo 11/18/2021 DAZ - If logger is disabled, RDF file operations are not performed.

/* ========================================================================== */
/**
 * \brief   Disable logging
 *
 * \details This function disables the Logger by closing its associated files and
 *          setting the variable LoggerDisabled to true.
 *
 * \param   < None >
 *
 * \return  None
 *
 * ========================================================================== */
void LogDisable(void)
{
    FS_ERR FsErr;

    // Allow any Logs sent before calling this function to make it to file
    OSTimeDly(50);

    LoggerDisabled = true;

    // Let existing files complete tasks after having disabled logger
    OSTimeDly(200);

    FSFile_Close(LocalLogger.pEventLogFile, &FsErr);   // Me pointer is not available here
    FSVol_Close("sdcard:0:", &FsErr);
    FSDev_Close("sdcard:0:", &FsErr);
    OSTimeDly(200);   // Give time for SD card to close
}

/* ========================================================================== */
/**
 * \brief   Determine if Logger is disabled
 *
 * \details Returns the state of the LoggerDisabled flag
 *
 * \param   < None >
 *
 * \return  true if logger disabled, false otherwise
 *
 * ========================================================================== */
bool LoggerIsDisabled(void)
{
    return LoggerDisabled;
}

/**
 * \}
 */

#ifdef __cplusplus  /* header compatible with C++ project */
}
#endif

