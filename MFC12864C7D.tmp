/*.$file${.::TestManager.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: TestManager.qm
* File:  ${.::TestManager.c}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-SP-170817A
* Issued to   : Covidien LP
* Framework(s): qpc
* Support ends: 2022-08-17
* Product(s)  :
* Signia Powered Stapler
*/
/*.$endhead${.::TestManager.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifdef __cplusplus  /* header compatible with C++ project */
extern "C"
{
#endif

/* ========================================================================== */
/**
 * \addtogroup TestManager
 * \{
 *
 * \brief   Active Object for Signia Test Manager.
 *
 * \details This module is responsible for entering to TestMode, executing the
 *             requested test case.
 *
 * \copyright 2021 Covidien - Surgical Innovations. All Rights Reserved.
 *
 * \file    TestManager.c
 * \todo 5/31/2022 BS: Encapsulate with compiler switch if the module is not needed in Release build
 * ========================================================================== */
/******************************************************************************/
/*                             Include                                        */
/******************************************************************************/
#include "TestManager.h"
#include "ActiveObject.h"
#include "Signia_ChargerManager.h"
#include "Signia_AdapterEvents.h"
#include "McuX.h"
#include "TaskMonitor.h"
#include "L4_ConsoleManager.h"
#include "FileSys.h"
#include "L2_Timer.h"
#include "Signia_Motor.h"
#include "L3_Motor.h"
#include "L3_Fpga.h"

#include "Signia_AdapterManager.h"
#include "L3_GpioCtrl.h"
#include "Signia_Keypad.h"
#include "L2_Gpio.h"
#include "L4_OwMemoryFormats.h"
#include "L3_Battery.h"
/******************************************************************************/
/*                             Global Constant Definitions(s)                 */
/******************************************************************************/
/******************************************************************************/
/*                             Global Variable Definitions(s)                 */
/******************************************************************************/

/******************************************************************************/
/*                             Local Define(s) (Macros)                       */
/******************************************************************************/
#define LOG_GROUP_IDENTIFIER    (LOG_GROUP_TESTS)

#define TM_STACK_SIZE       (256u)                 /* Test Manager Stack Size*/
#define TM_EVQ_SIZE         (10u)                 /* Test Manager queue size */

#define TM_TIMEOUT_TIME_MS  (MIN_5)             ///< TestMode Timeout Time

#define HANDLE_SERIALNO_SIZE (10u)              ///< Handle Serial number size

#define TM_TESTTASKPRIO      (SIGNIA_TASK_PRIO_RESERVE_10)      ///< TestTask Priority
#define TM_TESTTASKMONSTKSZ  (64u)                              ///< TestTask Size
#define TM_TESTSTACKSZ       (56u)                              ///< TestTask stack size for stack fault simulation

#define TM_TESTID_OFFSET            (2u)       ///< Offset for TestID
#define TM_BATTSIMDATA_OFFSET       (4u)       ///< Offset for Battery simulation data

#define BIT_8                (8u)    ///< defines 8-bits
#define BITS_24              (24u)   ///< defines 24-bits
#define BITS_16              (16u)   ///< defines 16-bits
#define ZERO                 (0u)    ///< offset value 
#define ONE                  (1u)    ///< offset value 
#define SHORT_MAX            (65535u) ///< Max value of unsigned integer 

#define TM_ONEWIRE_PAGEEND_OFFSET       (31u)        ///< Onewire PAGE end offset


#define TM_CPULOADTEST_LOOPTIME  (10u)        ///< Cpu load test loop time

#define TM_TEST_FILE_NAME                  ("sdcard:0:\\TestFile.txt")

#define TM_SD_MAX_STRING_LEN              (30u)
#define TM_MAXSDCARDRDWRSIZE              (10000u)
#define GET_PIT_CVAL3_TICK                ((UINT32_MAX_VALUE  - (uint32_t) PIT_CVAL3))  ///< This macro returns the current PIT timer value which is a countdown timer
#define TM_TIMER_PRESCALE                 ((SYSTEM_FREQ_HZ / 1000000u) / 2u)            ///< with 120Mhz System Clock, 1uS = 120 Cycles.
#define TM_TIMER_MAX_MICROSECONDS         ((UINT32_MAX_VALUE / TM_TIMER_PRESCALE))      ///< timer capacity
#define USBPERFTESTTIME                   MSEC_10
#define USBRXPERFTIESTTIME                SEC_1

#define MAXSPEEDSTORUN                  (5u)     ///< Maximum Speeds
#define MAXMOTORIDS                     (3u)     ///< Maximum Motor ID's
#define MOTSTARTUPDELAY                 (30u)    ///< Motor Startup Delay
#define MOTCURNTTRIP                    (8000u)  ///< Current Value to stop move when exceeded
#define MOTCURNTLMT                     (0x1FF)  ///< Motor Current Limit
#define MOT_POS                         (90000u)  ///< Motor Position (Ticks)
#define MOT_RUN_TIMEOUT                 (50000u) ///< Maximum Time to run Motor
#define FIRING_SPEED_FAST_VALUE         (1348u)  ///< Firing Speed FAST
#define FIRING_SPEED_MEDIUM_VALUE       (755u)   ///< Firing Speed MEDIUM
#define FIRING_SPEED_SLOW_VALUE         (377u)   ///< Firing Speed SLOW
#define MINIMUM_SPEED_VALUE             (25u)    ///< Minimum Speed
#define MAXIMUM_SPEED_VALUE             (1800u)  ///< Maximum Speed
#define TM_ONSTARTUP    0xD0C0FFEEu ///< Magic Number in NoinitRAM indicates Request for TestMode active mode during startup
#define TM_HANDLEBATTERY   0x03u    ///< Handle and Battery bits


#define INT_RAM_START_ADD         (0x1FFF1C00u) ///< Internal RAM START Address
#define INT_RAM_END_ADD           (0x2000FB00u) ///< Internal RAM END Address
#define EXT_RAM_START_ADD         (0xC0000000u) ///< External RAM START Address
#define EXT_RAM_END_ADD           (0xC0040000u) ///< External RAM END Address


#define TM_MAXKEYSEQ              (20u)         ///< Max key sequences per command

#define TO16U(pData)    (((uint16_t)(pData[1]<<BITS_8)) | ((uint16_t)pData[0]))
#define TO32U(pData)    (((uint32_t)(pData[3]<<BITS_24)) | ((uint32_t)(pData[2]<<BITS_16)) | ((uint32_t)(pData[1]<<BITS_8)) | ((uint32_t)(pData[0])))

#define BIT1    0X01u

OS_EVENT *pTstMutex = NULL;
OS_EVENT *pTstQ = NULL;
uint8_t MappedEnum = NULL;

/******************************************************************************/
/*                    Local Type Definition(s)  / Function Prototypes         */
/******************************************************************************/
typedef enum{
    BATTLEVEL,              ///< Battery (Rsoc)level
    BATTVOLTAGE,            ///< battery Voltage
    BATTCURRENT,            ///< Battery current
    BATTTEMP,               ///< Battery temperature
    BATTCHGRCNTCYCLE,       ///< Battery Charger Count Cycle
    BATTCELL0VOLTAGE,       ///< Battery Cell0 Voltage in mV
    BATTCELL1VOLTAGE,       ///< Battery Cell1 Voltage in mV
    BATTLEVELBQ,            ///< Battery (RSOC) level from BQ chip in %
    BATTCHARGESTS,          ///< Battery Charging Status
    BATTGAUGSTS,            ///< Battery Gauging Satus
    BATTSAFETYSTS,          ///< Battery Safety Status
    BATTOPERTAIIONSTS,      ///< Battery Operation Status
    BATTPFSTS,              ///< Battery Permanent Fail Status
    BATTTYPE,               ///< Battery Type
    BATTINTERNALTEMP,       ///< Internal Temperature
    TS1TEMP,                ///< Cell1 Temperature
    TS2TEMP,                ///< Cell2 Temperature
    ISVALID,                ///< Flag to check if the Battery parameters are valid
    BATTPARAM_COUNT
}BATTPARAM_BITPOS;

typedef enum
{
    DSGCURRENT,                   ///< DSG Current Threshold - Class: 249, Offset: 0
    CHGCURRENT,                  ///< CHG Current Threshold - Class: 249, Offset: 2
    QUITCURRENT,                      ///< Quit Current Threshold - Class: 249, Offset: 4
    CYCLECNTPERC,                  ///< Cycle Count Percentage - Class: 489, Offset: 18
    PFBITS0TO15,                   ///< Enabaled PF 0 to 15 bits - Class: 197, Offset: 0
    SHUTDOWNTIME,                     ///< Shutdown Time - Class: 230, Offset: 2
    PRECHARGCURRENT,               ///< Pre-Charging current - Class: 148, Offset: 0
    MINSTARTBALANCEDELTA,           ///< Cell Balancing congi, Min Start Balance Delta - Class: 168, Offset: 4
    CURRENTDEADBAND,                  ///< Current Deadband - Class: 103, Offset: 0
    VALIDVOLTAGEUPDATE,              ///< Valid Update Voltage - Class: 228, Offset: 0
    SBSDATACONFIG_0_15,              ///< Setting Configuration - Class: 201, Offset: 9
    CHARGINGCONFIG,                   ///< Setting Configuration - Class: 201, Offset: 3
    CLEARVOLTAGETHD,                 ///< Clear voltage threshold - Class: 578, Offset: 2
    BATTDFCOUNT                           ///< Number of DF Parameters
} BATTDEF_BITPOS;

typedef union{                          ///< structures to be added based on the test cases
  struct
  {
    uint32_t CW;                        ///< Control word indicating which of the following parameters should be simulated
    float32_t BatteryLevel;             ///< Battery (Rsoc)level
    uint16_t BatteryVoltage;            ///< battery Voltage
    int16_t BatteryCurrent;             ///< Battery current
    float32_t  BatteryTemperature;      ///< Battery temperature
    uint16_t BatChgrCntCycle;           ///< Battery Charger Count Cycle
    uint16_t BatteryCell0Voltage;       ///< Battery Cell0 Voltage in mV
    uint16_t BatteryCell1Voltage;       ///< Battery Cell1 Voltage in mV
    uint16_t BatteryLevelBQ;            ///< Battery (RSOC) level from BQ chip in %
    uint16_t BatteryChargeSts;          ///< Battery Charging Status
    uint16_t BatteryGaugSts;            ///< Battery Gauging Satus
    uint32_t BatterySafetySts;          ///< Battery Safety Status
    uint32_t BatteryOperationSts;       ///< Battery Operation Status
    uint32_t BatteryPFSts;              ///< Battery Permanent Fail Status
    CHGR_MNGR_BATTERYTYPES BatteryType; ///< Battery Type
    float32_t InternalTemperature;      ///< Battery Internal Temperature
    float32_t TS1Temperature;           ///< Cell1 Temperature
    float32_t TS2Temperature;           ///< Cell2 Temperature
    bool IsValid;
  } BattParam;

  struct{
    uint8_t MotorIDCW;      ///< Motor Control word indicating Motor Number (Id)
  }MTR_PERFPARAM;

  struct{
    uint16_t MtrID;         ///< Motor Control word indicating Motor Number (Id)
    uint16_t Mtr0SpeedinRpm;  ///< Motor 0 Speed in RPM
    int16_t Mtr0PositioninTicks;  ///< Motor 0 Position in TICKS
    uint16_t Mtr1SpeedinRpm;  ///< Motor 1 Speed in RPM
    int16_t Mtr1PositioninTicks;  ///< Motor 1 Position in TICKS
    uint16_t Mtr2SpeedinRpm;  ///< Motor 2 Speed in RPM
    int16_t Mtr2PositioninTicks;  ///< Motor 2 Position in TICKS
  }MTR_POSITION;

  struct{
    uint8_t RamDecide;     ///  RAM Decision   ( INTERNAL RAM - 0, EXTERNAL RAM - 1 )
    uint8_t PatternDecide; ///  Pattern decide ( PATTERN - 0, ANTI PATTERN - 1 )
  }MEM_PARAMETERS;

   struct{
    uint8_t TestToDO;     ///  OS Failures Decision  
  }OS_FAILURES;

  struct{
    uint16_t KeySeqCount;                 ///< Key sequence in the command
    uint16_t KeySeqDelay;                 ///< Delay between key sequences
    uint16_t KeyBM[TM_MAXKEYSEQ];        ///< Key BitMap
  }KEYDATA;
  uint16_t OWDeviceBM;                  ///< One wire Devices to be teseted ( Bit code as per ONEWIRE_DEVICES enum)
  uint16_t  SDCDErrID;   ///< SD Card Error to Trigger 
  uint16_t  EventLogID;  ///< Event Log to Trigger
  uint16_t  CrcFailureID; ///< CRC Command ID of Charger, Battery, Adapter

  struct
  {
    uint16_t CW;  
//    uint16_t DsgCurrent; ///< DSG Current Threshold - Class: 249, Offset: 0
//    uint16_t ChgCurret;                  ///< CHG Current Threshold - Class: 249, Offset: 2
//    uint16_t QuitCurrent;                      ///< Quit Current Threshold - Class: 249, Offset: 4
//    uint8_t CycCntPer;                  ///< Cycle Count Percentage - Class: 489, Offset: 18
//    uint16_t PFbitPos;                   ///< Enabaled PF 0 to 15 bits - Class: 197, Offset: 0
//    uint8_t ShdnTime;                     ///< Shutdown Time - Class: 230, Offset: 2
//    uint16_t PreChargCurrent;               ///< Pre-Charging current - Class: 148, Offset: 0
//    uint8_t  MinStartBalanDelta;           ///< Cell Balancing congi, Min Start Balance Delta - Class: 168, Offset: 4
//    uint8_t CurrentDedBand;                  ///< Current Deadband - Class: 103, Offset: 0
//    uint16_t ValidUpdaVol;              ///< Valid Update Voltage - Class: 228, Offset: 0
//    uint16_t SettSbsCfg015;              ///< Setting Configuration - Class: 201, Offset: 9
//    uint8_t SettChrangCfg;                   ///< Setting Configuration - Class: 201, Offset: 3
//    uint16_t ClearVolThreshold;                 ///< Clear voltage threshold - Class: 578, Offset: 2
  } BattDFParam;

}TESTDATA;

typedef struct
{
  //BATT_DF_TM_DATA  DFparams;
  uint16_t SubClID;
  uint8_t  DofSet;
  uint8_t  DSize;
  uint16_t DFdata;
  BATTDEF_BITPOS   BitPos;
}BDF_MAPPER;

typedef struct
{
    uint32_t TestTime;                 ///< TestTime
    float32_t AvgWrPerf;               ///< Average Write speed
    float32_t AvgRdPerf;               ///< Average Read speed
    float32_t MaxWrPerf;               ///< Max Write speed
    float32_t MaxRdPerf;               ///< Max Read speed
    uint16_t WrPerfCount;              ///< Write test count
    uint16_t RdPerfCount;              ///< Read test count

}SDCARD_PERFPARAM;

typedef struct
{
    uint32_t TestTime;                  ///< Testtime
    float32_t AvgTxPerf;                ///< Average USB TX Throughtput
    float32_t AvgRxPerf;                ///< Average USB RX Throughtput
    float32_t MaxTxPerf;                ///< Max USB TX Throughtput
    float32_t MaxRxPerf;                ///< Min USB TX Throughtput
    uint16_t TxPerfCount;
    uint16_t RxPerfCount;

}USB_PERFPARAM;


typedef enum
{
    STACK,                  ///< Taskmonitor test to check Stack Utilization
    CPULOAD,                ///< Taskmonitor test to check CPU Load
    CHECKIN,                ///< Taskmonitor test to check Task checkin times
    TASKMONTEST_COUNT
}TASKMON_TESTS;

typedef enum
{
    SIMULATE_SEMAPHORE_FAILURE,
    SIMULATE_MUTEX_FAILURE,
    SIMULATE_TASK_FAILURE,
    SIMULATE_QUEUE_FAILURE,
    SIMULATE_TIMEOUT_FAILURE
} TEST_FAILURE_ID;

typedef enum              ///< Enum for onewire devices bitmap
{
   HANDLE,
   BATTERY,
   CLAMSHELL,
   CHARGER,
   ADAPTER,
   RELOAD,
   CATRIDGE,
   DEVICECOUNT,
   DEVICEUNKOWN
}ONEWIRE_DEVICES;

static uint8_t MicroSecTmrOvf;

/* ask QM to declare the TestManager Class -----------------------------------*/
/*.$declare${AOs::TestManager} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TestManager} .....................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */

    /// Timer Object
    QTimeEvt TMTimer;

    //Timer to hold key time
    QTimeEvt TMKeyHoldTmr;
} TestManager;

/* protected: */
static QState TestManager_initial(TestManager * const me, void const * const par);

/* ========================================================================== */
static QState TestManager_Idle(TestManager * const me, QEvt const * const e);

/* ========================================================================== */
static QState TestManager_Active(TestManager * const me, QEvt const * const e);
/*.$enddecl${AOs::TestManager} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static uint16_t TM_CalculateKey(void);
static void TestSimulateBattParam(CHARGER_INFO *pBattData, TESTDATA *pTdata);
static void TestSimulateMotorParam(MOTOR_CTRL_PARAM *pMotorData, TESTDATA *pMdata, HOOKID id);
static void TestRAMIntegrityFault(void *pData, TESTDATA *pMdata, HOOKID id);
static void TestSimulateMotorPosition(MOTOR_CTRL_PARAM *pMtrData, TESTDATA *pMdata);
static void SimulateOSTaskErrors(TESTDATA *pTestdata);
static void SimulateOSFailures(void *pData, HOOKID id);
static void SimulateSDCardErrors(void *pData, TESTDATA *pSdErrdata, HOOKID id);
static void SimulateLoggingEvents(void *pData, TESTDATA *pSdErrdata, HOOKID id);
static void SimulateCRCFailures(void *pData, TESTDATA *pCrcdata, HOOKID id);

static void SimulateBatteryFalshParamters(BATT_DF_TM_DATA *pData, TESTDATA *pCrcdata, HOOKID id);

static void TestSimulateTaskMonitorFault(TASKMON_TESTS Test);

static void TaskMonitorStackTestExecute(void *pArg);
static void TaskMonitorLoadTestExecute(void *pArg);
static void TaskMonitorCheckinTestExecute(void *pArg);
static void DummyTaskCreation(void *pArg);

static void TestSDCardPerformance(HOOKID id, void *pData);
static void TestUSBPerformance(HOOKID id, void *pData);

static TM_STATUS TMResetMicroTimer(void);
static TM_STATUS TMInitMicroTimer(void);
static void TM_TimerHandler(void);
static float32_t GetTimeElapsed(uint32_t StartTime);
static uint32_t GetServoTimeElapsed(uint32_t StartTime);
static void TestOneWireFailure(uint8_t *pData, uint16_t *pTdata, HOOKID id);
static void OneWireFailureSimulation(uint8_t *pData, HOOKID id, ONEWIRE_DEVICES device);
static ONEWIRE_DEVICES GetOneWireDevice(uint8_t *pData);

static void TMSimulateKey(GPIO_TM_DATA *pData, TESTDATA *pTdata);

/******************************************************************************/
/*                             Local Constant Definition(s)                   */
/******************************************************************************/

/******************************************************************************/
/*                             Local Variable Definition(s)                   */
/******************************************************************************/
/* Instantiate the TestManager active object (and local data)--------------------*/
static TestManager      LocalTestManager;                            /* Local data */
QActive *const          AO_TestManager = &LocalTestManager.super;    /* Opaque pointer to Logger Active Object */

//#pragma location=".sram"
static QEvt const *TMEventQueue[TM_EVQ_SIZE];      /* Event Queue for AO */
//#pragma location=".sram"
static OS_STK      TMStack[TM_STACK_SIZE];         /* Stack for AO */
static uint8_t    *AOname = "TESTMANAGER";

static uint8_t TM_TestID;

#pragma location=".sram"
static TESTDATA TM_TestData;

static bool TestModeActive;
bool MotspeedTstSts[MAXMOTORIDS] = {false};

static const uint8_t SerialKey[] = {'S','i','g','n','i','a'};


static OS_STK TM_TestTaskMonStk[TM_TESTTASKMONSTKSZ];
static uint8_t *TestTaskName = "TestTaskMonitor";

static TestManagerNoinitData TM_NoinitData;

static GPIO_uP_INT_CALLBACK_T WakeupPinCallback;
static uint8_t SeqCount;
static bool KeySimEnd;
static bool LogEndCnt;


/******************************************************************************/
/*                             Local Function(s)                              */
/******************************************************************************/
/* Local helper functions for TestManager: */

/* ========================================================================== */
/**
 * \brief   Calculate the Key value based on Serial Number
 *
 * \details This Function calcuates the Key value from the Handle serial number
 *              Serial Number (10bytes) = b9b8b7b6b5b4b3b2b1b0
 *              Step1: add serial number wordwise Sum = b0b1+b2b3+b4b5+b6b7+b8b9 (ignore carry if any)
 *              Step2: One's complement of sum (ISum)
 *              Step3: Xor with Serial Key "Signia": ((ISum ^ 0x5369)^0x676E)^0x6961)
 *                                      0x5369 = "Si", 0x676E = "gn", 0x6961 = "ia"
 *
 * \param   < none >
 *
 * \return  uint16_t - Calculated key
 *
 * ========================================================================== */
static uint16_t TM_CalculateKey(void)
{
    uint16_t CalcKey;
    uint16_t Temp;
    uint8_t i;
    uint8_t* pHandleSrNo;
    AM_HANDLE_IF* pHandleData;

    CalcKey = 0;

    do
    {
        pHandleData = Signia_GetHandleIF();
        pHandleSrNo = pHandleData->Data.LotNumber;  // get handle serial number from handle interface
        i = 0;
        while (i < (HANDLE_SERIALNO_SIZE))
        {
           Temp = (((uint16_t)(pHandleSrNo[i] << BIT_8)) | ((uint16_t)pHandleSrNo[i+1]));
           CalcKey += Temp;
           i+=2;
        }
        CalcKey = ~CalcKey;

        i = 0;
        while (i< (sizeof(SerialKey)))
        {
            Temp = (((uint16_t)(SerialKey[i]<< BIT_8)) | ((uint16_t)(SerialKey[i+1])));
            CalcKey ^= Temp;
            i+=2;
        }

    } while (false);
    return CalcKey;
}

/* ========================================================================== */
/**
 * \brief   Test to Simulate Stack Fault
 *
 * \details This Function simulates the Stack fault
 *
 * \param   Test - Tasmonitor test id that needs to be run
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSimulateTaskMonitorFault(TASKMON_TESTS Test)
{
    uint32_t stacksz;
    void (*testfn)(void *) = NULL;
    switch(Test)
    {
        case STACK:
            Log(TST, "TestMode: TaskMonitor Stack fault simulation");
            testfn = TaskMonitorStackTestExecute;
            stacksz = TM_TESTSTACKSZ;
            break;

        case CPULOAD:
            Log(TST, "TestMode: TaskMonitor Load fault simulation");
            testfn = TaskMonitorLoadTestExecute;
            stacksz = TM_TESTTASKMONSTKSZ;
            break;

        case CHECKIN:
            Log(TST, "TestMode: TaskMonitor Load fault simulation");
            testfn = TaskMonitorCheckinTestExecute;
            stacksz = TM_TESTTASKMONSTKSZ;
            break;

        default:
            break;
    }
    if (NULL != testfn)
    {
        SigTaskCreate(testfn,
                        NULL,
                        &TM_TestTaskMonStk[0],
                        TM_TESTTASKPRIO,
                        stacksz,
                        TestTaskName);
    }
}


/* ========================================================================== */
/**
 * \brief   Task Monitor test stub for Task Load Test.
 *
 * \details Task is created to simulate a Over utilization of CPU.
 *              This is done by running task in ready state for most of the time.
 *                     The task is desingend to starv low priority tasks of CPU time.
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void TaskMonitorLoadTestExecute(void *pArg)
{
    uint32_t tsttimer;
    tsttimer = 0;
    TaskMonitorRegisterTask(SEC_1);
    while(true)
    {
      TaskMonitorTaskCheckin(OSTCBCur->OSTCBPrio);
      tsttimer = SigTime();
       while(1)
       {
          if((SigTime() - tsttimer) > TM_CPULOADTEST_LOOPTIME)
          {
              break;
          }
       }
       OSTimeDly(MSEC_1);
    }
}

/* ========================================================================== */
/**
 * \brief   Task Monitor Stack Test stub execution.
 *
 * \details the task is created with Stack size equal to its min stack utilization size (56bytes)
 *            The below task is registered with Taskmonitor during TaskStartup
 *            Taskmonitor module should detect the Stack uitilization and raise a Stack fault
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void TaskMonitorStackTestExecute(void *pArg)
{
    TaskMonitorRegisterTask(SEC_1);
    while(true)
    {
        TaskMonitorTaskCheckin(OSTCBCur->OSTCBPrio);

        OSTimeDly(MSEC_100);

    }
}

/* ========================================================================== */
/**
 * \brief   Task Monitor test for Task Checkin faults.
 *
 * \details Task Monitor test  - with Task Checkin time > timeout time
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void TaskMonitorCheckinTestExecute(void *pArg)
{
    TaskMonitorRegisterTask(SEC_1);
    while(true)
    {
       TaskMonitorTaskCheckin(OSTCBCur->OSTCBPrio);

       OSTimeDly(SEC_3);  // Task check in error simulation
    }
}

/* ========================================================================== */
/**
 * \brief   Dummy Task Creation to Simulate OS Task Failures.
 *
 * \details Simply delay creating so that, Task Creation Fn should call and
 *          Simulate OS Task Error
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void DummyTaskCreation(void *pArg)
{
  while(true)
  {
    OSTimeDly(SEC_3);
  }
}

/* ========================================================================== */
/**
 * \brief   Test to simulate Battery parameters
 *
 * \details This Function overrides the Battery parameters
 *              Data[0] to Data[3] - 3bytes - Controlword (bitcoded word indicating which BatteryParameters to be simulated
 *                                                                               - see enum BATTPARAM_BITPOS for details)
 *              Data[4], .... - data bytes in order of BattaeryParameters enabled in ControlWord
 *
 * \param   CHARGER_INFO * - pointer to the charger info
 *
 * \param   uint8* - pointer to the Simulation data
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSimulateBattParam(CHARGER_INFO *pBattData,  TESTDATA *pTdata)
{

    BATTPARAM_BITPOS BatParm;

    BatParm = BATTLEVEL;

    while (BatParm < BATTPARAM_COUNT)
    {
        if( pTdata->BattParam.CW & (BIT1 << BatParm) )
        {
            switch(BatParm)
            {
              case BATTLEVEL:
                  pBattData->BatteryLevel = pTdata->BattParam.BatteryLevel;
                  break;

              case BATTVOLTAGE:
                  pBattData->BatteryVoltage = pTdata->BattParam.BatteryVoltage;
                  break;

              case BATTCURRENT:
                  pBattData->BatteryCurrent = pTdata->BattParam.BatteryCurrent;
                  break;

              case BATTTEMP:
                  pBattData->BatteryTemperature = pTdata->BattParam.BatteryTemperature;
                  break;

              case BATTCHGRCNTCYCLE:
                  pBattData->BatChgrCntCycle = pTdata->BattParam.BatChgrCntCycle;
                  break;

              case BATTCELL0VOLTAGE:
                  pBattData->BatteryCell0Voltage = pTdata->BattParam.BatteryCell0Voltage;
                  break;

              case BATTCELL1VOLTAGE:
                  pBattData->BatteryCell1Voltage = pTdata->BattParam.BatteryCell1Voltage;
                  break;

              case BATTLEVELBQ:
                  pBattData->BatteryLevelBQ = pTdata->BattParam.BatteryLevelBQ;
                  break;

              case BATTCHARGESTS:
                  pBattData->BatteryChargeSts = pTdata->BattParam.BatteryChargeSts;
                  break;

              case BATTSAFETYSTS:
                  pBattData->BatterySafetySts = pTdata->BattParam.BatterySafetySts;
                  break;

              case BATTGAUGSTS:
                  pBattData->BatteryGaugSts = pTdata->BattParam.BatteryGaugSts;
                  break;

              case BATTOPERTAIIONSTS:
                  pBattData->BatteryOperationSts = pTdata->BattParam.BatteryOperationSts;
                  break;

              case BATTPFSTS:
                  pBattData->BatteryPFSts = pTdata->BattParam.BatteryPFSts;
                  break;

              case BATTTYPE:
                  pBattData->BatteryType = pTdata->BattParam.BatteryType;
                  break;

              case BATTINTERNALTEMP:
                  pBattData->InternalTemperature = pTdata->BattParam.InternalTemperature;
                  break;

              case TS1TEMP:
                  pBattData->TS1Temperature = pTdata->BattParam.TS1Temperature;
                  break;

              case TS2TEMP:
                  pBattData->TS2Temperature = pTdata->BattParam.TS2Temperature;
                  break;

              case ISVALID:
                  pBattData->IsValid = pTdata->BattParam.IsValid;
                  break;

              default:
                 break;
            }
        }
        BatParm++;
    }
}
/* ========================================================================== */
/**
 * \brief   Test to simulate Motor Performance
 *
 * \details This Function Simulates the Motor Parameters( Performance )
 *
 * \note    This function ensures that following tests:
 *          a) All three Motors Runs with Minimum RPM(i.e 25 RPM) And Maximum RPM (i.e 1800 RPM )
 *          b) All three Motors Stops with in the specified time
 *          c) All three Motors Controls the MOTOR speed within 10% of the setpoint, within 200 ms of the set speed
 *             when motors are operating between Minimum RPM to Maximum RPM.
 *
 * \param   pMotorData - Pointer to the motor control parameters
 *          pMdata     - Pointer to the motor Id's input data
 *          id         - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSimulateMotorParam(MOTOR_CTRL_PARAM *pMotorData, TESTDATA *pMdata, HOOKID id)
{

    uint8_t  MotrID[MAXMOTORIDS]        = { MOTOR_ID0, MOTOR_ID1, MOTOR_ID2 };
    uint32_t  MotrSpeed[MAXSPEEDSTORUN] = { MINIMUM_SPEED_VALUE, FIRING_SPEED_SLOW_VALUE, FIRING_SPEED_MEDIUM_VALUE,
                                                FIRING_SPEED_FAST_VALUE, MAXIMUM_SPEED_VALUE }; // In RPM's
    uint8_t    MtrIdIndx;

    static uint32_t MotorSpdUpdateTime[MAXMOTORIDS];
    static uint32_t MotorRunTime[MAXMOTORIDS];
    static uint8_t  Motspeedidx[MAXMOTORIDS];
    static uint32_t MotorSettlingTime[MAXMOTORIDS];
    static uint32_t IntialServotick;
    static uint32_t ElapsedServotime;
    static uint32_t ServoLogtime;
    static uint32_t PerValue;
    static uint8_t  SampleCntr[MAXMOTORIDS];


      switch(id)
      {
       case HOOK_TM:
               for(MtrIdIndx = 0; MtrIdIndx < MAXMOTORIDS; MtrIdIndx++)
               {
                 if( pMdata->MTR_PERFPARAM.MotorIDCW & ( 0x01 << MtrIdIndx) )
                 {
                    Motspeedidx[MtrIdIndx] = 0;
                    Signia_MotorStart((MOTOR_ID)MotrID[MtrIdIndx], MOT_POS, MotrSpeed[Motspeedidx[MtrIdIndx]], MOTSTARTUPDELAY, MOT_RUN_TIMEOUT, MOTCURNTTRIP, MOTCURNTLMT, true, MOTOR_VOLT_15, 0);
                    MotorRunTime[MtrIdIndx] = SigTime();
                    MotspeedTstSts[MtrIdIndx] = false;
                 }
               }
           break;

      case HOOK_MTRSPEED:
            if(pMotorData->State == MOTOR_STATE_RUNNING)
            {
                /*calculating the percentage value of the MOTOR speed within 10% of the set speed. for all defined speeds */
                PerValue = (uint32_t)(( MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO)*0.1 );

                if( ( pMotorData->MotorAvgSpeed <=  ((MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO) + PerValue )) &&
                    ( pMotorData->MotorAvgSpeed >=  ((MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO) - PerValue )) )
                {
                    SampleCntr[pMotorData->MotorId]++;

                    if( 1 == SampleCntr[pMotorData->MotorId] )
                    {
                      MotorSettlingTime[pMotorData->MotorId] =  SigTime();
                    }

                    if( 100 >= SampleCntr[pMotorData->MotorId] && !MotspeedTstSts[pMotorData->MotorId])
                    {
                          Log(TST, "TestManager: Motor ID: %d, Setting Speed: %ld, Avg Speed: %lu, Time: %1u ms, Current: %lu",
                                 pMotorData->MotorId,
                                (MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO),
                                pMotorData->MotorAvgSpeed,
                                (MotorSettlingTime[pMotorData->MotorId] - MotorRunTime[pMotorData->MotorId]),
                                pMotorData->MotorCurrent);

                          MotspeedTstSts[pMotorData->MotorId] = true;
                    }
                }
                else
                {
                    SampleCntr[pMotorData->MotorId] = 0;
                }

                if((SigTime() - MotorRunTime[pMotorData->MotorId]) >= SEC_5 )
                {
                    if( Motspeedidx[pMotorData->MotorId] < MAXSPEEDSTORUN )
                    {
                        MotorRunTime[pMotorData->MotorId] = SigTime();
                        MotorSettlingTime[pMotorData->MotorId] = SigTime();
                        Motspeedidx[pMotorData->MotorId]++;
                        Signia_MotorUpdateSpeed(pMotorData->MotorId, MotrSpeed[Motspeedidx[pMotorData->MotorId]], MOTOR_VOLT_15);
                        MotspeedTstSts[pMotorData->MotorId] = false;
                        SampleCntr[pMotorData->MotorId] = 0;
                    }
                    else
                    {
                        MotorSpdUpdateTime[pMotorData->MotorId] = SigTime();
                        Signia_MotorStop(pMotorData->MotorId);
                    }
                }
            }
            else if(pMotorData->State == MOTOR_STATE_STOPPING)
            {
                Log(TST, "TestManager: Speed Stop Time : %lu in ms", (SigTime() - MotorSpdUpdateTime[pMotorData->MotorId]));
            }
            else
            {
                /* Do noting in idle state */
            }
        break;

      case HOOK_MTRSERVOSTART:/* Motor Servo Loop time execution Test:- Warning. No other task should resetting the CPU_COUNTER. Currently No other task is using it.*/
            IntialServotick = CPU_COUNTER_READ();
            ServoLogtime = SigTime();
            break;

      case HOOK_MTRSERVOEND:
            ElapsedServotime = GetServoTimeElapsed(IntialServotick);

            if( 0 == ServoLogtime%1000 )
            {
              Log(TST, "TestManager: Control Loop Execution Time = %lu microSeconds", ElapsedServotime);
            }
            break;
        default:
            break;
      }
}

/* ========================================================================== */
/**
 * \brief   Test to simulate Memory Fault
 *
 * \details This Function Simulates the Memory Fault Scenarios
 *
 * \note    This function ensures that following tests:
 *          a) Integrity of the Internal RAM check Fault Scenario.
 *          b) Integrity of the External RAM check Fault Scenario.
 *
 * \param   pData     - Pointer to data ( It carries the address of the Internal & External RAM Addresses.)
 *          pMemdata  - Pointer to the input data ( RAM Decision, Pattern Decision to make fail )
 *          id        - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void TestRAMIntegrityFault(void *pData, TESTDATA *pMemdata, HOOKID id)
{
   uint8_t RamToValidate;
   uint8_t PatternToValidate;

      switch(id)
      {

       case HOOK_TM:
            RamToValidate =  pMemdata->MEM_PARAMETERS.RamDecide;
            PatternToValidate = pMemdata->MEM_PARAMETERS.PatternDecide;
            break;

        case HOOK_RAMPATTERNFAIL:
             if( ( 0 == RamToValidate ) && ( 0 == PatternToValidate) ) // Internal RAM Validation Fails & Actual Pattern data corrupting
             {
               if( ((uint32_t *)(pData)  >= (uint32_t*)INT_RAM_START_ADD) &&
                  ( (uint32_t *)(pData) <= (uint32_t*)INT_RAM_END_ADD ) )
               {
                 *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ZERO );
                 Log(TST, "TestManager: Internal RAM Check for Pattern  at Address = %X ", (uint32_t*)(pData));
               }
             }
             else if( ( 1 == RamToValidate ) && ( 0 == PatternToValidate) ) // External RAM Validation Fails & Anti Pattern data corrupting
             {
                if( ((uint32_t*)(pData)  >= (uint32_t*)EXT_RAM_START_ADD ) &&
                ((uint32_t*)(pData) <= (uint32_t*)EXT_RAM_END_ADD ) )
                {
                    *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ZERO );
                    Log(TST, "TestManager: External RAM Check for Pattern  at Address = %X ", (uint32_t*)(pData));
                }
             }
             break;

      case HOOK_RAMANTIPATTERNFAIL:
             if( ( 0 == RamToValidate ) && ( 1 == PatternToValidate) ) // Internal RAM Validation Fails & Actual Pattern data corrupting
             {
               if( ((uint32_t*)(pData)  >= (uint32_t*)INT_RAM_START_ADD  ) &&
                  ((uint32_t*)(pData) <= (uint32_t*)INT_RAM_END_ADD ) )
               {
                 *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ONE );
                 Log(TST, "TestManager: Internal RAM Check for Anti Pattern  at Address = %X ", (uint32_t*)(pData));
               }
             }
             else if( ( 1 == RamToValidate ) && ( 1 == PatternToValidate) ) // External RAM Validation Fails & Anti Pattern data corrupting
             {
                if( ((uint32_t*)(pData)  >= ((uint32_t*)EXT_RAM_START_ADD ) ) &&
                ((uint32_t*)(pData) <= ((uint32_t*)EXT_RAM_END_ADD) ))
                {
                    *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ONE );
                    Log(TST, "TestManager: External RAM Check for Anti Pattern  at Address = %X ", (uint32_t*)(pData));
                }
             }
             break;


        default:
            break;
      }
}
/* ========================================================================== */
/**
 * \brief   Test to Motor Position
 *
 * \details This Function Starts(Moves) the Motor with the receied Parameters from the input
 *
 * \note    The Intention of the test is to see if the Motor stops with in the 20 ticks of the set position
 *          this can be observed by the logs which is received from the Motor Logs
 *
 * \param   pMtrData   - Pointer to the motor control parameters
 *          pMdata     - Pointer to the input data ( Speed in RPM, Position in Ticks, Motor ID's )
 *          id         - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */

static void TestSimulateMotorPosition(MOTOR_CTRL_PARAM *pMtrData, TESTDATA *pMdata)
{
    uint8_t  MotrID[MAXMOTORIDS]      = { MOTOR_ID0, MOTOR_ID1, MOTOR_ID2 };
    uint8_t    MtrIdx;
    uint16_t  MotrPosition[MAXMOTORIDS];
    uint16_t  MotrSpeed[MAXMOTORIDS];

    MtrIdx = 0;
    MotrPosition[MtrIdx]  = pMdata->MTR_POSITION.Mtr0PositioninTicks;
    MotrSpeed[MtrIdx] = pMdata->MTR_POSITION.Mtr0SpeedinRpm;
    MtrIdx++;
    MotrPosition[MtrIdx]  = pMdata->MTR_POSITION.Mtr1PositioninTicks;
    MotrSpeed[MtrIdx] = pMdata->MTR_POSITION.Mtr1SpeedinRpm;
    MtrIdx++;
    MotrPosition[MtrIdx]  = pMdata->MTR_POSITION.Mtr2PositioninTicks;
    MotrSpeed[MtrIdx] = pMdata->MTR_POSITION.Mtr2SpeedinRpm;

    for(MtrIdx = 0; MtrIdx < MAXMOTORIDS; MtrIdx++)
    {
        if( pMdata->MTR_POSITION.MtrID & ( 0x01 << MtrIdx) )
        {
            Signia_MotorStart((MOTOR_ID)MotrID[MtrIdx], MotrPosition[MtrIdx], MotrSpeed[MtrIdx], MOTSTARTUPDELAY, MOT_RUN_TIMEOUT, MOTCURNTTRIP, MOTCURNTLMT, true, MOTOR_VOLT_15, 0);
        }
    }
}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the SD Card Errors.
 *
 * \details This Function Simulates the File System Read Return value.
 *          Once an Error is detected with in the file system, it continues
 *          its Operation
 *
 * \param   pData        - Pointer to the motor control parameters
 *          pSdErrdata   - Pointer to the input data ( SD Card Error to Simulate  )
 *          id           - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateSDCardErrors(void *pData, TESTDATA *pSdErrdata, HOOKID id)
{
    uint8_t ErrID;
    ErrID =  pSdErrdata->SDCDErrID;

    if (( HOOK_FILESYSTEMERROR == id ) && ( ErrID == 2 ))
    {
        *(uint16_t*)(pData) = FS_ERR_FILE_ERR;
        Log(TST, "TestManager: Simualting SD Card File Read Error ");
    }
}
/* ========================================================================== */
/**
 * \brief   Test to Simulating the CRC data of SPI Bus ( Battery & Charger ) and 
 *          Adapter UArt Serial Port 
 *
 * \details This Function Simulates the CRC Failures of the SPI_BUS, 
 *          Adapter UART Serial port
 *
 * \param   pData        - Pointer to the address if the Checksum data 
 *          pSdErrdata   - Pointer to the input data ( CRC Failures ID )
 *          id           - Hook Id represents the Function call Parameter 
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateCRCFailures(void *pData, TESTDATA *pCrcdata, HOOKID id)
{
   uint16_t TestCrcID;
    
    do
    {
        if (NULL == pData || NULL == pCrcdata )
        {
            break;
        }
        
        TestCrcID = pCrcdata->CrcFailureID;
        
        if (( HOOK_SPICRCFAIL == id ) && ( TestCrcID == 1 ) )
        {
           Log(TST, "TestManager: Simulating SPI Bus CRC Failure", );
           *(uint16_t*)(pData) = *(uint16_t*)(pData) + ONE;      
        }
        else if( ( HOOK_ADAPTERCRCFAIL == id ) && ( TestCrcID == 2 ))
        {
          Log(TST, "TestManager: Simulating ADAPTER - UART CRC Failure", );
          *(uint8_t*)(pData) = *(uint8_t*)(pData) + ONE;  
        }
        
    } while ( false );
}
/* ========================================================================== */
/**
 * \brief   Test to Simulating the Battery Falsh data of
 *
 * \details This Function Simulates the CRC Failures of the SPI_BUS, 
 *          Adapter UART Serial port
 *
 * \param   pData        - Pointer to the address if the Checksum data 
 *          pSdErrdata   - Pointer to the input data ( CRC Failures ID )
 *          id           - Hook Id represents the Function call Parameter 
 *
 * \return  None
 *
 * ========================================================================== */
//static void SimulateBatteryFalshParamters(BATT_DF_TM_DATA *pData, TESTDATA *pBatDFdata, HOOKID id)
//{
static void SimulateBatteryFalshParamters(BATT_DF_TM_DATA *pData, TESTDATA *pBatDFdata, HOOKID id)
{
    BDF_MAPPER tempCopy;
   
    memcpy(&tempCopy, &(pData), sizeof(pData));
    
    const BDF_MAPPER DFEnumMapperTable[] =
    {
    //  ClsID, OfSetID, Size, DataValue, DSGCURRENT,
    
      { 249u, 0u, 2u, 32u, DSGCURRENT },
      { 249u, 2u, 2u, 00u, CHGCURRENT },//00
      { 249u, 4u, 2u, 4161u , QUITCURRENT }, //10 41
      { 489u, 18u, 1u, 35u, CYCLECNTPERC },// 00 23
      { 197u, 0u, 2u, 0xEEFBu, PFBITS0TO15 },
      { 230u, 2u, 1u, 1u,      SHUTDOWNTIME },
      { 148u, 0u, 2u, 320u, PRECHARGCURRENT },
      { 168u, 4u, 1u, 10u, MINSTARTBALANCEDELTA },
      { 103u, 0u, 1u, 2u, CURRENTDEADBAND },
      { 228u, 0u, 2u, 4500u, VALIDVOLTAGEUPDATE },
      { 201u, 9u, 2u, 0x0C2Fu, SBSDATACONFIG_0_15 },
      { 201u, 3u, 1u, 0x21u, CHARGINGCONFIG },
      { 578u, 2u, 2u, 4125u, CLEARVOLTAGETHD },
    
    };
    
    uint16_t DataFlashValue;
   DataFlashValue = ( *(pData->pValue )  + *( pData->pValue + 1 ));
    for( uint8_t i = 0; i < sizeof(DFEnumMapperTable)/ sizeof(DFEnumMapperTable[0]); i++)
    {
          if( (DFEnumMapperTable[i].SubClID == pData->DFparameter->SubClsId ) &&
          ( DFEnumMapperTable[i].DofSet == pData->DFparameter->Offset ) &&
          ( DFEnumMapperTable[i].DSize == pData->DFparameter->Size) &&
          ( DFEnumMapperTable[i].DFdata == DataFlashValue))//*pData->pValue)) 
          {
            
              MappedEnum = (BATTDEF_BITPOS)DFEnumMapperTable[i].BitPos;
              break;
              
          }
    }
    
    do
    {
    
        if( (pBatDFdata->BattDFParam.CW  & ((uint16_t)BIT1 << MappedEnum)) )
        {
             switch(MappedEnum)
            {
              case DSGCURRENT:
                   Log(TST, "Enum DSGCURRENT");
                  break;
                  
              case CHGCURRENT:
               Log(TST, "Enum CHGCURRENT");
              break;

              case QUITCURRENT:
               Log(TST, "Enum QUITCURRENT");
              break;

              case CYCLECNTPERC:
               Log(TST, "Enum CYCLECNTPERC");
              break;
              
            default:
                  break;
            }
        }
      
    }while(false);
    
    
   /* while (DFParamPos < BATTDFCOUNT)
    {
        if( pBatDFdata->BattDFParam.CW & (BIT1 << DFParamPos) )
        {
          
/            switch(DFParamPos)
//            {
//              case DSGCURRENT:
//                  if( ( 249 == pData->DFparameter.SubClsId ) && ( 0 == pData->DFparameter.Offset) )
//                  {
//                    // *pData->pValue = (uint16_t)*pData->pValue + ( 1 << ONE );
//                  }
//                  break;
//
////                  case CHGCURRENT:
////                      pBattData->BatteryVoltage = pBatDFdata->BattParam.BatteryVoltage;
////                      break;
////
////                  case QUITCURRENT:
////                      pBattData->BatteryCurrent = pTdata->BattParam.BatteryCurrent;
////                      break;
////
////                  case CYCLECNTPERC:
////                      pBattData->BatteryTemperature = pTdata->BattParam.BatteryTemperature;
////                      break;
////
////                  case PFBITS0TO15:
////                      pBattData->BatChgrCntCycle = pTdata->BattParam.BatChgrCntCycle;
////                      break;
////
////                  case SHUTDOWNTIME:
////                      pBattData->BatteryCell0Voltage = pTdata->BattParam.BatteryCell0Voltage;
////                      break;
////
////                  case PRECHARGCURRENT:
////                      pBattData->BatteryCell1Voltage = pTdata->BattParam.BatteryCell1Voltage;
////                      break;
////
////                  case MINSTARTBALANCEDELTA:
////                      pBattData->BatteryLevelBQ = pTdata->BattParam.BatteryLevelBQ;
////                      break;
////
////                  case CURRENTDEADBAND:
////                      pBattData->BatteryChargeSts = pTdata->BattParam.BatteryChargeSts;
////                      break;
////
////                  case VALIDVOLTAGEUPDATE:
////                      pBattData->BatterySafetySts = pTdata->BattParam.BatterySafetySts;
////                      break;
////
////                  case SBSDATACONFIG_0_15:
////                      pBattData->BatteryGaugSts = pTdata->BattParam.BatteryGaugSts;
////                      break;
////
////                  case CHARGINGCONFIG:
////                      pBattData->BatteryOperationSts = pTdata->BattParam.BatteryOperationSts;
////                      break;
////
////                  case CLEARVOLTAGETHD:
////                      pBattData->BatteryPFSts = pTdata->BattParam.BatteryPFSts;
////                      break;
//
//              default:
//                 break;
//            }
        }
        DFParamPos++;
    }*/
    

}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the logging Events 
 *
 * \details This Function Simulates the Logging Events
            i.e. Rollover of the Logger Counts, Log the Greter than REQ Log levels
 *
 * \param   pData        - Pointer to the Logging data Parameters 
 *          pEvntdata   - Pointer to the input data ( Event Logs Input Data  )
 *          id           - Hook Id represents the Function call Parameter 
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateLoggingEvents(void *pData, TESTDATA *pEvntdata, HOOKID id)
{
   uint16_t LogID;

    do
    {
        if (NULL == pData || NULL == pEvntdata )
        {
            break;
        }
        
        LogID = pEvntdata->EventLogID;

        if (( HOOK_LOGCNTROLLOVER == id ) && ( LogID == 1 ) && ( LogEndCnt == false ))
        {
            *(uint16_t*)(pData) = SHORT_MAX-2;
             LogEndCnt = true;        
        }
        else if( ( HOOK_TM == id ) && ( LogID == 2 ))
        {
           Log(REQ, "TestManager: Log Level :  REQ ");
           Log(WNG, "TestManager: Log Level :  WNG ");
           Log(ERR, "TestManager: Log Level :  ERR ");
           Log(FLT, "TestManager: Log Level :  FLT ");
           Log(TST, "TestManager: Log Level :  TST ");
        }
    } while ( false ); 
}

/* ========================================================================== */
/**
 * \brief   Test to simulating the OS Fault Failures.
 *          Caputring the input data based on which OS Failure Suppose to do.
 *
 * \details This Function Creates the IPC primitives.
 *           ( Not Implemented : Semaphore, Memory Create, Implemented: Mutuex, Task, Queue )
 *
 * \param   pTestdata  - Pointer to the input data ( OS Error to Simulate )
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateOSTaskErrors(TESTDATA *pTestdata)
{
    uint8_t  OsError;
    void* pTMQueue[ONE];
    uint8_t OSFailureID;
    OSFailureID = pTestdata->OS_FAILURES.TestToDO;

    switch(OSFailureID)
    {
        case SIMULATE_MUTEX_FAILURE:
            pTstMutex = SigMutexCreate("TestHook-Mutex", &OsError);
            break;

        case SIMULATE_TASK_FAILURE:
            OsError = SigTaskCreate( &DummyTaskCreation,
                                     NULL,
                                     &TM_TestTaskMonStk[0],
                                     TM_TESTTASKPRIO,
                                     TM_TESTTASKMONSTKSZ,
                                     TestTaskName);
             break;

        case SIMULATE_QUEUE_FAILURE:
            pTstQ = SigQueueCreate(pTMQueue, ONE);
            break;

        default:
        break;
    }

}

/* ========================================================================== */
/**
 * \brief   Test to simulate OSTask Errors
 *
 * \details This Function Simulates OS Failure Errors.
 *
 * \param   pData     - Pointer to data ( It carries the address of the Error, and Simulating its value.)
 *          id        - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
void SimulateOSFailures(void *pData,HOOKID id)
{
    switch(id)
    {
        case HOOK_OSMUTEXFAIL:
            *(uint8_t*)(pData) = OS_ERR_MEM_INVALID_PART;
            Log(TST, "TestManager: Mutext Simulation Failure ");
            break;

        case HOOK_OSTASKFAIL:
            *(uint8_t*)(pData) = OS_ERR_MEM_INVALID_PART;
            Log(TST, "TestManager: Task Simulation Failure ");
            break;

        case HOOK_OSQUEFAIL:
            *(uint32_t*)pData = 0;
            Log(TST, "TestManager: Queue Simulation Failure ");
            break;

        default:
        break;
    }
}
/* ========================================================================== */
/**
 * \brief   Test to check SD Card peformance
 *
 * \details For the test to calculate the SD card wirte/read times,
 *              a SD card write or read during the test needs to be performed.
 *              (preferable upload/read a blob from MCP)
 *
 * \param   id - HOOK id indicating if the calling Hook position in code ( either start or finish of Tx/Rx )
 *
 * \param   pData - pointer to data ( for Start hook its Null, for End hook it carries the size of Tx/Rx data )
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSDCardPerformance(HOOKID id, void *pData)
{
    static SDCARD_PERFPARAM sdperf;

    static uint32_t SDWrTick;
    static uint32_t WrSize;
    static float32_t WrTime;
    static uint32_t SDRdTick;
    static uint32_t RdSize;
    static float32_t RdTime;

    switch(id){
        case HOOK_SDWRSTART:
            SDWrTick = GET_PIT_CVAL3_TICK;
            break;

        case HOOK_SDWREND:
            WrTime += GetTimeElapsed(SDWrTick);
            WrSize += *(uint16_t *)(pData);
            break;

        case HOOK_SDRDSTART:
            SDRdTick = GET_PIT_CVAL3_TICK;
            break;

        case HOOK_SDRDEND:
            RdTime += GetTimeElapsed(SDRdTick);
            RdSize += *(uint16_t *)(pData);
            break;

        case HOOK_TM:
            WrSize = 0;
            WrTime = 0;
            RdSize = 0;
            RdTime = 0;
            sdperf.RdPerfCount = 0;
            sdperf.WrPerfCount = 0;
            sdperf.AvgWrPerf = 0;
            sdperf.AvgRdPerf = 0;
            TMInitMicroTimer();
            sdperf.TestTime = SigTime();
            break;

        default:

            break;
    }

    if (WrSize > TM_MAXSDCARDRDWRSIZE){
      sdperf.WrPerfCount++;
      sdperf.AvgWrPerf += (float32_t)((WrSize * 8))/WrTime;
      sdperf.AvgWrPerf /= sdperf.WrPerfCount;
      if (sdperf.AvgWrPerf > sdperf.MaxWrPerf)
      {
          sdperf.MaxWrPerf = sdperf.AvgWrPerf;
      }
      WrSize = 0;
      WrTime = 0;
    }
    if (RdSize > TM_MAXSDCARDRDWRSIZE){
      sdperf.RdPerfCount++;
      sdperf.AvgRdPerf += (float32_t)((RdSize * 8))/RdTime;
      sdperf.AvgRdPerf /=sdperf.RdPerfCount;
      if (sdperf.AvgRdPerf > sdperf.MaxRdPerf)
      {
          sdperf.MaxRdPerf = sdperf.AvgRdPerf;
      }
      RdSize = 0;
      RdTime = 0;
    }
    if(MIN_4 < (SigTime() - sdperf.TestTime))
    {
        Log(TST, "TestMangaer SDCard Average Write speed: %3.3f Mbps, Max Write speed: %3.3f Mbps ", sdperf.AvgWrPerf, sdperf.MaxWrPerf);
        Log(TST, "TestMangaer SDCard Average Read speed: %3.3f Mbps, Max Read speed: %3.3f Mbps", sdperf.AvgRdPerf, sdperf.MaxRdPerf);
        (void)TMResetMicroTimer();
        Log(TST, "Test completed" );
        TestModeActive = false;
        ClearSystemStatus();
    }
}

/* ========================================================================== */
/**
 * \brief   Handler for Timer 3
 *
 * \details
 *
 * \param   < none >
 *
 * \return  None
 *
 * ========================================================================== */

static void TM_TimerHandler(void)
{
    /* Do nothing */
  MicroSecTmrOvf++;
}
/* ========================================================================== */
/**
 * \brief   Test to check USB performance
 *
 * \details  The function calculates the Average and Max throughput for USB
 *              Every 10ms interval - Tx/Rx data transfered / time taken to transfer
 *              Results are averaged for 4min and Logged
 *
 * \param   id - HOOK id indicating if the calling Hook position in code ( either start or finish of Tx/Rx )
 *
 * \param   pData - void pointer to data ( for Start hook its Null, for End hook it carries the size of Tx/Rx data )
 *
 * \return  None
 *
 * ========================================================================== */
static void TestUSBPerformance(HOOKID id, void *pData)
{
    static uint32_t USBTXTime;
    static uint32_t TxSize;
    static uint32_t TxTime;
    static uint32_t USBRXTime;
    static uint32_t RxSize;
    static uint32_t RxTime;
    static USB_PERFPARAM USBPerf;



    switch(id){
        case HOOK_USBTXSTART:
            USBTXTime = GET_PIT_CVAL3_TICK;
            break;

        case HOOK_USBTXEND:
            TxTime += GetTimeElapsed(USBTXTime);
            TxSize += *(uint32_t *)(pData);
            break;

        case HOOK_USBRXSTART:
            USBRXTime = GET_PIT_CVAL3_TICK;
            break;

        case HOOK_USBRXEND:
            RxTime += GetTimeElapsed(USBRXTime);
            RxSize += *(uint32_t *)(pData);
            break;

        case HOOK_TM:
            TxSize = 0;
            TxTime = 0;
            RxSize = 0;
            RxTime = 0;
            USBPerf.RxPerfCount = 0;
            USBPerf.TxPerfCount = 0;
            TMInitMicroTimer();
            USBPerf.TestTime = SigTime();
            break;

        default:

            break;
    }

    if (USBPERFTESTTIME < (TxTime/1000))
    {
      USBPerf.TxPerfCount++;
      USBPerf.AvgTxPerf += (float32_t)((TxSize * 8))/TxTime;
      USBPerf.AvgTxPerf /= USBPerf.TxPerfCount;
      if (USBPerf.AvgTxPerf > USBPerf.MaxTxPerf)
      {
          USBPerf.MaxTxPerf = USBPerf.AvgTxPerf;
      }
      TxSize = 0;
      TxTime = 0;
    }
    if (USBRXPERFTIESTTIME < (RxTime/1000))
    {
      /// \todo 06/13/2022 BS: USB RX calculation should be revisited
      USBPerf.RxPerfCount++;
      USBPerf.AvgRxPerf += (float32_t)((RxSize * 8))/RxTime;
      USBPerf.AvgRxPerf /= USBPerf.RxPerfCount;
      if (USBPerf.AvgRxPerf > USBPerf.MaxRxPerf)
      {
          USBPerf.MaxRxPerf = USBPerf.AvgRxPerf;
      }
      RxSize = 0;
      RxTime = 0;
    }

    if(MIN_4 < (SigTime() - USBPerf.TestTime))
    {
        Log(TST, "TestMangaer USB Average TX speed: %3.3f Mbps, MAX TX speed: %3.3f Mbps", USBPerf.AvgTxPerf, USBPerf.MaxTxPerf );
        Log(TST, "TestMangaer USB Average RX speed: %3.3f Mbps, MAX RX speed: %3.3f Mbps", USBPerf.AvgRxPerf, USBPerf.MaxRxPerf );
        (void)TMResetMicroTimer();
        Log(TST, "Test completed" );
        TestModeActive = false;
        ClearSystemStatus();
    }


}

/* ========================================================================== */
/**
 * \brief   Test OneWire failures
 *
 * \details The function executes the fault simulation if the calling device matches
 *              the device of interest (received from Test command)
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData ( bit map indicating Devices to be tested )
 *
 * \param  id - HOOKID
 *
 * \return  None
 *
 * ========================================================================== */
static void TestOneWireFailure(uint8_t *pData, uint16_t *pTdata, HOOKID id)
{
    ONEWIRE_DEVICES Dev;
    Dev = GetOneWireDevice(pData);

    do
    {
        BREAK_IF(DEVICEUNKOWN == Dev);
        if( (*pTdata & ((uint16_t)BIT1 << Dev)) )
        {
            OneWireFailureSimulation(pData, id, Dev);
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Simulate OneWire failures
 *
 * \details
 *           Authentication fail:
 *           function compares the device being authenticated to the device of interest (received from USB command)
 *           if yes the pData (1st page of Slave EEPROM received from hook in L3_OneWireController OWComputeAuthMac ) is garbled
 *           by making the first byte (Data version number) is made zero.
 *           the same is sent to Master as challenge to calculate the slave MAC. This would result in MAC mismatch resulting in a
 *           UnAuthenticated device
 *
 *           NVM write test fail:
 *           function compare the device under NVM readwirte test to the device of interest (received from USB command)
 *           if yes the NVM Write test byte in EEPROM under test is made zero.
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  HookId - HOOKID
 *
 * \return  None
 *
 * ========================================================================== */
static void OneWireFailureSimulation(uint8_t *pData, HOOKID HookId, ONEWIRE_DEVICES device)
{
  static const uint8_t *devicename[DEVICECOUNT] = { "Handle",
                                                    "Battery",
                                                    "Clamshell",
                                                    "Charger",
                                                    "Adapter",
                                                    "Reload",
                                                    "Catridge"
                                                  };

    BasicOneWireMemoryLayout_Ver2  *pOneWireData;
    pOneWireData = (BasicOneWireMemoryLayout_Ver2 *)pData;
    do
    {
        BREAK_IF (device != GetOneWireDevice(pData));
        if ( (HOOK_ONEWIREAUTH == HookId) && (TC_ONEWIREAUTHENTICATIONFAIL == TM_TestID) )
        {
            Log(TST, "TestManager: Simulating %s Aunthenication Failure", devicename[device]);
            pOneWireData->dataVersion = 0;
        }
        else if ( (HOOK_ONEWIRENVMTEST == HookId) && (TC_ONEWIRENVMTESTFAIL == TM_TestID) )
        {
            Log(TST, "TestManager: Simulating %s NVMTest Failure", devicename[device]);
            pOneWireData->writeTest = 0;

        }
        else if ( (HOOK_ONEWIRECRCTEST == HookId) && (TC_ONEWIRECRCTESTFAIL == TM_TestID) )
        {
            Log(TST, "TestManager: Simulating %s CRCTest Failure", devicename[device]);
            pData[TM_ONEWIRE_PAGEEND_OFFSET]++;
        }
        else
        {
            /* Do Nothing*/
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Get ONeWire Device from the OneWire EEPROM Data
 *
 * \details The function Maps the Signia Device id from EEPROM Data to local ONEWIRE_DEVICES enum
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData ( bit map indicating Devices to be tested )
 *
 * \param  id - HOOKID
 *
 * \return  None
 *
 * ========================================================================== */
static ONEWIRE_DEVICES GetOneWireDevice(uint8_t *pData)
{
    uint16_t SigniaDevID;
    uint16_t DevType;
    uint16_t DevInstance;
    ONEWIRE_DEVICES device;

    device = DEVICEUNKOWN;

    memcpy(&SigniaDevID, &(pData[1]), sizeof(uint16_t));
    DevType = ONEWIRE_ID_TYPE(SigniaDevID);
    DevInstance = ONEWIRE_INSTANCE(SigniaDevID);

    if ( DEVICE_TYPE_MISC == DevType)
    {
      if (DEVICE_HANDLE == DevInstance)
      {
          device = HANDLE;
      }
      if (DEVICE_BATTERY == DevInstance)
      {
          device = BATTERY;
      }
      if (DEVICE_CLAMSHELL == DevInstance)
      {
          device = CLAMSHELL;
      }
    }
    else if (DEVICE_TYPE_ADAPTER == DevType){
        device = ADAPTER;
    }
    else if ((DEVICE_TYPE_EGIA_SULU == DevType ) || (DEVICE_TYPE_EGIA_MULU == DevType ) ||
             (DEVICE_TYPE_EGIA_RADIAL == DevType ) || (DEVICE_TYPE_EEA_RELOAD == DevType ))
    {
        device = RELOAD;
    }
    else if (DEVICE_TYPE_EGIA_CART == DevType ){
        device = CATRIDGE;
    }
    else {
        device = DEVICEUNKOWN;
    }
    return device;

}

/* ========================================================================== */
/**
 * \brief Simulates the GPIO signals for keys based on data from serial command
 *
 * \details  Serial command sets the number of key sequences to be simulated , the delay between key patterns and the bitmap (pattern) of the key sequences.
 *          ( provision given to simulate max of 20 keys patterns in sequence)
 * |-----------|------|-------|-------|-------|-------|-------|-------|-------|-------|-------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
 * |KeySeqCount| Delay| KeyBM1| KeyBM2| KeyBM3| KeyBM4| KeyBM5| KeyBM6| KeyBM7| KeyBM8| KeyBM9|	KeyBM10| KeyBM11| KeyBM12| KeyBM13| KeyBM14| KeyBM15| KeyBM16| KeyBM17| KeyBM18| KeyBM19| KeyBM20|
 * |-----------|------|-------|-------|-------|-------|-------|-------|-------|-------|-------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData
 *
 * \return  None
 *
 * ========================================================================== */
static void TMSimulateKey(GPIO_TM_DATA *pData, TESTDATA *pTdata)
{
    uint8_t KeyId;

  /*! GPIO signals for keys, The order here should match with enum KEY_ID*/
    static const uint8_t KeySignal[KEY_COUNT] =
    {
        GPIO_CLOSE_KEYn,
        GPIO_OPEN_KEYn,
        GPIO_LEFT_ARTIC_KEYn,
        GPIO_RIGHT_ARTIC_KEYn,
        GPIO_LEFT_CW_KEYn,
        GPIO_RIGHT_CW_KEYn,
        GPIO_LEFT_CCW_KEYn,
        GPIO_RIGHT_CCW_KEYn,
        GPIO_GN_KEY1n,
        GPIO_GN_KEY2n
    };
    do
    {
        BREAK_IF(KeySimEnd);
        if ( ( GPIO_GN_KEY1n == pData->Signal )        || ( GPIO_GN_KEY2n == pData->Signal )       ||
             ( GPIO_OPEN_KEYn == pData->Signal )       || ( GPIO_CLOSE_KEYn == pData->Signal )     ||
             ( GPIO_LEFT_CW_KEYn == pData->Signal )    || ( GPIO_LEFT_CCW_KEYn == pData->Signal )  ||
             ( GPIO_RIGHT_CW_KEYn == pData->Signal )   || ( GPIO_RIGHT_CCW_KEYn == pData->Signal ) ||
             ( GPIO_LEFT_ARTIC_KEYn == pData->Signal ) || ( GPIO_RIGHT_ARTIC_KEYn == pData->Signal ) )
        {
            for ( KeyId = 0; KeyId < KEY_COUNT; KeyId++ )
            {
                BREAK_IF( pData->Signal == KeySignal[KeyId]);
            }
            if (( KeyId < KEY_COUNT ))
            {
                *pData->pValue = ( pTdata->KEYDATA.KeyBM[SeqCount] & ((uint16_t)BIT1 << KeyId) )? false : true;
            }
        }

    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Initialize a PIT timer for micro second resolution
 *
 * \details  function initializes PIT TIMER 3 as microsecond timer
 *              - Decrement timer with 60Mhz frequency (60 ticks = 1microsecond)
 *
 * \param   < none >
 *
 * \return  TM_STATUS - TM_STATUSOK if Init successful,
 *                    - TM_STATUSFAIL in case of error
 *
 * \todo 06/13/2022 BS: Check the use of DWT from CpuCycles.h and remove usage of Timer3
 * ========================================================================== */
static TM_STATUS TMInitMicroTimer(void)
{
    TimerControl pControl;
    TIMER_STATUS TimerStatus;
    TM_STATUS Status;
    Status = TM_STATUSFAIL;
    do
    {
        MicroSecTmrOvf = 0;
            /* configure PIT timer3*/
        pControl.TimerId = TIMER_ID4;
        pControl.Mode = TIMER_MODE_PERIODIC;
        pControl.Value = TM_TIMER_MAX_MICROSECONDS-1;
        pControl.pHandler = (&TM_TimerHandler);
        TimerStatus = L2_TimerConfig (&pControl);
        if(TIMER_STATUS_ERROR == TimerStatus)
        {
            Log(TST,"TestManager: L2_TimerConfig Error, SD Card Test not performed ");
            break;
        }
        TimerStatus = L2_TimerStart(TIMER_ID4);
        if(TIMER_STATUS_ERROR == TimerStatus)
        {
            Log(TST,"TestManger: MicroSecond Timer start fail, SD Card Test not performed ");
            break;
        }

        Status = TM_STATUSOK;
    } while (false);
    return Status;
}
/* ========================================================================== */
/**
 * \brief   Reset a PIT timer for micro second resolution
 *
 * \details  function resets PIT TIMER 3 as microsecond timer
 *
 * \param   < none >
 *
 * \return  TM_STATUS - TM_STATUSOK if Init successful,
 *                    - TM_STATUSFAIL in case of error
 *
 * ========================================================================== */
static TM_STATUS TMResetMicroTimer(void)
{
    TM_STATUS Status;
    Status = TM_STATUSOK;

    if(TIMER_STATUS_ERROR == L2_TimerRestart(TIMER_ID4, TM_TIMER_MAX_MICROSECONDS-1))
    {
      Log(TST, "TestManager: MicroTimer Restart fail");
        Status = TM_STATUSFAIL;

    }
    return Status;
}

/* ========================================================================== */
/**
 * \brief   calculate the time elapsed
 *
 * \details  function calculates the time elapsed in Microseconds based on the start time of PIT 3 timer
 *              - Decrement timer with 60Mhz frequency (60 ticks = 1microsecond)
 *
 * \param   StartTick
 *
 * \return  float32_t - Returns the time in microseconds from StartTick to current Tick of PIT 3 timer
 *
 * \note The below function takes care for one timer overflow,
 *              Expectation is that elapsed time shall be < timer overflow time (~71.5sec)
 *
 * ========================================================================== */
static float32_t GetTimeElapsed(uint32_t StartTick)
{
    float32_t TimeElapsed;
    if (StartTick > GET_PIT_CVAL3_TICK)
    {
        TimeElapsed = (TM_TIMER_MAX_MICROSECONDS - (StartTick - GET_PIT_CVAL3_TICK))/60;
    }
    else
    {
        TimeElapsed = (GET_PIT_CVAL3_TICK - StartTick)/60;

    }
    return TimeElapsed;

}

/* ========================================================================== */
/**
 * \brief   Calculating the Elapsed Time
 *
 * \details  function calculates the time elapsed in Microseconds based on the start time
 *
 * \param   StartTick  - Intial tick of the CPU Timer in Micro Seconds
 *
 * \return  uint32_t - Returns the time in microseconds from StartTick to current Tick
 *
 * ========================================================================== */
static uint32_t GetServoTimeElapsed(uint32_t StartTick)
{
    uint32_t ElapsedTime;
    if (StartTick >= CPU_COUNTER_READ())
    {
        ElapsedTime = ((UINT32_MAX_VALUE - StartTick ) + CPU_COUNTER_READ());
    }
    else
    {
        ElapsedTime = (CPU_COUNTER_READ() - StartTick);
    }

    return ElapsedTime;
}


/* ask QM to define the TestManager class -----------------------------------------*/

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::TestManager} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TestManager} .....................................................*/
/*.${AOs::TestManager::SM} .................................................*/
static QState TestManager_initial(TestManager * const me, void const * const par) {
    /*.${AOs::TestManager::SM::initial} */
    QEVENT_TEST_MSG *pTestEvt;
    GetTestManagerNoinitData(&TM_NoinitData);
    if (TM_ONSTARTUP == TM_NoinitData.TM_OnStarup){
        pTestEvt = AO_EvtNew(REQ_TEST_SIG , sizeof(QEVENT_TEST_MSG));
        pTestEvt->size = sizeof(TM_NoinitData.Testdata);
        pTestEvt->RxKey = TM_NoinitData.Key;
        pTestEvt->TestID = TM_NoinitData.TestID;
        memcpy (pTestEvt->Data, &TM_NoinitData.Testdata, pTestEvt->size);
        AO_Post(AO_TestManager,&pTestEvt->Event,NULL);
        Log(TST, "TestManager: TestMode request on startup");
    }

    return Q_TRAN(&TestManager_Idle);
}

/**
 * \brief   This is the startup state for the TestManager Active Object
 *
 * \details This state TaskManager waits for REQ_TEST event
 *   Upon receiving the event authentication is performed to check if the tester is valid.
 *    If the Authentication is passed then the TestMode is activated and state is transitioned to Active
 *
 * \param   me - Pointer to local data store
 * \param   e  - Pointer to present event
 *
 * \return  State transition status: Q_HANDLED(), Q_UNHANDLED(), Q_TRAN(), Q_SUPER()
 *
 * ========================================================================== */
/*.${AOs::TestManager::SM::Idle} ...........................................*/
static QState TestManager_Idle(TestManager * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::TestManager::SM::Idle::REQ_TEST} */
        case REQ_TEST_SIG: {
            QEVENT_TEST_MSG *pInfo = (QEVENT_TEST_MSG *)e;
            TM_TestID = pInfo->TestID;
            /*.${AOs::TestManager::SM::Idle::REQ_TEST::[AuthenticationPass]} */
            if ((pInfo->RxKey == TM_CalculateKey()) || (TM_ONSTARTUP == TM_NoinitData.TM_OnStarup)) {
                /* Authentication pass indicating connection to a valid tester */
                memcpy(&TM_TestData,pInfo->Data,pInfo->size);

                /// \todo 05/26/2022 BS: Send Response packet
                Log(TST, "TestManager: TestMode activated");
                status_ = Q_TRAN(&TestManager_Active);
            }
            /*.${AOs::TestManager::SM::Idle::REQ_TEST::[AuthenticatonFail]} */
            else {
                /* Recieved key did not match the calculated key*/

                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * \brief   This is the running state for the TestManager Active Object
 *
 * \details The TestManager object handles the execution
 *    of requested test
 *    The TestMode is exited after a timeout by performing a Soft Reset
 *
 * \param   me - Pointer to local data store
 * \param   e  - Pointer to present event
 *
 * \return  State transition status: Q_HANDLED(), Q_UNHANDLED(), Q_TRAN(), Q_SUPER()
 *
 * ========================================================================== */
/*.${AOs::TestManager::SM::Active} .........................................*/
static QState TestManager_Active(TestManager * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::TestManager::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Start Test mode timeout timer */
            AO_TimerArm(&me->TMTimer, TM_TIMEOUT_TIME_MS, 0);
            TestModeActive = true;
            SetSystemStatus(SYSTEM_STATUS_TESTMODE);

            TM_Hook(HOOK_TM, NULL);
            if(TC_KEYSIMULATION == TM_TestID )
            {
                AO_TimerArm(&me->TMKeyHoldTmr, TM_TestData.KEYDATA.KeySeqDelay, TM_TestData.KEYDATA.KeySeqDelay);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TestManager::SM::Active::TM_TIMEOUT} */
        case TM_TIMEOUT_SIG: {
            /* Test Mode time out, perform a soft reset */
            Log(TST, "TestManager: TestMode Timeout, performing soft reset");
            TestModeActive = false;
            ClearSystemStatus();
            OSTimeDly(MSEC_50); // delay to ensure logging happens
            SoftReset();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TestManager::SM::Active::REQ_TEST} */
        case REQ_TEST_SIG: {
            QEVENT_TEST_MSG *pInfo = (QEVENT_TEST_MSG *)e;

            /*.${AOs::TestManager::SM::Active::REQ_TEST::[AuthenticationPass]} */
            if (((TM_TestID == pInfo->TestID) && (pInfo->RxKey == TM_CalculateKey()))) {
                /* Authentication pass indicating connection to a valid tester */
                memcpy(&TM_TestData,pInfo->Data,pInfo->size);
                AO_TimerDisarm(&me->TMTimer);
                AO_TimerDisarm(&me->TMKeyHoldTmr);
                /// \todo 05/26/2022 BS: Send Response packet
                Log(TST, "TestManager: Subsequent test command accepted");
                status_ = Q_TRAN(&TestManager_Active);
            }
            /*.${AOs::TestManager::SM::Active::REQ_TEST::[AuthenticatonFail]} */
            else {
                /* Received key did not match the calculated key or
                TestID is different from the TestID in ongoing Test sesssion*/
                Log(TST, "TestManager: subsequent test commands not accepted");
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::TestManager::SM::Active::TM_KEYTIMEOUT} */
        case TM_KEYTIMEOUT_SIG: {
            SeqCount++;
            if(SeqCount >= TM_TestData.KEYDATA.KeySeqCount)
            {
                SeqCount = TM_TestData.KEYDATA.KeySeqCount-1;
                AO_TimerDisarm(&me->TMKeyHoldTmr);
                KeySimEnd = true;
            }
            WakeupPinCallback = L2_GpioGetPinConfig(GPIO_uP_PORT_C,GPIO_PIN_03);
            if(WakeupPinCallback != NULL)
            {
                WakeupPinCallback();
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::TestManager} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/******************************************************************************/
/*                             Global Function(s)                             */
/******************************************************************************/
void TM_Hook(HOOKID id, void *pData)
{
    do
    {
        BREAK_IF((!TestModeActive) || (!GetSystemStatus(SYSTEM_STATUS_TESTMODE)));

        switch (TM_TestID)
        {

            case TC_TASKMONITOR_STACKFAULT:
                if( HOOK_TM == id )
                {
                    TestSimulateTaskMonitorFault(STACK);
                }
                break;

            case TC_TASKMONITOR_CPUUTILIFAULT:
                if( HOOK_TM == id )
                {
                   TestSimulateTaskMonitorFault(CPULOAD);
                }
                break;

            case TC_TASKMONITOR_TASKCHKFAIL:
                if( HOOK_TM == id )
                {
                  TestSimulateTaskMonitorFault(CHECKIN);
                }
                break;

            case TC_SIM_BATTPARAM:
                if ( HOOK_BATTERYPARAMETER == id )
                {
                    TestSimulateBattParam((CHARGER_INFO *)pData, &TM_TestData);
                }
                break;

            case TC_SDCARD_RDWRPERFORMANCE:
                if ( HOOK_SDWRSTART == id || HOOK_SDWREND == id ||\
                     HOOK_SDRDSTART == id || HOOK_SDRDEND == id ||
                     HOOK_TM == id )
                {
                    TestSDCardPerformance(id,pData);
                }
                break;

            case TC_USB_PERFORMANCE:
                if ( HOOK_USBTXSTART == id || HOOK_USBTXEND == id ||\
                     HOOK_USBRXSTART == id || HOOK_USBRXEND == id ||\
                     HOOK_TM == id)
                {
                    TestUSBPerformance(id,pData);
                }
                break;

           case TC_MTR_PERFORMANCE:
                if (HOOK_MTRSPEED == id  || HOOK_TM == id ||\
                    HOOK_MTRSERVOSTART == id || HOOK_MTRSERVOEND == id )
                {
                   TestSimulateMotorParam((MOTOR_CTRL_PARAM *)pData,  &TM_TestData, id);
                }
                break;

            case TC_MTR_POSITION_CHECK:
                if ( HOOK_TM == id )
                {
                    TestSimulateMotorPosition((MOTOR_CTRL_PARAM *)pData,  &TM_TestData);
                }
                break;
            case TC_MEM_FAULT_RAMINTEXTINTGRTY:
                if ( HOOK_TM == id || HOOK_RAMPATTERNFAIL == id ||\
                     HOOK_RAMANTIPATTERNFAIL == id )
                {
                    TestRAMIntegrityFault(pData,  &TM_TestData, id);
                }
                break;
            case TC_ONEWIREAUTHENTICATIONFAIL:
            case TC_ONEWIRENVMTESTFAIL:
            case TC_ONEWIRECRCTESTFAIL:
                if ( HOOK_ONEWIREAUTH == id || HOOK_ONEWIRENVMTEST == id || HOOK_ONEWIRECRCTEST == id)
                {
                    TestOneWireFailure((uint8_t *)pData, (uint16_t *)&TM_TestData, id);
                }

                if (HOOK_TM == id )
                {
                    // OneWire Authentication for Handle and Battery occurs during Handle startup
                    // to simulate the Failure we store the Test data in noInit ram and reset the Handle
                    // during starup the TestManager init routine should check for the TM_noInit data and take necessary action
                    // The If condition is entered only if there is no data in No init ram indicating instance of command received from USB
                    if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) &&
                          (TM_TestData.OWDeviceBM & TM_HANDLEBATTERY) )
                    {
                        TM_NoinitData.Key =  TM_CalculateKey();
                        TM_NoinitData.TestID = TM_TestID;
                        TM_NoinitData.Testdata = TM_TestData.OWDeviceBM;
                        TM_NoinitData.TM_OnStarup = TM_ONSTARTUP;
                        UpdateTestManagerNoinitData(&TM_NoinitData);
                        Log(TST, "TestManger: Reset the device to simulate Handle/Battery Onewire Authentication Failure ");
                        OSTimeDly(MSEC_100); // delay to ensure logging happens
                        SoftReset();
                    }
                    else if (TM_NoinitData.Testdata)// if the reset is to simulate Handle or Battery onewire Authentication failure clear the noinit data
                    {
                        ClearTestManagerNoinitData();
                    }
                    else
                    {
                        /* Do nothing */
                    }
                }
                break;

		   case TC_OS_FAILURES:
                if ( HOOK_TM == id )
                {
                    SimulateOSTaskErrors(&TM_TestData);
                }
                else if( HOOK_OSMUTEXFAIL == id || HOOK_OSTASKFAIL == id ||\
                         HOOK_OSQUEFAIL == id )
                {
                     SimulateOSFailures((void *)pData, id);
                }
                break;

            case TC_SD_CARD_ERRORS:
                if ( HOOK_FILESYSTEMERROR == id )
                {
                    SimulateSDCardErrors((uint8_t *)pData, &TM_TestData, id);
                }
                if (HOOK_TM == id )
                {
                    if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) && (TM_TestData.SDCDErrID))
                    {
                        TM_NoinitData.Key =  TM_CalculateKey();
                        TM_NoinitData.TestID = TM_TestID;
                        TM_NoinitData.Testdata = TM_TestData.SDCDErrID;
                        TM_NoinitData.TM_OnStarup = TM_ONSTARTUP;
                        UpdateTestManagerNoinitData(&TM_NoinitData);
                        Log(TST, "TestManger: Reset the device to simulate SD Card Failure ");
                        OSTimeDly(MSEC_100);
                        SoftReset();
                    }
                    else if (TM_NoinitData.Testdata)
                    {
                        ClearTestManagerNoinitData();
                    }
                    else
                    {
                        /* Do nothing */
                    }
                }
                break;


            case TC_KEYSIMULATION:
                if ( HOOK_GPIOSIGNAL == id )
                {
                    TMSimulateKey( (GPIO_TM_DATA *)pData, &TM_TestData);
                }
                else if ( HOOK_TM == id )
                {
                    // publish the Semaphore via the WakeupPinCallback function. This is required to get the Keypad module out of wait state.
                    WakeupPinCallback = L2_GpioGetPinConfig(GPIO_uP_PORT_C,GPIO_PIN_03);
                    if(WakeupPinCallback != NULL)
                    {
                        KeySimEnd = false;
                        SeqCount = 0;
                        WakeupPinCallback();

                    }
                }
                else
                {
                    /* Do nothing */
                }
                break;
				
	  case TC_EVE_LOGGING:
              if( HOOK_TM == id || HOOK_LOGCNTROLLOVER == id )
                {
                   SimulateLoggingEvents(pData, &TM_TestData, id);
                }
				break;  
              
      case TC_CRCFAILURES: 
          if( HOOK_TM == id || HOOK_SPICRCFAIL == id ||\
              HOOK_ADAPTERCRCFAIL == id )
            {
               SimulateCRCFailures(pData, &TM_TestData, id);
            }
            break; 
          
        case TC_BATTFLASHPARAMFAIL: 
               if ( HOOK_BATTERYDFFIAL == id )
                {
                  SimulateBatteryFalshParamters((BATT_DF_TM_DATA *)pData, &TM_TestData, id);
                }
                
                if (HOOK_TM == id )
                {
                    
                    if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) && (TM_TestData.BattDFParam.CW))
                    {
                        TM_NoinitData.Key =  TM_CalculateKey();
                        TM_NoinitData.TestID = TM_TestID;
                        TM_NoinitData.Testdata = TM_TestData.BattDFParam.CW;
                        TM_NoinitData.TM_OnStarup = TM_ONSTARTUP;
                        UpdateTestManagerNoinitData(&TM_NoinitData);
                        Log(TST, "TestManger: Reset the device to simulate Battery DF Params ");
                        OSTimeDly(MSEC_100);
                        SoftReset();
                    }
                    else if (TM_NoinitData.Testdata)
                    {
                        ClearTestManagerNoinitData();
                    }
                    else
                    {
                        /* Do nothing */
                    }
                }
            break;
            default:
                break;
        }//switch end
    } while(false);
}


/*.$define${AOs::TestManagerCtor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TestManagerCtor} .................................................*/
void TestManagerCtor(void) {
    TestManager *me = (TestManager *)AO_TestManager;

    AO_TimerCtor(&me->TMTimer, &me->super, TM_TIMEOUT_SIG);  // Build timer
    AO_TimerCtor(&me->TMKeyHoldTmr, &me->super, TM_KEYTIMEOUT_SIG);  // Build timer

    AO_Start(AO_TestManager,                             // Pointer to QActive object (AO)
             Q_STATE_CAST(&TestManager_initial),         // Pointer to initial transition
             SIGNIA_TASK_PRIO_TM,                  // Task priority
             TMEventQueue,                      // Pointer to event queue
             TM_EVQ_SIZE,                       // Size of event queue (in entries) This could be Q_DIM(MotorDevStubs_queueSto
             TMStack,                           // Pointer to stack (bottom)
             TM_STACK_SIZE,                     // Stack size This could be Q_TIM(MotorDevStubs
             NULL,                                  // Pointer to object specific initialization parameters
             AOname);                               // Pointer to name of active object
}
/*.$enddef${AOs::TestManagerCtor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/**
 * \}
 */

#ifdef __cplusplus  /* header compatible with C++ project */
}
#endif