/*.$file${..\Source::EGIA.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: EGIA.qm
* File:  ${..\Source::EGIA.c}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-SP-170817A
* Issued to   : Covidien LP
* Framework(s): qpc
* Support ends: 2022-08-17
* Product(s)  :
* Signia Powered Stapler
*/
/*.$endhead${..\Source::EGIA.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifdef __cplusplus  /* header compatible with C++ project */
extern "C"
{
#endif

/* ========================================================================== */
/**
 * \addtogroup EGIA
 * \{
 *
 * \brief   This is the state collection for the EGIA superstate.
 *
 * \details This file provides the state definitions for control of the handle operations when ADAPTER is connected.
 *          All EGIA requirements will be part of EGIA.qm.
 *          EGIA APP doesn't have its own thread, it will be called as part of Platform APP thread when Adapter is connected.
 *          EGIA APP is part of the App AO, and thus has no instantiation.
 *          EGIA uses the local data store passed in the me pointer, it points to a structure of type App, not type EGIA (Hence the ME macro), and in addition, does have local data of its own.
 *          This local data is statically allocated (NOT part of task creation, as is the case with App) and as a result, the EGIA code may not have threads running through it.
 *          There is no plan to have thread for EGIA and is a limitation.
 *          This is the external model referred to in the App.qm model
 *
 * \copyright 2021 Covidien - Surgical Innovations. All Rights Reserved.
 *
 * \file    EGIA.c
 *
 * ========================================================================== */
/******************************************************************************/
/*                             Include                                        */
/******************************************************************************/
#include "Signia.h"
#include "EGIA.h"
#include "EGIAutil.h"
#include "EGIAscreens.h"
#include "L4_GpioCtrl.h"
#include "FaultHandler.h"   /// \todo 08/05/2022 DAZ - Possible layer violation?
#include "TestManager.h"
#include "HandleUtil.h"

/******************************************************************************/
/*                             Local Define(s) (Macros)                       */
/******************************************************************************/


/******************************************************************************/
/*                    Local Type Definition(s) / Function Prototypes          */
/******************************************************************************/

/******************************************************************************/
/*                             Local Constant Definition(s)                   */
/******************************************************************************/

/******************************************************************************/
/*                             Local Variable Definition(s)                   */
/******************************************************************************/
/*
Note that the below Egia variables are not thread safe.
Since the current design only has single thread accessing these variables, safe to use for now.
*/
/// \todo 25/10/2021 CPK  Since the Egia memory is not shared, we might endup allocating memory for each adapter(EEA etc..) added to this design.
/// \todo 25/10/2021 CPK consider using a common memory pool while adding new adapter support

static APP_EGIA_DATA            Egia;          // EGIA Variables
static APP_EGIA_DATA            *pEgia;        // Pointer to EGIA Variables
static QEVENT_MOTOR_STOP_INFO   *pStopInfo;    // Pointer to motor stop info signal
static QEVENT_CHARGER           *pInfo;        // Pointer to charger info signal

/******************************************************************************/
/*                             Local Function(s)                              */
/******************************************************************************/

/* Ask QM to define the EGIA class (State machine) ------------------------*/

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::EGIA} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

// NOTE: This structure is not used. This model is simply a
//       substate of the Handle model. It's me pointer points
//       to a structure of type Handle, defined in the Handle
//       model. See the structure definition in Handle.qm
//       for the definition for this object.
/*.${AOs::EGIA} ............................................................*/
/*.${AOs::EGIA::SM} ........................................................*/

/**
 * \brief   EGIA superstate
 *
 * \details  This is the state that is transferred to from the external Handle.qm
 *           model. All superstate references to the Handle_Operate state (superstate
 *           of EGIA_Operate) go through this state. Thus, all states in this model
 *           that wish to have the top level as a superstate must be substates
 *           of this one.
 *
 * \param   me - Pointer to data area. Cast to proper type with ME() macro when
 *               dereferencing.
 * \param   e - Pointer to event
 *
 * \return  State status
 * \retval  Q_RET_SUPER - Refer to superstate for event processing
 * \retval  Q_RET_HANDLED - Event handled by this state
 * \retval  Q_RET_TRAN - Perform state transition
 *
 *  /// \todo 08/15/2021 NP Don't Test with Adapter Connected
 *  /// \todo 08/15/2021 NP Need a Change for Adapter Connected Scenario
 *
 *
 *
 * ========================================================================== */
/*.${AOs::EGIA::SM::Operate} ...............................................*/
QState EGIA_Operate(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate} */
        case Q_ENTRY_SIG: {
            pEgia = &Egia;
            AM_HANDLE_IF       *pHandle;

            /* Retraction Not Started */
            pEgia->RetractionStatus = RETRACTION_NOTSTARTED;
            AO_TimerDisarm(&ME->Timer);    // Ensure timer is disarmed
            Log(TRC, "****  Entering EGIA Super State ****");

            /* Read Handle data and calculate Remaining Handle Procedures */
            pHandle = HandleGetIF();
            pEgia->HandleProcRemaining = ((pHandle->Data.ProcedureLimit) - (pHandle->Data.ProcedureCount));

            /* Read Adapter Procedure Limit & count and calculate Remaining Adapter Procedures */
            DeviceMem_READ(ME->Adapter, ProcedureCount, pEgia->AdapterProcedureCounter);
            DeviceMem_READ(ME->Adapter, ProcedureLimit, pEgia->AdapterProcedureLimit);
            pEgia->AdapterProcRemaining = pEgia->AdapterProcedureLimit - pEgia->AdapterProcedureCounter;

            if (AM_DEVICE_CONNECTED != ME->Adapter.Status)
            {//do not allow any handle operations(except emergency retract)

                QEVENT_ADAPTER_MANAGER *pEvent;

                pEvent = AO_EvtNew(P_ADAPTER_ERROR_SIG, sizeof(QEVENT_ADAPTER_MANAGER));

                if (pEvent)
                {
                    Log(DBG, "P_ADAPTER_ERROR_SIG generated in EGIA operate");
                    AO_Publish(pEvent, NULL);
                }
                else
                {
                    Log(DBG, "Signia Event allocation error");
                }
            }
            else
            {
                pHandle = HandleGetIF();
                pEgia->HandleProcRemaining = ((pHandle->Data.ProcedureLimit) - (pHandle->Data.ProcedureCount));

                pEgia->PrevSwitch.State = SWITCH_STATE_OPEN;
                ME->WaitFor1WireReload = true;
                /* Read Reload switch data via command */
                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_GET_EGIA_SWITCHDATA,0) )
                {
                    Log(DEV, "AdapterEvents: Adapter SwitchDataRead Request Failed");
                    break;
                }
                Log(DEV, "AdapterEvents: Adapter SwitchDataRead Request Successful");
                EGutil_LoadDefaultCalibParams();
                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_GET_FLASHDATA,0) )
                {
                    Log(DEV, "AdapterEvents: Adapter FlashDataRead Request Failed");
                    break;
                }
                Log(DEV, "AdapterEvents: Adapter FlashDataRead Request Successful");

                /* register function for egia specific strain gauge processing */
                L4_RegisterAdapterAppCallback(&EGutil_ProcessEgiaStrainGaugeRawData, ADAPTER_APP_STRAIN_GAUGE_INDEX);
                /* register call back function for egia reload switch data */
                L4_RegisterAdapterAppCallback(&EGutil_ProcessEgiaReloadSwitchData  , ADAPTER_APP_RELOADSWITCH_INDEX);

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_ENABLE_SWEVENTS,0) )
                {
                    Log(DEV, "AdapterEvents: Adapter EnableEGIASwitch Request Failed");
                    break;
                }
                Log(DEV, "AdapterEvents: Adapter EnableEGIASwitch Request Successful");

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_START_SGSTREAM,0) )
                {
                    Log(DEV, "AdapterEvents: Adapter SGStreamStart Request Failed");
                    break;
                }
                Log(DEV, "AdapterEvents: Adapter SGStreamStart Request Successful");

                AO_Subscribe(AO_Handle, P_ARTIC_STOP_SIG);         // Subscribe to necessary signals. NOTE: These may be relegated to a helper function
                AO_Subscribe(AO_Handle, P_FIRE_STOP_SIG);
                AO_Subscribe(AO_Handle, P_ROTATE_STOP_SIG);
                AO_Subscribe(AO_Handle, P_CARTRIDGE_CONNECTED_SIG);
                AO_Subscribe(AO_Handle, P_CARTRIDGE_REMOVED_SIG);
                // Set one shot timer to allow 1-wire bus scan
                AO_TimerArm(&ME->Timer, EGIA_TIMEOUT_2_SEC, 0);

                AO_Subscribe(AO_Handle, P_TOGGLE_DOWN_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_TOGGLE_DOWN_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_TOGGLE_UP_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_TOGGLE_UP_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_TOGGLE_LEFT_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_TOGGLE_LEFT_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_TOGGLE_RIGHT_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_LEFT_UP_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_LEFT_UP_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_RIGHT_UP_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_RIGHT_UP_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_LEFT_DOWN_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_TOGGLE_RIGHT_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_LEFT_DOWN_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_RIGHT_DOWN_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_LATERAL_RIGHT_DOWN_PRESS_SIG);
                AO_Subscribe(AO_Handle, P_EGIA_RELOAD_CONNECTED_SIG);
                AO_Subscribe(AO_Handle, P_EGIA_RELOAD_REMOVED_SIG);
                AO_Subscribe(AO_Handle, P_REQ_RST_SIG);
                AO_Subscribe(AO_Handle, P_SAFETY_RELEASE_SIG);
                AO_Subscribe(AO_Handle, P_SAFETY_PRESS_SIG);

                /* Calibration Not Started */
                pEgia->CalibrationStatus = CALIBRATION_NOTSTARTED;
                /* Battery is Sufficient */
                pEgia->SufficientBattery          = true;
                pEgia->FiringComplete = false;
                pEgia->FPGAResetFireMode = false;
                pEgia->IsCartridgeCompatible = false;
                pEgia->ExtraTimeForReloadCheck = false;
                ME->EgiaReload.Status = AM_DEVICE_DISCONNECTED;
                /* Default Handle Fire Counter Value */
                pEgia->HandleFireCountUpdated = FIRE_COUNT_UPDATE_DEFAULT;
                pEgia->RotateAllowed = false;
                pEgia->ArticAllowed  = false;

                /* Check Adapter EOL */
                if(!ME->Adapter.ConnectorBusShort)
                {
                    EGutil_ProcessAdapterEOL(ME);
                    DeviceMem_READ(ME->Adapter, ProcedureCount, pEgia->AdapterProcedureCounter);
                    DeviceMem_READ(ME->Adapter, ProcedureLimit, pEgia->AdapterProcedureLimit);
                    pEgia->AdapterProcRemaining = pEgia->AdapterProcedureLimit - pEgia->AdapterProcedureCounter;
                }
            }

             pEgia->BatteryLevel = ME->pChargerInfo->BatteryLevel;
             EGUtil_InitRotationConfig(ME);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate} */
        case Q_EXIT_SIG: {
            // inactive timer.
            AO_TimerDisarm(&ME->Timer);
            AO_TimerDisarm(&ME->ReloadSwitchTimer);

            //Unlock Adapter EOL Screen
            Gui_AdapterEOL_ScreenUnlock();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::R_EMPTY, R_INIT} */
        case R_EMPTY_SIG: /* intentionally fall through */
        case R_INIT_SIG: {

            // All unprocessed system signals must be referred to the external
            // superstate.

            // Be SURE to catch R_ENTRY, R_INIT and R_EXIT if the entry, initial,
            // and exit transitions are not defined.

            // R_EMPTY is an internal signal that is used by the dispatcher to
            // determine state nesting. Do NOT use this signal for any purpose
            // other than this.

            // This will allow us to intercept the dispatcher's search function
            // and substitute our own superstate reference in the other file.

            // NO OTHER PROCESSING SHOULD BE PERFORMED HERE!

            // Between this and the CATCH_ALL pseudo-signal, we are effectively
            // rewriting the default case of this state. Instead of referencing
            // our parent bubble (QHsm_top), we are referencing the parent bubble (superstate)
            // in an external model.

            // The if statement is to avoid compiler complaints about unreachable code.

            if (me)
            {
                status_ = Q_SUPER(Handle_Operate);
                break;
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::TIMEOUT} */
        case TIMEOUT_SIG: {
            ///\todo 10/05/2021 BS - API (to read and validate) needs to be finalized
            bool Status;
            SWITCH_DATA Switch;
            Status = false;
            ME->Adapter.pHandle->pAdapterGetSwitchState(&Switch);
            /* Disallow Retraction: Any reload connected post timeout should not enter retraction.*/
            pEgia->RetractionStatus = RETRACTION_NOTALLOWED;
            do
            {
                /* Do not allow calibration, other operations when ADAPTER CRC failed */
                if ( ME->Adapter.CRCFailed )
                {
                    break;
                }
                /* Do not allow calibration, other operations when CONNECTOR bus shorted */
                if ( ME->Adapter.ConnectorBusShort )
                {
                    break;
                }
                /* Do not allow calibration, other operations when ADAPTER authentication failed */
                if ( AUTHENTICATION_FAILED == ME->Adapter.Authenticated )
                {
                    break;
                }
                /* If Reload switch is connected break */
                if ( SWITCH_STATE_CLOSED == Switch.State )
                {
                    break;
                }
                /* If Adapter coefficient not read then break */
                if ( !pEgia->CoefficientsStatus )
                {
                    break;
                }
                Status = true;
            } while (false);
            /*.${AOs::EGIA::SM::Operate::TIMEOUT::[Status_OK]} */
            if ((Status) && (!(ME->Adapter.InErrorstate))) {
                // Set motor home positions before starting calibrate
                /// \todo 08/25/2021 NP -  Home position ticks to be updated for all motor
                Signia_MotorSetPos(ARTIC_MOTOR, 0); // Set starting points for calibration
                Signia_MotorSetPos(FIRE_MOTOR, 0);
                Signia_MotorSetPos(ROTATE_MOTOR, 0);

                /* Check for the Clamshell Error and display the screen */
                if (ME->Clamshell.ClamshellEOL)
                {
                    ScreenAdapterProgressCalib(true, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }
                else
                {
                    ScreenAdapterProgressCalib(false, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }

                /* Calibration In Progress */
                pEgia->CalibrationStatus = CALIBRATION_INPROGRESS;

                status_ = Q_TRAN(&EGIA_Calibrate);
            }
            /*.${AOs::EGIA::SM::Operate::TIMEOUT::[Status_FAIL]} */
            else {
                // check if reload detected and allow
                if (AM_DEVICE_CONNECTED != ME->EgiaReload.Status)
                {
                    Signia_PlayTone(SNDMGR_TONE_FAULT);
                    Gui_AdapterErrorScreen();
                }
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_EGIA_RELOAD_CONNECTED} */
        case P_EGIA_RELOAD_CONNECTED_SIG: {
            EGutil_ProcessDeviceConnEvents(ME,e);
            /* Disable Timer */
            AO_TimerDisarm(&ME->Timer);
            /* Start 3 sec timer to identify Reload Type */
            AO_TimerArm(&ME->ReloadSwitchTimer, SEC_3 , 0);
            /// \todo SET FIRE MOTOR ( B1 SHAFT ) to HomePosition. This is part of story 1423
            /* Calibration Failed due to Reload Connected */
            pEgia->CalibrationStatus = CALIBRATION_FAILED_RELOADCONNECTED;
            /*.${AOs::EGIA::SM::Operate::P_EGIA_RELOAD_CO~::[AllowRetraction]} */
            if (RETRACTION_NOTSTARTED == pEgia->RetractionStatus) {
                /* Retraction In Progress */
                pEgia->RetractionStatus = RETRACTION_INPROGRESS;

                /* Log Reload connected message */
                Log(TRC, "**** RELOAD attached before EGIA ADAPTER Calibration ****");
                Log(TRC, "**** Retract the RELOAD ****");
                Log(REQ, "**** EGIA Retraction - Show ADAPTER with RELOAD attached screen ****");

                if (ME->Clamshell.ClamshellEOL)
                {
                    Gui_AdapterReload_ScreenSet(true, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }
                else
                {
                    Gui_AdapterReload_ScreenSet(false, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }

                status_ = Q_TRAN(&EGIA_AutomaticRetract_ProximalEndStop);
            }
            /*.${AOs::EGIA::SM::Operate::P_EGIA_RELOAD_CO~::[RetractionNotAllowed]} */
            else {
                /* Reload connected post timeout. Do not allow retraction*/
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_BATTERY_LOW} */
        case P_BATTERY_LOW_SIG: {
            pEgia->SufficientBattery = false;

            /* Play Low Battery Tone in ST_ERR_BATT_LOW state #Req ID: 253594 */
            Signia_PlayTone(SNDMGR_TONE_LOW_BATTERY);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_BATTERY_INFO} */
        case P_BATTERY_INFO_SIG: {
            pInfo = (QEVENT_CHARGER *)e;
            bool ReloadConnected;

            LOG_BATT_INFO(pInfo);
            /* Check if Reload connected - Battery error status is updated based on Reload Connection status */
            if ( (AM_DEVICE_CONNECTED == ME->Reload.Status) ||
                (AM_DEVICE_CONNECTED == ME->EgiaReload.Status) )
            {
                ReloadConnected = true;
            }
            else
            {
                ReloadConnected = false;
            }
            /* Check Battery Voltage Low, Insufficient or Shutdown Errors */
            HNutil_Signia_BatteryUpdateErrors(&pInfo->Info, ME, ReloadConnected);

            /// \\todo 04/06/2022 KA - change one data type to eliminate the cast?
            pEgia->BatteryLevel = pInfo->Info.BatteryLevel;
            pEgia->BatCommState = pInfo->Info.BatCommState;

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_TOGGLE_LEFT_PRESS} */
        case P_TOGGLE_LEFT_PRESS_SIG: {
            uint16_t KeyState;

            /*Multi Key State*/
            KeyState = ME->KeyState;
            EGUtil_StartArticulation(TOGGLE_LEFT, KeyState);
            TM_Hook(HOOK_ARTIC_LEFT_MTR_CRNT_SIMULATE, NULL);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_TOGGLE_RIGHT_PRESS} */
        case P_TOGGLE_RIGHT_PRESS_SIG: {
            uint16_t KeyState;

            /*Multi Key State*/
            KeyState = ME->KeyState;
            EGUtil_StartArticulation(TOGGLE_RIGHT, KeyState);
            TM_Hook(HOOK_ARTIC_RIGHT_MTR_CRNT_SIMULATE, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_TOGGLE_LEFT_RELEASE,P_TOGGLE_R~} */
        case P_TOGGLE_LEFT_RELEASE_SIG: /* intentionally fall through */
        case P_TOGGLE_RIGHT_RELEASE_SIG: {
            /// \todo 18/04/2022 AR: Need to handle multi key press during Articulation
            if ( pEgia->ArticAllowed )
            {
                EGutil_UpdateArticulation(MOTOR_STOP, NULL, NULL);
            }
            else
            {
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_LATERAL_LEFT_UP_PRESS,P_LATERA~} */
        case P_LATERAL_LEFT_UP_PRESS_SIG: /* intentionally fall through */
        case P_LATERAL_RIGHT_DOWN_PRESS_SIG: /* intentionally fall through */
        case P_LATERAL_LEFT_DOWN_PRESS_SIG: /* intentionally fall through */
        case P_LATERAL_RIGHT_UP_PRESS_SIG: {
            do
            {
                EGUtil_ProcessRotationRequest(e,ME);
                TM_Hook(HOOK_LUP_RDN_ROTATION_MTR_CRNT_SIMULATE, NULL);

            } while ( false );


            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_LATERAL_LEFT_UP_RELEASE,P_LATE~} */
        case P_LATERAL_LEFT_UP_RELEASE_SIG: /* intentionally fall through */
        case P_LATERAL_RIGHT_DOWN_RELEASE_SIG: /* intentionally fall through */
        case P_LATERAL_LEFT_DOWN_RELEASE_SIG: /* intentionally fall through */
        case P_LATERAL_RIGHT_UP_RELEASE_SIG: {
            if ( pEgia->RotateAllowed )
            {
                EGUtil_ProcessRotationRequest(e,ME);
            }
            else
            {
                pEgia->RotateAllowed = true;
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::SWITCH_STATE_TIMEOUT} */
        case SWITCH_STATE_TIMEOUT_SIG: {
            /* One wire Reload is not detected */
            if ( AM_DEVICE_CONNECTED != ME->Reload.Status )
            {
                /* Get Reload Device Type */
                EGutil_GetReloadDeviceTypeLength(ME);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_RELOAD_CONNECTED} */
        case P_RELOAD_CONNECTED_SIG: {
            bool TimerRunStatus;
            HNutil_ProcessDeviceConnEvents(ME,e);
            /* Get ReloadSwitch Timer running Status */
            TimerRunStatus = AO_TimerIsRunning(&ME->ReloadSwitchTimer);
            if ( TimerRunStatus )
            {
                /* Timer is running, stop the timer */
                AO_TimerDisarm(&ME->ReloadSwitchTimer);
                /* One wire Reload is detected, get reload type */
                EGutil_GetReloadDeviceTypeLength(ME);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_RELOAD_REMOVED} */
        case P_RELOAD_REMOVED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::RETRY_FIRE_COUNT_UPDATE_TIMEOUT} */
        case RETRY_FIRE_COUNT_UPDATE_TIMEOUT_SIG: {
            /*
            * Note - Retry Timer is handling -
            *                           Adapter Fire Counter update retry
            *                           Adapter Procedure Counter update retry
            *                           Handle Fire Counter update retry
            */
            uint16_t TempNewCounter;
            TempNewCounter = 0;
            Log(REQ, "**** Timer Running For Update the Handle Fire Counter ****");

            if (FIRE_COUNT_UPDATE_FAILED == pEgia->HandleFireCountUpdated)
            {
                //Read the Updated Handle Fire Counter Value
                DeviceMem_READ(ME->Handle, FireCount, TempNewCounter);
                /* Handle Fire Counter update check */
                if (pEgia->PrevHandleFireCounter < TempNewCounter)
                {
                    pEgia->HandleFireCountUpdated = FIRE_COUNT_UPDATE_SUCCESS;
                }
                else
                {
                    pEgia->HandleFireCountUpdated = FIRE_COUNT_UPDATE_FAILED;
                    // update and write the Firing Counter Value
                    TempNewCounter = pEgia->PrevHandleFireCounter;
                    TempNewCounter++;
                    DeviceMem_WRITE(ME->Handle, FireCount, TempNewCounter);
                }
            }

            if (FIRE_COUNT_UPDATE_FAILED == pEgia->AdapterProcCountUpdated)
            {
                //Read the Updated Adapter Procedure Counter Value
                DeviceMem_READ(ME->Adapter, ProcedureCount, TempNewCounter);
                /* Adapter Procedure Counter update check  */
                if (pEgia->PrevAdapterProcCounter < TempNewCounter)
                {
                    pEgia->AdapterProcCountUpdated = FIRE_COUNT_UPDATE_SUCCESS;
                }
                else
                {
                    pEgia->AdapterProcCountUpdated = FIRE_COUNT_UPDATE_FAILED;
                    // update and write the Adapter Procedure Counter Value
                    TempNewCounter = pEgia->PrevAdapterProcCounter;
                    TempNewCounter++;
                    DeviceMem_WRITE(ME->Adapter, ProcedureCount, TempNewCounter);
                }
            }

            if (FIRE_COUNT_UPDATE_FAILED == pEgia->AdapterFireCountUpdated)
            {
                //Read the Updated Adapter Fire Counter Value
                DeviceMem_READ(ME->Adapter, FireCount, TempNewCounter);
                /* Adapter Fire Counter update check */
                if (pEgia->PrevAdapterFireCounter < TempNewCounter)
                {
                    pEgia->AdapterFireCountUpdated = FIRE_COUNT_UPDATE_SUCCESS;
                }
                else
                {
                    pEgia->AdapterFireCountUpdated = FIRE_COUNT_UPDATE_FAILED;
                    // update and write the Firing Counter Value
                    TempNewCounter = pEgia->PrevAdapterFireCounter;
                    TempNewCounter++;
                    DeviceMem_WRITE(ME->Adapter, FireCount, TempNewCounter);
                 }
            }

            if ((FIRE_COUNT_UPDATE_FAILED == pEgia->AdapterProcCountUpdated)  || (FIRE_COUNT_UPDATE_FAILED == pEgia->HandleFireCountUpdated)
               || (FIRE_COUNT_UPDATE_FAILED == pEgia->AdapterFireCountUpdated))
            {
                //Retry timer is started again
                AO_TimerArm(&ME->RetryFireCountUpdateTimer, FIRE_COUNT_UPDATE_TIME, 0);
            }
            else if ((FIRE_COUNT_UPDATE_SUCCESS == pEgia->AdapterProcCountUpdated) && (FIRE_COUNT_UPDATE_SUCCESS == pEgia->HandleFireCountUpdated)
                 && (FIRE_COUNT_UPDATE_SUCCESS == pEgia->AdapterFireCountUpdated))
            {
                //Disarm the Timer
                AO_TimerDisarm(&ME->RetryFireCountUpdateTimer);
            }
            else
            {
                ;//Do Nothing
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_CARTRIDGE_REMOVED} */
        case P_CARTRIDGE_REMOVED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            Gui_Used_Cartridge_ScreenUnlock();
            EGutil_ProcessDeviceConnEvents(ME,e);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_CARTRIDGE_CONNECTED} */
        case P_CARTRIDGE_CONNECTED_SIG: {
            if ((RETRACTION_INPROGRESS != pEgia->RetractionStatus) && (pEgia->CalibrationStatus != CALIBRATION_FAILED_RELOADCONNECTED))
            {
                HNutil_ProcessDeviceConnEvents(ME,e);
                Gui_Insert_Cartridge_ScreenUnlock();
                EGutil_ProcessDeviceConnEvents(ME,e);
            }
            else
            {
                ;//Do Nothing
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_ARTIC_STOP} */
        case P_ARTIC_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO*)e;

            if (pStopInfo->StopStatus & MOT_STOP_STATUS_CURRENT_ES)
            {
                Signia_PlayTone(SNDMGR_TONE_CAUTION);
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_ADAPTER_ERROR} */
        case P_ADAPTER_ERROR_SIG: {
            uint16_t ErrorCause;
            APP_EGIA_DATA *pEgia;
            QEVENT_FAULT *pAdapterErr;
            uint16_t AdapterFireCount;
            uint8_t ReloadFireCount;


            pAdapterErr = (QEVENT_FAULT *)e;
            AdapterFireCount = 0;
            ReloadFireCount = 0;
            pEgia = EGIA_GetDataPtr();

            ME->Adapter.InErrorstate = true;

            //Adapter error due to zero Strain gauge coefficients
            if ((SG_STATUS_ZERO_ADC_DATA == pAdapterErr->ErrorCause) || (ADAPTER_SGCOEFF_ZERO == pAdapterErr->ErrorCause))
            {
                DeviceMem_READ (ME->Adapter, FireCount, AdapterFireCount);
                DeviceMem_WRITE(ME->Adapter, FireLimit, AdapterFireCount);
            }

            /* Transition if ErrorStatus is set, else remain in operate */
            if (ADAPTER_ONEWIRE_SHORT == pAdapterErr->ErrorCause)
            {
               ME->Adapter.ConnectorBusShort = true;
            }

            /*.${AOs::EGIA::SM::Operate::P_ADAPTER_ERROR::[ErrStatSet]} */
            if ((pAdapterErr->ErrorStatus) && (!ME->Adapter.ConnectorBusShort)) {
                Log(DBG,"***Entering Adapter Error State*****");
                /* perform error handling - Adapter Error Screen, Fault tone */
                Signia_PlayTone(SNDMGR_TONE_FAULT);

                ErrorCause = pAdapterErr->ErrorCause - ADAPTER_ERR_START;
                /* if ErrorStatus is set, populate the error causes */
                if ( pAdapterErr->ErrorStatus )
                {
                    pEgia->AdapterErrCause |= (1<<ErrorCause);
                    /* if Straingauge coefficients zero, Set the ADAPTER FIRING_LIMIT equal to the ADAPTER FIRING_COUNTER */
                    if ((SG_STATUS_ZERO_ADC_DATA == pAdapterErr->ErrorCause) || (ADAPTER_SGCOEFF_ZERO == pAdapterErr->ErrorCause))
                    {
                        DeviceMem_READ (ME->Adapter, FireCount, AdapterFireCount);
                        DeviceMem_WRITE(ME->Adapter, FireLimit, AdapterFireCount);
                    }
                    else
                    {
                        //Do nothing
                    }
                }
                /* Remove the error cause from when clear received */
                else
                {
                    pEgia->AdapterErrCause &= ~(1<<ErrorCause);
                }
                status_ = Q_TRAN(&EGIA_Adapter_Error);
            }
            /*.${AOs::EGIA::SM::Operate::P_ADAPTER_ERROR::[ErrStatClr]} */
            else {
                /// \todo 03/02/2023 NP - Naming for EgiaReload and Reload Structure needs to be modified while doing coding standard changes
                if ((AM_DEVICE_CONNECTED == ME->EgiaReload.Status) || (AM_DEVICE_CONNECTED == ME->Reload.Status))
                {
                    Log(DBG,"***** Connector Bus Short Detected -Reload Connected *****");
                    // Connected MULU and Firing is complete
                    if ((RELOAD_MULUINTELLIGENT == pEgia->ReloadType) && (true == pEgia->FiringComplete))
                    {
                        DeviceMem_READ(ME->Reload, FireCount, ReloadFireCount);
                        Gui_FluidIngressIndicator_Screen(ReloadFireCount, pEgia->CartridgeLen);
                    }
                }
                else
                {
                    Log(DBG,"***** Connector Bus Short Detected -Reload Not Connected *****");
                    Gui_AdapterErrorScreen();
                    Signia_PlayTone(SNDMGR_TONE_FAULT);
                }

                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_SAFETY_PRESS} */
        case P_SAFETY_PRESS_SIG: {
            uint16_t KeyState;
            /* Multi Key State */
            KeyState = ME->KeyState;
            /* Check multi key for SAFETY_LEFT */
            EGUtil_StopRotArtOnMultiKey(SAFETY_LEFT , KeyState);
            /* Check multi key for SAFETY_RIGHT */
            EGUtil_StopRotArtOnMultiKey(SAFETY_RIGHT, KeyState);
            /* When safety key is pressed post succesful/failure of retraction play caution tone */
            if ( (RETRACTION_FAILED == pEgia->RetractionStatus) || (RETRACTION_SUCCESS == pEgia->RetractionStatus) )
            {
                /* Play caution tone */
                Signia_PlayTone(SNDMGR_TONE_CAUTION);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_EGIA_RELOAD_REMOVED} */
        case P_EGIA_RELOAD_REMOVED_SIG: {
            EGutil_ProcessDeviceConnEvents(ME,e);
            /* Stop Reload Switch Timer */
            AO_TimerDisarm(&ME->ReloadSwitchTimer);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_ADAPTER_COM_RETRY_FAIL} */
        case P_ADAPTER_COM_RETRY_FAIL_SIG: {
            QEVENT_ADAPTERCOM *pSignalEvent;

            pSignalEvent = (QEVENT_ADAPTERCOM *)e;

            if(AM_DEVICE_DISCONNECTED != ME->Adapter.Status)
            {
                Log(DBG, "EGIA: Adapter Cmd = %d Retry fail", pSignalEvent->AdapterCmd);
                ME->Adapter.Status= AM_DEVICE_ACCESS_FAIL;
                if(ADAPTER_UPDATE_MAIN == pSignalEvent->AdapterCmd)
                {
                    Gui_AdapterErrorScreen();
                    Signia_PlayTone(SNDMGR_TONE_FAULT);
                }

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_RESTART, ADAPTER_RESTART_DELAY_IN_MS) )
                {
                    Log(DEV, "EGIA: Adapter Restart Request Failed");
                    break;
                }
                Log(DEV, "EGIA: Adapter Restart Request Successful");

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_ENTERBOOT, ADAPTER_COMMAND_RESPONSE_NODELAY) )
                {
                    Log(DEV, "EGIA: Adapter BootEnter Request Failed");
                    break;
                }
                Log(DEV, "EGIA: Adapter BootEnter Request Successful");

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_ENTERMAIN, ADAPTER_ENTERMAIN_DELAY_IN_MS) )
                {
                    Log(DEV, "EGIA: Adapter EnterMain Request Failed");
                    break;
                }
                Log(DEV, "EGIA: Adapter EnterMain Request Successful");

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_ENABLE_ONEWIRE, ADAPTER_COMMAND_RESPONSE_NODELAY) )
                {
                    Log(DEV, "EGIA: Adapter Enable OneWire Request Failed");
                    break;
                }
                Log(DEV, "EGIA: Adapter Enable OneWire Request Successful");

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_ENABLE_SWEVENTS, ADAPTER_COMMAND_RESPONSE_NODELAY) )
                {
                    Log(DEV, "EGIA: Adapter Enable SwitchEvents Request Failed");
                    break;
                }
                Log(DEV, "EGIA: Adapter Enable SwitchEvents Request Successful");

                if( AM_STATUS_OK != Signia_AdapterRequestCmd(ADAPTER_START_SGSTREAM, ADAPTER_COMMAND_RESPONSE_NODELAY) )
                {
                    Log(DEV, "EGIA: Adapter Straingauge Stream Request Failed");
                    break;
                }
                Log(DEV, "EGIA: Adapter Enable Straingauge Stream Request Successful");
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_ADAPTER_COM_RESP_RECEIVED} */
        case P_ADAPTER_COM_RESP_RECEIVED_SIG: {
            QEVENT_ADAPTERCOM *pSignalEvent;

            pSignalEvent = (QEVENT_ADAPTERCOM *)e;

            if(ADAPTER_GET_TYPE == pSignalEvent->AdapterCmd)
            {
                if(!ME->Adapter.Authenticated)
                {
                    ME->Adapter.DevID = (DEVICE_ID_ENUM)Signia_GetUartAdapterType();//use UART adapter type
                }
            }
            if(ADAPTER_GET_FLASHDATA == pSignalEvent->AdapterCmd)
            {
                    ME->Adapter.pHandle->pGetFlashCalibParam((uint8_t*)&Egia.CalibParam); //read flash calibration parameters
                    pEgia->CoefficientsStatus = true;

            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::P_ROTATE_STOP} */
        case P_ROTATE_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO*)e;

            if (pStopInfo->StopStatus & MOT_STOP_STATUS_CURRENT_ES)
            {
                /*ID 318411 */
                Signia_PlayTone(SNDMGR_TONE_CAUTION);
            }
            EGUtil_ProcessRotationRequest(e,ME);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::ROTATION_TIMER_TIMEOUT} */
        case ROTATION_TIMER_TIMEOUT_SIG: {
            EGUtil_ProcessRotationRequest(e,ME);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            /*.${AOs::EGIA::SM::Operate::CATCH_ALL} */
            if (e->sig < Q_USER_SIG) {
                status_ = Q_SUPER(&QHsm_top);
            }
            else {

                // All unprocessed user signals must be referred to the external
                // superstate.

                // Between this and the interception of unused system (QPC) signals, we are effectively
                // rewriting the default case of this state. Instead of referencing
                // our parent bubble (QHsm_top()) , we are referencing the parent bubble (superstate)
                // in an external model.

                // The if statement is to avoid compiler complaints about unreachable code.

                if (me)
                {
                    status_ = Q_SUPER(Handle_Operate);
                    break;
                }
                status_ = Q_HANDLED();
            }
            break;
        }
    }
    return status_;
}

/**
 * \brief   Calibrate
 *
 * \details This state calibrates the Fire Rod by retracting it to the end stop,
 *          then moving forward to the fully open position. If appropriate, the
 *          articulate rod is calibrated by retracting it to its hard stop, then
 *          advancing it to the center position to allow reload loading/unloading.
 *
 * ========================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate} ....................................*/
QState EGIA_Calibrate(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering EGIA Calibration State ****");
            /// \todo 07/06/2021 CPK Screen display functions to be consistant and tie this with timeout whith actual Calibration GUI story

            pEgia->RotateAllowed = false;
            pEgia->ArticAllowed = false;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate} */
        case Q_EXIT_SIG: {
            // inactive timer.
            AO_TimerDisarm(&ME->Timer);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&EGIA_ArticCal_ShortDistal);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::P_EGIA_RELOAD_CONNECTED} */
        case P_EGIA_RELOAD_CONNECTED_SIG: {
            EGutil_ProcessDeviceConnEvents(ME,e);
            /* Start 3 sec timer to identify Reload Type */
            AO_TimerArm(&ME->ReloadSwitchTimer, SEC_3 , 0);
            /* Log Message Reload connected before start of calibration */
            Log(DBG, "Reload connected in Calibrate State");

            /* Reload Connected Stop Articulation Motor */
            Signia_MotorStop(ARTIC_MOTOR);

            /* Stop Fire Motor */
            Signia_MotorStop(FIRE_MOTOR);

            /*Caution Tone*/
            Signia_PlayTone(SNDMGR_TONE_CAUTION);

            /* Request to Removed Reload Screen */
            if (ME->Clamshell.ClamshellEOL)
            {
                Gui_AdapterReload_ScreenSet(true, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
            }
            else
            {
                Gui_AdapterReload_ScreenSet(false, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
            }

            pEgia->RotateAllowed = false;
            pEgia->ArticAllowed = true;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::P_EGIA_RELOAD_REMOVED} */
        case P_EGIA_RELOAD_REMOVED_SIG: {
            /*.${AOs::EGIA::SM::Operate::Calibrate::P_EGIA_RELOAD_RE~::[NoAdapterError]} */
            if (!(ME->Adapter.InErrorstate)) {
                EGutil_ProcessDeviceConnEvents(ME,e);
                /* Stop Reload Switch Timer */
                AO_TimerDisarm(&ME->ReloadSwitchTimer);
                Log(DBG, "Egia.c Reload Removed Signal Received");

                /* Check for Clamshell EOL */
                if (ME->Clamshell.ClamshellEOL)
                {
                    ScreenAdapterProgressCalib(true, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }
                else
                {
                    ScreenAdapterProgressCalib(false, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }

                status_ = Q_TRAN(&EGIA_Calibrate);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::P_EGIA_RELOAD_RE~::[AdapterError]} */
            else {
                Signia_PlayTone(SNDMGR_TONE_FAULT);
                Gui_AdapterErrorScreen();
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::P_RELOAD_CONNECTED, P_RELOAD_REM~} */
        case P_RELOAD_CONNECTED_SIG: /* intentionally fall through */
        case P_RELOAD_REMOVED_SIG: {
            /* Process the Reload connect event */
            HNutil_ProcessDeviceConnEvents(ME,e);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Operate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the Second step in the Artic calibration sequence
 *
 *  \details      This is the second step in the calibration sequence.  It
 *                moves the the articulation rod proximally until an endstop is detected.
 *                This is the calibration- or zero-reference point.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Hardstop} .................*/
QState EGIA_ArticCal_Hardstop(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Hardstop} */
        case Q_ENTRY_SIG: {
            /// \todo 07/02/2021 CPK Actual values after handle cofficiants read implemented

            pEgia->MotorId = ARTIC_MOTOR;
            pEgia->ShaftRpm = ARTIC_CALIB_SHAFT_RPM;
            pEgia->Ticks = ARTIC_HARDSTOP_POS;
            pEgia->Timeout = ARTIC_CAL_HARDSTOP_TIMEOUT;
            pEgia->CurrentLimit = ARTIC_CAL_CURRENTLIMIT;
            pEgia->CurrentTrip = ARTIC_CAL_CURRENTTRIP;
            pEgia->TimeDelay = TIME_DELAY_200;
            pEgia->InitCurrent = true;
            pEgia->MotorVoltage = MOTOR_VOLT_15;
            Log(REQ, "**** Entering EGIA Calibration - Artic - Hardstop State ****");

            /// \todo 08/25/2021 NP -  Home position ticks to be updated
            Signia_MotorSetPos(ARTIC_MOTOR, 0);  // Set start position for hardstop search
            Signia_MotorStart(
                             pEgia->MotorId,
                             pEgia->Ticks,
                             pEgia->ShaftRpm,
                             pEgia->TimeDelay,
                             pEgia->Timeout,
                             pEgia->CurrentTrip,  /// \todo 07/30/2021 DAZ - Mild current trip to start
                             pEgia->CurrentLimit,
                             pEgia->InitCurrent,
                             pEgia->MotorVoltage,
                             REPORT_INTERVAL,
                             NULL
                            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Hardsto~::P_ARTIC_STOP} */
        case P_ARTIC_STOP_SIG: {
             pStopInfo = (QEVENT_MOTOR_STOP_INFO*)e;
            Log(REQ, "**** Entering EGIA Calibration - Artic Hardstate State - Stop event received ****");
            /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Hardsto~::P_ARTIC_STOP::[OK]} */
            if (!(pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS) && ( !( ME->EgiaReload.Status == AM_DEVICE_CONNECTED ) )) {
                /// \todo 08/09/2021 DAZ - Should look for specific status above rather than Not in position.
                Signia_MotorSetPos(pEgia->MotorId, ARTIC_CAL_HARDSTOP_POS);
                status_ = Q_TRAN(&EGIA_ArticCal_Homing);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Hardsto~::P_ARTIC_STOP::[Fail]} */
            else {
                /* Update Calbration Failed due to Reload or not */
                pEgia->CalibrationStatus = (ME->EgiaReload.Status == AM_DEVICE_CONNECTED)?CALIBRATION_FAILED_RELOADCONNECTED:CALIBRATION_FAILED_MOTOR;
                /// \todo 07/02/2021 CPK Error handling to be done based on Stop return status
                Log(REQ, "**** EGIA Cal Artic - Hard Stop fail stop status 0x%04X ****",pStopInfo->StopStatus);

                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the Third step in the Artic calibration sequence
 *
 *  \details      This is the last step in the calibration sequence.  It
 *                moves the the articulation rod distally a measured number of turns to
 *                the reload load position.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Homing} ...................*/
QState EGIA_ArticCal_Homing(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Homing} */
        case Q_ENTRY_SIG: {
            /// \todo 07/02/2021 CPK Actual values after handle cofficiants read implemented

            pEgia->MotorId = ARTIC_MOTOR;
            pEgia->ShaftRpm = ARTIC_CALIB_SHAFT_RPM;
            pEgia->Ticks = ARTIC_HOMING_POS;
            pEgia->Timeout = ARTIC_HOMING_TIMEOUT;
            pEgia->CurrentLimit = ARTIC_HOMING_CURRENTLIMIT;
            pEgia->CurrentTrip = ARTIC_HOMING_CURRENTTRIP;
            pEgia->TimeDelay = TIME_DELAY_200;
            pEgia->InitCurrent = true;
            pEgia->MotorVoltage = MOTOR_VOLT_15;
            Log(REQ, "**** Entering EGIA Calibration -Artic- Homing State ****");

            Signia_MotorStart(
                             pEgia->MotorId,
                             pEgia->Ticks,
                             pEgia->ShaftRpm,
                             pEgia->TimeDelay,
                             pEgia->Timeout,
                             pEgia->CurrentTrip,  /// \todo 07/30/2021 DAZ - Mild current trip to start
                             pEgia->CurrentLimit,
                             pEgia->InitCurrent,
                             pEgia->MotorVoltage,
                             REPORT_INTERVAL,
                             NULL
                            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Homing::P_ARTIC_STOP} */
        case P_ARTIC_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO*)e;
                       if ((pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS) > 0)
                        {                                      /* Yes, signal success*/
                            /* Subtract Backlash Ticks from negative motor movement ticks  *** */
                            pEgia->ArticCalPosition = pStopInfo->Position + pEgia->BacklashTicks;
                            Log(REQ, "**** Entering EGIA Calibration - Homing State Success- Stop event received current pos %d ****",pEgia->ArticCalPosition);
                        }
                        else   /* No, Cal Failed*/
                        {
                            /// \todo 07/02/2021 CPK Error handling to be done based on Stop return status
                            Log(REQ, "**** EGIA Calibration - Artic -Homing-Recvd fail stop status %d ****",pStopInfo->StopStatus);
                        }
            //ScreenAdapterCalibShowProgress(ADAPTER_CALIB_STATE_COMPLETED);
            /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Homing::P_ARTIC_STOP::[OK]} */
            if ((pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS) && ( !( ME->EgiaReload.Status == AM_DEVICE_CONNECTED ) )) {
                status_ = Q_TRAN(&EGIA_FiringCalibration_Hardstop);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_Homing::P_ARTIC_STOP::[Fail]} */
            else {
                /* Update Calbration Failed due to Reload or not */
                pEgia->CalibrationStatus = (ME->EgiaReload.Status == AM_DEVICE_CONNECTED) ? CALIBRATION_FAILED_RELOADCONNECTED : CALIBRATION_FAILED_MOTOR;
                /// \todo 07/02/2021 CPK Error handling to be done based on Stop return status
                Log(REQ, "**** EGIA Cal Artic - Home fail stop status 0x%04X ****",pStopInfo->StopStatus);

                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        EGIA firing calibration Homing
 *
 *  \details      This is the second step in firing rod calibration. Motor 1 is rotated till the homing
 *                position is reached
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibration_Homing} ..........*/
QState EGIA_FiringCalibration_Homing(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibration_Homing} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering EGIA Firing Homing Calibration State ****");


            Signia_MotorStart(
                             FIRE_MOTOR,
                             FIRE_HOMING_POS,
                             FIRE_CALIB_SHAFT_RPM,
                             TIME_DELAY_200,
                             FIRE_HOMING_TIMEOUT,
                             FIRE_HOMING_CURRENTTRIP, /// \todo 07/30/2021 DAZ - Mild current trip to start
                             FIRE_HOMING_CURRENTLIMIT,
                             true,
                             MOTOR_VOLT_15,
                             REPORT_INTERVAL,
                             NULL
                             );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibratio~:: P_FIRE_STOP} */
        case  P_FIRE_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(DBG, "****Motor:%d P_MOTOR_0_STOP_INFO_SIG signal received. Position is %d",
                      pStopInfo->MotorNum, pStopInfo->Position);
            /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibratio~:: P_FIRE_STOP::[OK]} */
            if (EGutil_CalibrationNextStatePreCond(me, e)) {
                /* Get Strain Gauge raw value to set tare at no load*/
                EGutil_SetCalibrationTareLbs(pEgia->SGForce.Current);
                TM_Hook(HOOK_SG_CALIB_SUCCES_SIMULATE, NULL);
                status_ = Q_TRAN(&EGIA_Clamptest);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibratio~:: P_FIRE_STOP::[Fail]} */
            else {
                /* Pre-Condition's to enter1 RELOAD CLAMP TEST failed */
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief    Retract the RELOAD by driving the Firing Shaft proximally until it stops at its mechanical limit
 *
 *  \details  This is the first step in Retracting a Reload Automatically. Motor 1 is rotated till the hardstop
 *            position is reached.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract_ProximalEndStop} ..*/
QState EGIA_AutomaticRetract_ProximalEndStop(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract_ProximalEndStop} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** EGIA Retraction - Automatically retract the RELOAD by driving the Firing Shaft proximally until it stops****");
            AO_TimerArm(&ME->CartridgeCheckTimer, CARTRIDGE_CHECK_TIME, 0);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_FIRE_STOP} */
        case P_FIRE_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(DBG, "**** Motor:%d P_MOTOR_1_STOP_INFO_SIG signal received. Position is %d",
                      pStopInfo->MotorNum, pStopInfo->Position);
            AO_TimerDisarm(&ME->Timer);
            /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_FIRE_STOP::[Ok]} */
            if ((pStopInfo->StopStatus & MOT_STOP_STATUS_CURRENT_ES) > 0) {
                Signia_PlayTone(SNDMGR_TONE_CAUTION);
                Signia_MotorSetPos(MOTOR_ID1, FIRE_CAL_HARDSTOP_POS);
                status_ = Q_TRAN(&EGIA_AutomaticRetract_DistallyHoming);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_FIRE_STOP::[Fail]} */
            else {
                Log(REQ, "**** EGIA Retraction - RELOAD Retraction Failed - Hardstop fail status 0x%04X ****",pStopInfo->StopStatus);
                pEgia->RetractionStatus = RETRACTION_FAILED;
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::TIMEOUT} */
        case TIMEOUT_SIG: {
            Signia_PlayTone(SNDMGR_TONE_EMERGENCY_RETRACT);
            AO_TimerRearm(&ME->Timer, EGIA_TIMEOUT_1_SEC);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::MULU_CARTRIDGE_WAIT_TIMEOUT} */
        case MULU_CARTRIDGE_WAIT_TIMEOUT_SIG: {
            Signia_MotorSetPos(FIRE_MOTOR, 0);  // Set start position for hardstop search
            Signia_MotorStart(  FIRE_MOTOR,
                                FIRE_HARDSTOP_POS,
                                FIRE_SHAFT_RPM+100,
                                TIME_DELAY_200,
                                FIRE_CAL_HARDSTOP_TIMEOUT,
                                FIRE_CAL_CURRENTTRIP, /// \todo 07/30/2021 DAZ - Mild current trip to start
                                FIRE_CAL_CURRENTLIMIT,
                                true,
                                MOTOR_VOLT_15,
                                REPORT_INTERVAL,
                                NULL
                             );

            AO_TimerArm(&ME->Timer, EGIA_TIMEOUT_1_SEC, TIME_DELAY_500);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the first step in the calibration sequence
 *
 *  \details      in this first step the articulation rod is moved distally for a short period of time.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_ShortDistal} ..............*/
QState EGIA_ArticCal_ShortDistal(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_ShortDistal} */
        case Q_ENTRY_SIG: {
            /// \todo 07/02/2021 CPK Actual values after handle cofficiants read implemented

            pEgia->MotorId = ARTIC_MOTOR;
            pEgia->ShaftRpm = ARTIC_SHAFT_RPM;
            pEgia->Ticks = ARTIC_SHORTDISTAL_POS;
            pEgia->Timeout = ARTIC_SHORTDISTAL_TIMEOUT;
            pEgia->CurrentLimit = ARTIC_CAL_CURRENTLIMIT;
            pEgia->CurrentTrip = ARTIC_CAL_CURRENTTRIP;
            pEgia->TimeDelay = TIME_DELAY_30;
            pEgia->InitCurrent = true;
            pEgia->MotorVoltage = MOTOR_VOLT_15;
            Log(REQ, "**** Entering EGIA Calibration - Artic -Shortdistal State ****");
            /* start motor for 200ms */
            Signia_MotorStart(
                             pEgia->MotorId,
                             pEgia->Ticks,
                             pEgia->ShaftRpm,
                             pEgia->TimeDelay,
                             pEgia->Timeout,
                             pEgia->CurrentTrip,  /// \todo 07/30/2021 DAZ - Mild current trip to start
                             pEgia->CurrentLimit,
                             pEgia->InitCurrent,
                             pEgia->MotorVoltage,
                             REPORT_INTERVAL,
                             NULL
                            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_ShortDi~::P_ARTIC_STOP} */
        case P_ARTIC_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(REQ, "**** Entering EGIA Calibration - Shortdistal State - Stop event received ****");
            /// \todo 02/07/2022 CPK Engineers working on EGIA observed MOT_STOP_STATUS_CURRENT_ES in testing. ideally should not hit hard-stop during short-distal.Test and remove if not required.
            /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_ShortDi~::P_ARTIC_STOP::[OK]} */
            if ((pStopInfo->StopStatus & (MOT_STOP_STATUS_CURRENT_ES | MOT_STOP_STATUS_TIMEOUT)) && ( !( ME->EgiaReload.Status == AM_DEVICE_CONNECTED))) {
                status_ = Q_TRAN(&EGIA_ArticCal_Hardstop);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::ArticCal_ShortDi~::P_ARTIC_STOP::[Fail]} */
            else {
                /* Update Calbration Failed due to Reload or not */
                pEgia->CalibrationStatus = (ME->EgiaReload.Status == AM_DEVICE_CONNECTED) ? CALIBRATION_FAILED_RELOADCONNECTED : CALIBRATION_FAILED_MOTOR;
                /// \todo 07/02/2021 CPK Error handling to be done based on Stop return status
                Log(REQ, "**** EGIA Cal Artic - Short Distal fail stop status 0x%04X ****",pStopInfo->StopStatus);

                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        Drive the Firing Shaft distally to its home position
 *
 *  \details      This is the second step during Automatic Retraction. Motor 1 will be rotated till the homing
 *                position is reached
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract_DistallyHoming} ...*/
QState EGIA_AutomaticRetract_DistallyHoming(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract_DistallyHoming} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** EGIA Retraction - Entering Automatic Retraction Homing State ****");
            Signia_MotorStart( FIRE_MOTOR,
                               FIRE_HOMING_POS,
                               FIRE_SHAFT_RPM,
                               TIME_DELAY_200,
                               FIRE_HOMING_TIMEOUT,
                               FIRE_HOMING_CURRENTTRIP, /// \todo 07/30/2021 DAZ - Mild current trip to start
                               FIRE_HOMING_CURRENTLIMIT,
                               true,
                               MOTOR_VOLT_15,
                               REPORT_INTERVAL,
                               NULL
            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_FIRE_STOP} */
        case P_FIRE_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(DBG, "**** Motor:%d Move the Firing Shaft distally to its home position. is %d",
                        pStopInfo->MotorNum, pStopInfo->Position);
            /* Allow articulation after retraction */
            pEgia->ArticAllowed = true;

            /* Allow Rotation after Retraction */
            pEgia->RotateAllowed = true;
            /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_FIRE_STOP::[OK]} */
            if ((pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS) > 0) {
                pEgia->RetractionStatus = RETRACTION_SUCCESS;

                if (AM_DEVICE_CONNECTED != ME->Adapter.Status)
                {
                    /// \todo 04/15/2022 JA -  Update with proper Adapter Error Screen
                    Gui_HandleErrorScreen();
                }
                status_ = Q_TRAN(&EGIA_AutomaticRetract_Completed);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_FIRE_STOP::[Fail]} */
            else {
                Log(REQ, "**** EGIA Retraction - Automatically Retract - Home fail stop status 0x%04X ****",pStopInfo->StopStatus);
                pEgia->RetractionStatus = RETRACTION_FAILED;
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        EGIA firing calibration Hardstop
 *
 *  \details      This is the first step in firing rod calibration. Motor 1 is rotated till the hardstop
 *         position is reached.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibration_Hardstop} ........*/
QState EGIA_FiringCalibration_Hardstop(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibration_Hardstop} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering EGIA Firing hardstop Calibration State ****");

            /// \todo 08/25/2021 NP -  Home position ticks to be updated
            Signia_MotorSetPos(FIRE_MOTOR, 0);  // Set start position for hardstop search
            /// \todo 25/10/2021 CPK need to have a consistant usage of parameters. for Signia_MotorStart, use either pEgia or hardcoded across Egia.c
            /// \todo 25/10/2021 CPK check if the Signia_MotorStart parameters changes based on Reload length etc and update the parameters (Hardcoded vs pEgia)
            Signia_MotorStart(
                             FIRE_MOTOR,
                             FIRE_HARDSTOP_POS,
                             FIRE_CALIB_SHAFT_RPM,
                             TIME_DELAY_200,
                             FIRE_CAL_HARDSTOP_TIMEOUT,
                             FIRE_CAL_CURRENTTRIP, /// \todo 07/30/2021 DAZ - Mild current trip to start
                             FIRE_CAL_CURRENTLIMIT,
                             true,
                             MOTOR_VOLT_15,
                             REPORT_INTERVAL,
                             NULL
                             );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibratio~:: P_FIRE_STOP} */
        case  P_FIRE_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(DBG, "****Motor:%d P_MOTOR_1_STOP_INFO_SIG signal received. Position is %d",
                      pStopInfo->MotorNum, pStopInfo->Position);
            /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibratio~:: P_FIRE_STOP::[OK]} */
            if (!(pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS) && ( !( ME->EgiaReload.Status == AM_DEVICE_CONNECTED ) )) {
                /// \todo 08/09/2021 DAZ - Should look for specific status above rather than Not in position.
                Signia_MotorSetPos(MOTOR_ID1, FIRE_CAL_HARDSTOP_POS);
                status_ = Q_TRAN(&EGIA_FiringCalibration_Homing);
            }
            /*.${AOs::EGIA::SM::Operate::Calibrate::FiringCalibratio~:: P_FIRE_STOP::[Fail]} */
            else {
                /* Update Calbration Failed due to Reload or not */
                pEgia->CalibrationStatus = (ME->EgiaReload.Status == AM_DEVICE_CONNECTED) ? CALIBRATION_FAILED_RELOADCONNECTED : CALIBRATION_FAILED_MOTOR;  /// \todo 07/02/2021 CPK Error handling to be done based on Stop return status
                Log(REQ, "**** EGIA Cal Fire - Hardstop fail stop status 0x%04X ****",pStopInfo->StopStatus);

                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        Firing Shaft distally to its home position
 *
 *  \details      This is the last step during Automatic Retraction.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract_Completed} ........*/
QState EGIA_AutomaticRetract_Completed(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract_Completed} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** EGIA Retraction - Automatic Retraction Completed ****");
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_TOGGLE_UP_PRESS} */
        case P_TOGGLE_UP_PRESS_SIG: {
            uint16_t KeyState;

            do
            {
                KeyState = ME->KeyState;
                BREAK_IF(EGUtil_StopRotArtOnMultiKey(TOGGLE_UP, KeyState));

                Signia_MotorStart(
                                 FIRE_MOTOR,
                                 FIRE_FULL_OPEN_POS,
                                 FIRE_MOTOR_SHAFT_RPM,
                                 TIME_DELAY_200,
                                 FIRE_MOTOR_HOMING_TIMEOUT,
                                 FIRE_MOTOR_CURRTRIP_6000, /// \todo 07/30/2021 DAZ - Mild current trip to start
                                 FIRE_MOTOR_CURRLIMIT,
                                 true,
                                 MOTOR_VOLT_15,
                                 REPORT_INTERVAL,
                                 NULL
                                 );

            } while (false);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_TOGGLE_DOWN_PRESS} */
        case P_TOGGLE_DOWN_PRESS_SIG: {
            uint16_t KeyState;

            do
            {
                KeyState = ME->KeyState;
                BREAK_IF(EGUtil_StopRotArtOnMultiKey(TOGGLE_DOWN, KeyState));

                Signia_MotorStart(
                                 FIRE_MOTOR,
                                 FIRE_FULL_CLOSE_POS,
                                 FIRE_MOTOR_SHAFT_RPM,
                                 TIME_DELAY_200,
                                 FIRE_MOTOR_HARDSTOP_TIMEOUT,
                                 FIRE_MOTOR_CURRTRIP_6000, /// \todo 07/30/2021 DAZ - Mild current trip to start
                                 FIRE_MOTOR_CURRLIMIT,
                                 true,
                                 MOTOR_VOLT_15,
                                 REPORT_INTERVAL,
                                 NULL
                                 );

            } while ( false );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_TOGGLE_UP_RELEASE, P_TOGGLE_DO~} */
        case P_TOGGLE_UP_RELEASE_SIG: /* intentionally fall through */
        case P_TOGGLE_DOWN_RELEASE_SIG: {
            Signia_MotorStop(MOTOR_ID1);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Calibrate::AutomaticRetract~::P_FIRE_STOP} */
        case P_FIRE_STOP_SIG: {
            /*  P_ROTATION_SIGN, P_ARTIC_STOP signals are not  handling and needs caution tone if any current limits
                are reached as per the Requirements (318411 and 318474). We are already handling these in Operate State. */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Calibrate);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Initial transition termination
 *
 * \details This state provides a termination of the initialization task context.
 *          It sets a short timer event and returns to the caller. When the timer
 *          expires, this state runs in the AO's context instead of the initilization
 *          task's context. The timeout then transfers to the rest of the application.
 *          All future events are processed in the AO's context.
 *
 *          This workaround is not required if it is acceptable to execute the
 *          entry code of the top level state in the initialization task's context
 *          on initialization. In this case, the initial transition can go directly
 *          to the first state of the AO.
 *
 * \note    These parameters are common to all states, so they are only shown here.
 *
 * \param   me - Pointer to AO's local data structure. (This includes the AO descriptor)
 * \param   e  - Pointer to event
 *
 * \return  State status (provided by QM)
 *
 * ========================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamptest} ....................................*/
QState EGIA_Clamptest(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamptest} */
        case Q_ENTRY_SIG: {
            /// \todo 08/13/2021 NP Tested with Intelligent reload(Reload Switch Event not handled)
            Log(REQ, "**** Entering EGIA ClampTest ****");

            /// \todo 07/20/2021 NP Keypad Enable routine to be added
            /// \todo 07/20/2021 NP Screen display functions to be consistant and tie this with timeout whith actual clamp test GUI story
            /// \todo 07/29/2021 NP Keypad Signals to be moved to Main Handle

            pEgia->IsCartridgeCompatible = false;
            pEgia->RotateAllowed = true;
            pEgia->ArticAllowed  = false;

            pEgia->NonIntReloadEOL = false;
            pEgia->ExtraTimeForReloadCheck = false;

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_EGIA_RELOAD_REMOVED} */
        case P_EGIA_RELOAD_REMOVED_SIG: {
            /* Process the Reload disconnect event */
            EGutil_ProcessDeviceConnEvents(ME,e);
            /* Check if Screen is locked temporarily and unlock the screen */

            L4_DmCurrentScreenLockUnLock(SCREEN_LOCK_OFF); // S.K. - 10/13/2023 - Temporary fix for the proper screen unlocking, should be done everywhere instead of unlocking particular screens

            //Gui_SuluMuluReload_ScreenUnlock();
            pEgia->ArticAllowed = false;

            /* Check if Screen is locked due to Reload error and Unlock */
            //Gui_ReloadErrorWarning_ScreenUnlock();
            //Gui_Insert_Cartridge_ScreenUnlock();/* Check for Clamshell EOL when */
            /* Check for Clamshell EOL when */
            if (ME->Clamshell.ClamshellEOL)
            {
                Gui_Request_Reload_Screen(true, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
            }
            else
            {
                Gui_Request_Reload_Screen(false, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
            }

            /* Stop Reload Switch Timer */
            AO_TimerDisarm(&ME->ReloadSwitchTimer);
            status_ = Q_TRAN(&EGIA_Clamptest);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_TOGGLE_DOWN_PRESS} */
        case P_TOGGLE_DOWN_PRESS_SIG: {
            /// \todo 07/20/2021 NP Actual values after handle cofficiants read implemented
            /// \todo 08/04/2021 NP - Mild current trip to start

            uint8_t  ClamshellStatusFlags;          /* Clamshell Status Read from Clamshell */
            uint8_t  AdapterEOL;                    /* Adapter EOL Holder */
            uint8_t  MULUReloadEOL;                 /* MULU Reload EOL Hodler */
            uint16_t KeyState;
            /* Read the Handle Usage */
            DeviceMem_READ(ME->Clamshell, StatusFlags, ClamshellStatusFlags);

            /* Read the Adapter EOL */
            DeviceMem_READ(ME->Adapter, FireCount, AdapterEOL);

            /* Read MULU reload EOL */
            DeviceMem_READ(ME->EgiaReload, FireCount, MULUReloadEOL);
            do
            {
                KeyState = ME->KeyState;
                BREAK_IF(EGUtil_StopRotArtOnMultiKey(TOGGLE_DOWN, KeyState));

                if ((ME->Reload.Status == AM_DEVICE_CONNECTED) || (ME->EgiaReload.Status == AM_DEVICE_CONNECTED))
                {
                    Signia_MotorStart(
                                     FIRE_MOTOR,
                                     FIRE_FULL_CLOSE_POS,
                                     FIRE_MOTOR_SHAFT_RPM,
                                     TIME_DELAY_200,
                                     FIRE_MOTOR_HARDSTOP_TIMEOUT,
                                     FIRE_MOTOR_CURRTRIP_6000, /// \todo 07/30/2021 DAZ - Mild current trip to start
                                     FIRE_MOTOR_CURRLIMIT,
                                     true,
                                     MOTOR_VOLT_15,
                                     REPORT_INTERVAL,
                                     NULL
                                     );
                }

            } while ( false );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_TOGGLE_UP_PRESS} */
        case P_TOGGLE_UP_PRESS_SIG: {
            /// \todo 07/20/2021 NP Actual values after handle cofficiants read implemented

            uint16_t KeyState;
            do
            {
                KeyState = ME->KeyState;
                BREAK_IF(EGUtil_StopRotArtOnMultiKey(TOGGLE_UP, KeyState));
                /// \todo 08/04/2021 NP - Mild current trip to start
                if ( (ME->Reload.Status == AM_DEVICE_CONNECTED) || (ME->EgiaReload.Status == AM_DEVICE_CONNECTED) )
                {
                    Signia_MotorStart(
                                     FIRE_MOTOR,
                                     FIRE_FULL_OPEN_POS,
                                     FIRE_MOTOR_SHAFT_RPM,
                                     TIME_DELAY_200,
                                     FIRE_MOTOR_HOMING_TIMEOUT,
                                     FIRE_MOTOR_CURRTRIP_6000, /// \todo 07/30/2021 DAZ - Mild current trip to start
                                     FIRE_MOTOR_CURRLIMIT,
                                     true,
                                     MOTOR_VOLT_15,
                                     REPORT_INTERVAL,
                                     NULL
                                     );
                }

            } while (false);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_TOGGLE_UP_RELEASE} */
        case P_TOGGLE_UP_RELEASE_SIG: {
            Signia_MotorStop(MOTOR_ID1);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_TOGGLE_DOWN_RELEASE} */
        case P_TOGGLE_DOWN_RELEASE_SIG: {
            Signia_MotorStop(MOTOR_ID1);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::SWITCH_STATE_TIMEOUT} */
        case SWITCH_STATE_TIMEOUT_SIG: {
            bool ClampStatus;  //Allowing/Disallowing Clamping after multiple scenario check
            bool BattStatus;
            uint16_t AdapterFiringCounter;
            uint16_t AdapterFiringLimit;
            uint8_t ReloadFireCount;
            ClampStatus = true;

            do
            {
                /* Is Reload Connected */
                if (!(AM_DEVICE_CONNECTED == ME->EgiaReload.Status))
                {
                    break;
                }
                /* Don't allow the Clamping if Connector bus shorted before reload connection */
                if (ME->Adapter.ConnectorBusShort)
                {
                    ClampStatus = false;
                    break;
                }

                /* check for Reload Type */
                EGutil_GetReloadDeviceTypeLength(ME);
                /* Is battery is sufficient */
                BattStatus  = pEgia->SufficientBattery;
                ClampStatus = ClampStatus && BattStatus;
                /* Is Adapter End of Life */
                /* Read Adapter Fire Counter */
                DeviceMem_READ (ME->Adapter, FireCount , AdapterFiringCounter);
                DeviceMem_READ (ME->Adapter, FireLimit , AdapterFiringLimit  );
                ClampStatus = ClampStatus && ( AdapterFiringCounter < AdapterFiringLimit );

                /* Check for Battery Level */
                if (EGIA_BAT_INSUFFICIENT >= pEgia->BatteryLevel)
                {
                    // Insufficient Battery Tone
                    Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
                }

                //Checks for Reload errors and lock the screen if an error
                EGutil_CheckForReloadErrors(ME);
                /* Check Reload EOL */
                EGutil_ProcessReloadEOL(me);
                pEgia->ArticAllowed = true;
                /* Check for MULU Reload */
                if (pEgia->ReloadType == RELOAD_MULUINTELLIGENT)
                {
                    /* if Cartridge is connected and its not compatible - Don't allow Clamptest */
                    if ((ME->Cartridge.Status == AM_DEVICE_CONNECTED) && (!pEgia->IsCartridgeCompatible))
                    {
                        Log(DBG, "Cartridge Connected and Incompatible");
                        ClampStatus = false;
                    }
                    else if ((ME->Cartridge.Status == AM_DEVICE_CONNECTED) && (pEgia->IsCartridgeCompatible))
                    {
                        Log(DBG, "Cartridge Connected and Compatible");
                        ClampStatus = ClampStatus && true;
                    }
                    else if (ME->Cartridge.Status != AM_DEVICE_CONNECTED)
                    {
                        Log(DBG, "Cartridge Not Connected ");
                        ClampStatus = ClampStatus && true;
                    }
                    else
                    {
                        ;// Do Nothing
                    }
                }
            } while ( false );
            /*.${AOs::EGIA::SM::Operate::Clamptest::SWITCH_STATE_TIM~::[OK]} */
            if (ClampStatus) {
                do
                {
                    if (pEgia->ReloadType == RELOAD_NONINTELLIGENT)
                    {
                        NonIntReloadScreenProgress(RELOAD_NON_INT_DEFAULT_CLOSE, NOT_USED,false,false);
                        break;
                    }

                    if(pEgia->ReloadType == RELOAD_SULUINTELLIGENT)
                    {

                        DeviceMem_READ(ME->Reload,FireCount,ReloadFireCount);

                        /* Fresh SULU Reload */
                        if ((RELOAD_SULUINTELLIGENT == pEgia->ReloadType) && (ReloadFireCount == 0))
                        {
                            if (ME->Clamshell.ClamshellEOL)
                            {
                                IntReloadScreenProgress(RELOAD_INT_CONNECT, pEgia->ReloadLen, pEgia->ReloadCartColor,true,false);
                            }
                            else
                            {
                                IntReloadScreenProgress(RELOAD_INT_DEFAULT_CLOSE, pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                            }
                            break;
                        }

                        /* Used SULU Reload */
                        if ((RELOAD_SULUINTELLIGENT == pEgia->ReloadType) && (ReloadFireCount == 1))
                        {
                            if (ME->Clamshell.ClamshellEOL)
                            {
                                Gui_UsedReload_ScreenAndLock(true);
                            }
                            else
                            {
                                Gui_UsedReload_ScreenAndLock(false);
                            }
                            break;
                        }
                    }

                    if((pEgia->ReloadType == RELOAD_MULUINTELLIGENT) && (ME->Cartridge.Status == AM_DEVICE_CONNECTED))
                    {
                        if (ME->Clamshell.ClamshellEOL)
                        {
                            IntReloadScreenProgress(RELOAD_INT_CONNECT, pEgia->ReloadLen, pEgia->ReloadCartColor,true,false);
                        }
                        else
                        {
                            IntReloadScreenProgress(RELOAD_INT_DEFAULT_CLOSE, pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                        }
                        break;
                    }

                    if((pEgia->ReloadType == RELOAD_MULUINTELLIGENT) && (ME->Cartridge.Status != AM_DEVICE_CONNECTED))
                    {
                        if (ME->Clamshell.ClamshellEOL)
                        {
                            IntReloadScreenProgress(RELOAD_INT_CONNECT, pEgia->ReloadLen, NO_CARTRIDGE,true,false);
                        }
                        else
                        {
                            IntReloadScreenProgress(RELOAD_INT_DEFAULT_CLOSE, pEgia->ReloadLen, NO_CARTRIDGE,false,false);
                        }
                        break;
                    }
                } while (false);
                status_ = Q_TRAN(&EGIA_Lazyjaw_Proximal);
            }
            /*.${AOs::EGIA::SM::Operate::Clamptest::SWITCH_STATE_TIM~::[Fail]} */
            else {
                /// \todo 02/10/2023 NP - Add Screen which has Adapter swimlane error with Reload connected
                Signia_PlayTone(SNDMGR_TONE_FAULT);
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_CARTRIDGE_REMOVED} */
        case P_CARTRIDGE_REMOVED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            /*Unlock the screen lock Temporary, if locked*/
            Gui_MULUCartridgeErrorWarning_ScreenUnlock();
            Gui_Used_Cartridge_ScreenUnlock();
            EGutil_ProcessDeviceConnEvents(ME,e);
            pEgia->IsCartridgeCompatible = false;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_CARTRIDGE_CONNECTED} */
        case P_CARTRIDGE_CONNECTED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            Gui_Insert_Cartridge_ScreenUnlock();
            EGutil_UsedCartridgeTest(me);
            EGutil_ProcessDeviceConnEvents(ME,e);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_RELOAD_REMOVED} */
        case P_RELOAD_REMOVED_SIG: {
            QEVENT_ADAPTER_MANAGER *pEvent;
            pEvent = (QEVENT_ADAPTER_MANAGER *)e;
            //Get the Reload Authentication status
            pEgia->ReloadAuthenticated = pEvent->Authentic;
            //Get the Intelligent Reload Device Write test status
            pEgia->ReloadDeviceWriteStatus = false;
            Log(REQ, "**** Reload 1-Wire Removed in ClampTest State ****");
            AO_TimerDisarm(&ME->RetryFireCountUpdateTimer);
            HNutil_ProcessDeviceConnEvents(ME,e);
            /*Unlock screen if locked due to any failure on Reload connection*/
            Gui_MULUErrorWarning_ScreenUnlock();
            Gui_SuluMuluReload_ScreenUnlock();
            Gui_ReloadErrorWarning_ScreenUnlock();
            Gui_Insert_Cartridge_ScreenUnlock();

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_RELOAD_CONNECTED} */
        case P_RELOAD_CONNECTED_SIG: {
            bool TimerRunStatus;
            QEVENT_ADAPTER_MANAGER *pEvent;
            pEvent = (QEVENT_ADAPTER_MANAGER *)e;
            //Get the Reload Authentication status
            pEgia->ReloadAuthenticated = pEvent->Authentic;
            //Get the Intelligent Reload Device Write test status
            pEgia->ReloadDeviceWriteStatus = pEvent->DeviceWriteTest;
            HNutil_ProcessDeviceConnEvents(ME,e);
            EGutil_GetReloadDeviceTypeLength(ME);
            /* MULU Reload FIRE COUNT TEST */
            if ( pEgia->ReloadType == RELOAD_MULUINTELLIGENT && ME->Reload.Status == AM_DEVICE_CONNECTED )
            {
                EGutil_ReloadMULUFireCountTest(me);
            }
            TimerRunStatus = AO_TimerIsRunning(&ME->ReloadSwitchTimer);
            /* OneWire Reload is detected and Reload Switch Timer is Running */
            if ( TimerRunStatus )
            {
                /* Stop the timer */
                AO_TimerDisarm(&ME->ReloadSwitchTimer);
                /* Start Quick Timer to Enter ClampTest upon immediate detection of One Wire Reload */
                AO_TimerArm(&ME->ReloadSwitchTimer, MSEC_2 , 0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::P_EGIA_RELOAD_CONNECTED} */
        case P_EGIA_RELOAD_CONNECTED_SIG: {
            EGutil_ProcessDeviceConnEvents(ME,e);
            /* Start 3 sec timer to identify Reload Type and for entering ClampTest Full Close*/
            AO_TimerArm(&ME->ReloadSwitchTimer, SEC_3 , 0);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Operate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the first step in the Clamp Test Sequence
 *
 *  \details      in this first step the Firing motor is moved distally on close key press till the Clamping ticks are reached.
On Fully Close control transit to full open state
 *
 *
 *  \param   me - extended state variables of the EGIA object ..
 *  \param   e  - event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_Close} ..............*/
QState EGIA_Clamptest_Full_Close(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_Close} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering EGIA Clamp Test -Full Close State ****");
            /// \todo 08/16/2021 NP Reload type and Length to be handled by reading reload info
            /// \todo 08/20/2021 NP - Simulated the Reload type and Len-Remove in final code

            /* Clamp Test Close */
            pEgia->ClampCycle = EGIA_CLAMPCYCLE_CLAMPING_CLOSE;
            EGutil_ReloadRecognitionStatus(me);
            TM_Hook(HOOK_SG_CLAMP_FULLCLOSE_SIMULATE, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_C~::P_MOTOR_1_STOP_INFO} */
        case P_MOTOR_1_STOP_INFO_SIG: {
            /// \todo 07/20/2021 NP Actual Motor Status Bits needs to be added
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(REQ, "**** EGIA Clamping - Clamping stop status 0x%04X  pos %d ****",pStopInfo->StopStatus,pStopInfo->Position);
            /* Fire rod position ranges from 0 to negative #. so below condition checks for less negative position */
            /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_C~::P_MOTOR_1_STOP_I~::[FullyClosed]} */
            if ((!EGutil_IsFPGAReset(e)) && (pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS) && (pStopInfo->Position < FIRE_FULLOPEN_CLOSE)) {
                /* Read Strain Gauge Force, Reload Clamp Test Fully Clamped */
                memcpy(&pEgia->SGForceClampFullClose,  &pEgia->SGForce,  sizeof(SG_FORCE));

                Log(REQ,"SG: ForceInclose: %3.2f lbs, Current: %u Counts",pEgia->SGForce.ForceInLBS,pEgia->SGForce.Current );

                if ((pEgia->SGForceClampFullClose.Status != SG_STATUS_GOOD_DATA) && (!pEgia->SGForceClampFullClose.NewDataFlag))
                {
                    Log(REQ,"Clamp Test FullClose: Strain Gauge Error");
                    /// \todo 2/2/2022 Strain Gauge data is Error. Currently no input what to do.
                }

                pEgia->SGForce.NewDataFlag = false;

                if (pEgia->ReloadType == RELOAD_SULUINTELLIGENT)
                {
                    if (ME->Clamshell.ClamshellEOL)
                    {
                        IntReloadScreenProgress(RELOAD_INT_CONNECT, pEgia->ReloadLen, pEgia->ReloadCartColor,true,false);
                    }
                    else
                    {
                        IntReloadScreenProgress(RELOAD_INT_DEFAULT_OPEN, pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                    }
                }
                else if ((pEgia->ReloadType == RELOAD_MULUINTELLIGENT) && (ME->Cartridge.Status == AM_DEVICE_CONNECTED))
                {
                    // Cartridge is connected and it's good
                    if (ME->Clamshell.ClamshellEOL)
                    {
                        IntReloadScreenProgress(RELOAD_INT_CONNECT, pEgia->ReloadLen, pEgia->ReloadCartColor,true,false);
                    }
                    else
                    {
                        IntReloadScreenProgress(RELOAD_INT_DEFAULT_OPEN, pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                    }
                }
                else if ((pEgia->ReloadType == RELOAD_MULUINTELLIGENT) && (ME->Cartridge.Status != AM_DEVICE_CONNECTED))
                {
                    // Cartridge is not connected
                    if (ME->Clamshell.ClamshellEOL)
                    {
                        IntReloadScreenProgress(RELOAD_INT_CONNECT, pEgia->ReloadLen, NO_CARTRIDGE,true,false);
                    }
                    else
                    {
                        IntReloadScreenProgress(RELOAD_INT_DEFAULT_OPEN, pEgia->ReloadLen, NO_CARTRIDGE,false,false);
                    }
                }
                else
                {
                    NonIntReloadScreenProgress(RELOAD_NON_INT_DEFAULT_OPEN,NOT_USED,false,false);
                }

                Signia_PlayTone(SNDMGR_TONE_CLAMP_CONFIRMATION);
                status_ = Q_TRAN(&EGIA_Clamptest_Full_Open);
            }
            /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_C~::P_MOTOR_1_STOP_I~::[NotFullClamped]} */
            else {
                //If motor ticks not reached the clamp ticks stay there
                /// \todo 08/11/2021 NP Error handling to be done based on Stop return status
                Log(REQ, "**** EGIA Clamptest - Clamptest Not Full Close status 0x%04X ****",pStopInfo->StopStatus);
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Clamptest);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the second step in the Clamp Test Sequence
 *
 *  \details      in this second step the Firing motor is moved proximally on open key press till the Unclamping ticks are reached.
On Fully open control transit to Clamping
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_Open} ...............*/
QState EGIA_Clamptest_Full_Open(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_Open} */
        case Q_ENTRY_SIG: {
            Log(REQ, "Entering EGIA Clamp Test -Full Open State");

            /* Clamp Test Open */
            pEgia->ClampCycle = EGIA_CLAMPCYCLE_CLAMPING_OPEN;
            TM_Hook(HOOK_SG_CLAMP_FULLOPEN_SIMULATE, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_O~::P_MOTOR_1_STOP_INFO} */
        case P_MOTOR_1_STOP_INFO_SIG: {
            /// \todo 07/20/2021 NP Actual Motor Stop Status Bits needs to be added
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(REQ, "**** EGIA Clamping - Clamping stop status 0x%04X  pos %d ****",pStopInfo->StopStatus,pStopInfo->Position);
            /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_O~::P_MOTOR_1_STOP_I~::[OK]} */
            if ((!EGutil_IsFPGAReset(e)) && EGutil_ReloadClampTestNextStatePreCond(me,e)) {
                /* Clamp Test is successful */
                Log(REQ,"Clamp Test is Successful");
                status_ = Q_TRAN(&EGIA_Clamping);
            }
            /*.${AOs::EGIA::SM::Operate::Clamptest::Clamptest_Full_O~::P_MOTOR_1_STOP_I~::[FAIL]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Clamptest);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the second step in the Clamp Test Sequence
 *
 *  \details      in this step the Firing motor is moved distally away from the lazyjaw position to compensate for backlash.
Once the motor movement is complete, transit to full close state
 *
 *
 *  \param   me - extended state variables of the EGIA object ..
 *  \param   e  - event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Distal} ....................*/
QState EGIA_Lazyjaw_Distal(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Distal} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering EGIA Clamp Test -Lazyjaw Distal State ****");

            /* Lazyjaw Distal Movement */
            pEgia->ClampCycle = EGIA_CLAMPCYCLE_CLAMPING_CLOSE;

            // Query fire motor position
            int32_t Position;
            Signia_MotorGetPos(FIRE_MOTOR, &Position);

            // Calculate desired fire motor movement
            int32_t LazyjawDistalTicks = (int32_t)(Position + FIRE_BACKLASH_TICKS);

            // Begin motor movement
            Signia_MotorStart(FIRE_MOTOR,
                LazyjawDistalTicks,
                FIRE_MOTOR_SHAFT_RETRACT_RPM,
                TIME_DELAY_100,
                FIRE_LAZYJAW_TIMEOUT,
                FIRE_CAL_CURRENTTRIP,
                FIRE_CAL_CURRENTLIMIT,
                true,
                MOTOR_VOLT_15,
                REPORT_INTERVAL,
                NULL
                );

            TM_Hook(HOOK_SG_CLAMP_FULLCLOSE_SIMULATE, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Distal::P_MOTOR_1_STOP_INFO} */
        case P_MOTOR_1_STOP_INFO_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(REQ, "**** EGIA Clamping - Lazyjaw distal stop status 0x%04X  pos %d ****",pStopInfo->StopStatus,pStopInfo->Position);
            /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Distal::P_MOTOR_1_STOP_I~::[MotorMovementComplete]} */
            if ((!EGutil_IsFPGAReset(e)) && (pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS)) {
                status_ = Q_TRAN(&EGIA_Clamptest_Full_Close);
            }
            /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Distal::P_MOTOR_1_STOP_I~::[MotorMovementIncomplete]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Clamptest);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the first step in the Clamp Test Sequence
 *
 *  \details      in this first step the Firing motor is moved proximally for 1.5 turns to reach the lazyjaw position. We must also be careful to adjust for backlash depending on the previous movement of this motor.
Once the motor movement is complete, transit to lazyjaw distal state
 *
 *
 *  \param   me - extended state variables of the EGIA object ..
 *  \param   e  - event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Proximal} ..................*/
QState EGIA_Lazyjaw_Proximal(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Proximal} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering EGIA Clamp Test -Lazyjaw Proximal State ****");

            /* Lazyjaw Proximal Movement */
            pEgia->ClampCycle = EGIA_CLAMPCYCLE_LAZYJAW_PROXIMAL;

            // Query last direction of fire motor
            MOTOR_MOVEMENT_DIRECTION LastDirection;
            Signia_MotorGetLastDirection(FIRE_MOTOR, &LastDirection);

            // Calculate desired fire motor position
            int32_t LazyjawProximalTicks = FIRE_HOMING_POS + FIRE_LAZYJAW_TURNS * HANDLE_PARAM_GEAR_RATIO * HANDLE_PARAM_TICKS_PER_REV;

            // Adjust desired movement for backlash compensation
            if(MOTOR_DIRECTION_NEGATIVE == LastDirection)
            {
                LazyjawProximalTicks += FIRE_BACKLASH_TICKS;
            }

            // Begin motor movement
            Signia_MotorStart(FIRE_MOTOR,
                LazyjawProximalTicks,
                FIRE_MOTOR_SHAFT_RPM,
                TIME_DELAY_100,
                FIRE_LAZYJAW_TIMEOUT,
                FIRE_CAL_CURRENTTRIP,
                FIRE_CAL_CURRENTLIMIT,
                true,
                MOTOR_VOLT_15,
                REPORT_INTERVAL,
                NULL
                );

            TM_Hook(HOOK_SG_CLAMP_LAZYJAWPROXIMAL_SIMULATE, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Proximal::P_MOTOR_1_STOP_INFO} */
        case P_MOTOR_1_STOP_INFO_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            Log(REQ, "**** EGIA Clamping - Lazyjaw proximal stop status 0x%04X  pos %d ****",pStopInfo->StopStatus,pStopInfo->Position);
            /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Proximal::P_MOTOR_1_STOP_I~::[MotorMovementComplete]} */
            if (// TODO check for position reached or endstop
                (!EGutil_IsFPGAReset(e)) && ((pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS) || (pStopInfo->StopStatus & MOT_STOP_STATUS_CURRENT_ES)))
            {
                status_ = Q_TRAN(&EGIA_Lazyjaw_Distal);
            }
            /*.${AOs::EGIA::SM::Operate::Clamptest::Lazyjaw_Proximal::P_MOTOR_1_STOP_I~::[MotorMovementIncomplete]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Clamptest);
            break;
        }
    }
    return status_;
}
/*.${AOs::EGIA::SM::Operate::Firing_Retract} ...............................*/
QState EGIA_Firing_Retract(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Firing_Retract} */
        case Q_ENTRY_SIG: {
            uint8_t ReloadFireCount;
            uint8_t ReloadFireLimit;

            // Get the Reload type and Length
            EGutil_GetReloadDeviceTypeLength(ME);

            L4_GpioCtrlClearSignal(GPIO_GN_LED);
            pEgia->BatteryLevel = ME->pChargerInfo->BatteryLevel;
            Log(REQ, "**** Entering Firing Retraction State  ****");
            /// \todo 09/24/2021 CPK - Reraction need to transition to post-fire..currently going back to clamping for testing

            if( (RELOAD_MULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_SULUINTELLIGENT == pEgia->ReloadType) )
            {
                /// \todo 09/24/2021 CPK - during retraction screen showing cartride status to be displayed o oled
                /// \todo 10/02/2022 NP - MULU need correction
                IntReloadScreenProgress(RELOAD_INT_CONNECT, pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
            }
            else if(pEgia->ReloadType == RELOAD_NONINTELLIGENT)
            {
                NonIntReloadScreenProgress(RELOAD_NON_INT_CONNECT,NOT_USED,false,false);
            }

            EGutil_ProcessAdapterEOL(ME);

            /* After firing,SULU - Update firing data amd display Used Reload Screen until reload is removed */
            /*               MULU - Update firing data amd display Used Cartridge Screen until reload is removed */
            if ((RELOAD_SULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_NONINTELLIGENT == pEgia->ReloadType))
            {
                if (RELOAD_SULUINTELLIGENT == pEgia->ReloadType)
                {
                    Log(DBG,"SULU - setting SULU to used and writing firing data");
                }
                if (RELOAD_NONINTELLIGENT == pEgia->ReloadType)
                {
                    Log(DBG,"NON-Intelligent Reload -  showing used reload");
                }
                Gui_UsedReload_ScreenAndLock(false);
                /// \todo 04/12/2022 CPK - update Firing data to the SULU Reload after firing
            }
            else if (RELOAD_MULUINTELLIGENT == pEgia->ReloadType)
            {
                Log(DBG,"MULU - setting cartridge to used and writing firing data");
                /* Display used-cartridge screen */
                DeviceMem_READ(ME->Reload, FireCount, ReloadFireCount);
                DeviceMem_READ(ME->Reload, FireLimit, ReloadFireLimit);
                Gui_Used_Cartridge_ScreenLock(ReloadFireLimit - ReloadFireCount);
                Gui_Used_Cartridge_ScreenLock(CARTRIDGE_USED);
                /// \todo 04/12/2022 CPK - write firing data to Cartridge
            }
            else
            {
                /* Do Nothing */
            }


            // SG Out of Range is Set
            if (pEgia->AsaInfo.SGOutOfRangeSet)
            {
                Log(REQ, "**** SG Out Of Range During Firing ****");
                Signia_PlayTone(SNDMGR_TONE_FAULT);
                // Display Adapter Error Screen
                Gui_AdapterErrorScreen();

                pEgia->AsaInfo.SGOutOfRangeSet = false;
            }
            /* Check Battery Levels */
            if (EGIA_BAT_INSUFFICIENT >= pEgia->BatteryLevel)
            {
                DeviceMem_READ(ME->Reload, FireCount, ReloadFireCount);
                // Insufficeint Battery Tone - Req ID :327555
                Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
                // Screen InSufficeint Battery Screen
                Gui_InsufficientBattery_Screen(ReloadFireCount,  pEgia->ReloadLen);
            }
            else if (EGIA_BAT_LOW >= pEgia->BatteryLevel)
            {
                // Low Battery Tone - Req ID :327557
                Signia_PlayTone(SNDMGR_TONE_LOW_BATTERY);
                // Screen Low Battery Screen
                /// \todo 07/11/2022 NP- Low Battery Screen Fucntion not working need fix
                //Gui_Low_Battery_Screen();
            }
            else
            {
                ;//Do Nothing
            }

            pEgia->RotateAllowed = false;
            pEgia->ArticAllowed = false;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_FIRE_STOP} */
        case P_FIRE_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;

            if (pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS)
            {
                Log(REQ, "**** EGIA Retract - stop status 0x%04X  pos %d **** time %ld",pStopInfo->StopStatus,pStopInfo->Position,OSTimeGet());
            }
            else if (pStopInfo->StopStatus & MOT_STOP_STATUS_CURRENT_ES)
            {
                // EGIA REQ - 318746
                Log(REQ, "**** EGIA Retract - Current Exceeds Limit stop status 0x%04X *****", pStopInfo->StopStatus);

                // Screen Reload connected to adapter
                if( (pEgia->ReloadType == RELOAD_MULUINTELLIGENT) || (pEgia->ReloadType == RELOAD_SULUINTELLIGENT) )
                {
                    IntReloadScreenProgress(RELOAD_INT_START, pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                }
                else
                {
                    NonIntReloadScreenProgress((RELOAD_NON_INT_SCREEN_STATE) pEgia->FiringStateLast,NOT_USED,false,true);
                }

                // Emergency retract tone
                Signia_PlayTone(SNDMGR_TONE_EMERGENCY_RETRACT);
            }

            Log(REQ,"SG: FiringRetractionForce : %3.2f lbs, Current : %u Counts",pEgia->SGForce.ForceInLBS,pEgia->SGForce.Current );
            status_ = Q_TRAN(&EGIA_PostFire);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_OPEN_PRESS} */
        case P_OPEN_PRESS_SIG: {
            /// \todo 08/04/2021 NP - Mild current trip to motor start
            Log(REQ, "**** Entering Retract UP_PRESS  ****");

            //Signia_MotorStop(MOTOR_ID1);Log(REQ, "**** Entering Retract UP_PRESS  ****");
            Signia_MotorStart(
                     FIRE_MOTOR,
                     FIRE_FULL_CLOSE_POS,
                     FIRE_MOTOR_SHAFT_RPM+150,
                     TIME_DELAY_200,
                     FIRE_MOTOR_FIRING_TIMEOUT,
                     FIRE_MOTOR_CURRTRIP_7080,
                     FIRE_RETRACT_CURRLIMIT,
                     true,
                     MOTOR_VOLT_15,
                     REPORT_INTERVAL,
                     NULL
                     );

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_RELOAD_REMOVED} */
        case P_RELOAD_REMOVED_SIG: {
            Log(REQ, "**** Firing Retract-Retry timer stopped ****");
            AO_TimerDisarm(&ME->RetryFireCountUpdateTimer);
            HNutil_ProcessDeviceConnEvents(ME,e);

            /*Unlock screen if locked due to any failure on Reload connection*/
            Gui_MULUErrorWarning_ScreenUnlock();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_RELOAD_CONNECTED} */
        case P_RELOAD_CONNECTED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            /* MULU Reload FIRE COUNT TEST */
            if ( pEgia->ReloadType == RELOAD_MULUINTELLIGENT && ME->Reload.Status == AM_DEVICE_CONNECTED )
            {
                EGutil_ReloadMULUFireCountTest(me);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_EGIA_RELOAD_REMOVED} */
        case P_EGIA_RELOAD_REMOVED_SIG: {
            EGutil_ProcessDeviceConnEvents(ME,e);
            Log(REQ, "**** Reload Removed in Firing Retract State ****");
            Log(REQ, "**** Retry timer stopped ****");

            AO_TimerDisarm(&ME->RetryFireCountUpdateTimer);

            /*Check if Screen is locked temporarily and unlock the screen */
            Gui_SuluMuluReload_ScreenUnlock();

            if( (pEgia->ReloadType == RELOAD_MULUINTELLIGENT) || (pEgia->ReloadType == RELOAD_SULUINTELLIGENT) )
            {
                IntReloadScreenProgress(RELOAD_INT_DISCONNECT_STATE,pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
            }
            else
            {
                NonIntReloadScreenProgress(RELOAD_NON_INT_DISCONNECT_STATE,NOT_USED,false,false);
            }

            pEgia->ArticAllowed = false;

            //Move B1 shaft to Homing Position
            Signia_MotorStart( FIRE_MOTOR,
                           FIRE_HOMING_POS,
                           FIRE_SHAFT_RPM,
                           TIME_DELAY_200,
                           FIRE_HOMING_TIMEOUT,
                           FIRE_HOMING_CURRENTTRIP, /// \todo 07/30/2021 DAZ - Mild current trip to start
                           FIRE_HOMING_CURRENTLIMIT,
                           true,
                           MOTOR_VOLT_15,
                           REPORT_INTERVAL,
                           NULL
            );

            status_ = Q_TRAN(&EGIA_Clamptest);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_OPEN_RELEASE} */
        case P_OPEN_RELEASE_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_BATT_COMM} */
        case P_BATT_COMM_SIG: {
            AO_Defer(&ME->super,&ME->DeferQueue,e);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_ADAPTER_CONNECTED, P_ADAPTER_R~} */
        case P_ADAPTER_CONNECTED_SIG: /* intentionally fall through */
        case P_ADAPTER_REMOVED_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing_Retract::P_BATTERY_LOW,P_BATTERY_LEVEL_IN~} */
        case P_BATTERY_LOW_SIG: /* intentionally fall through */
        case P_BATTERY_LEVEL_INSUFF_SIG: /* intentionally fall through */
        case P_CLAMSHELL_REMOVED_SIG: /* intentionally fall through */
        case P_CLAMSHELL_CONNECTED_SIG: /* intentionally fall through */
        case P_CARTRIDGE_CONNECTED_SIG: /* intentionally fall through */
        case P_BATT_TEMP_SIG: /* intentionally fall through */
        case P_REQ_RST_SIG: {
            AO_Defer(&ME->super,&ME->DeferQueue,e);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Operate);
            break;
        }
    }
    return status_;
}
/*.${AOs::EGIA::SM::Operate::Firing} .......................................*/
QState EGIA_Firing(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Firing} */
        case Q_ENTRY_SIG: {
            int32_t Position;
            uint32_t turns;
            uint8_t Index;
            Log(REQ, "**** Entering Firing State  ****");

            /// \todo 2022-05-13 David Zeichner: These should not be subscribed to here. They were subscribed in Handle and must never be unsubscribed.
            /// \todo 2023-03-02 BS: There is another signal with Battery Low need to analyze further before removing
            AO_Subscribe(AO_Handle, P_BATTERY_LOW_SIG);

            pEgia->ArticAllowed = false; // EGIA SRS ID 183120
            pEgia->RotateAllowed = false;

            pEgia->FiringInfo.FiringSpeedState = FIRINGSPEED_LAST;
            /* Update Firing Speed from SULU RELOAD/ MULU Cartridge else default */
            EGutil_AsaUpdateForceToSpeedTable(ME);

            /* Initialize Bottom Key Info */
            pEgia->FiringInfo.Key          = KEY_COUNT;
            pEgia->FiringInfo.SameKeyCount = 0;

            // Get the Motor Position
            Signia_MotorGetPos(FIRE_MOTOR, &Position);
            pEgia->AsaInfo.TotalTicks = abs(FIRE_FULL_FIRE_POS) - abs(Position);
            pEgia->AsaInfo.StartTicks = abs(Position);
            Log(REQ,"SG: FiringForce : %3.2f lbs, Current : %u Counts",pEgia->SGForce.ForceInLBS,pEgia->SGForce.Current );


            EGutil_GetCurrentLimitProfile(ME,&pEgia->ITripProfile);
            Position -= FIRE_FULL_CLOSE_POS + FIRE_BACKLASH_TICKS;
            turns = (int32_t)((labs(Position))/(TICKS_PER_TURN));

            for(Index = 0; Index < pEgia->ITripProfile.NumEntries; Index++)
            {
                pEgia->ITripProfile.TurnsPosition[Index] += turns;
            }
            if(RELOAD_NONINTELLIGENT != pEgia->ReloadType)
            {
                // Set Interlock Position from Reload
                if (ME->Reload.pHandle->Data.InterlockZone)
                {
                  pEgia->ITripProfile.TurnsPosition[0] =  ME->Reload.pHandle->Data.InterlockZone;
                }
                // Set Cardinal Start Position from Reload
                if (ME->Reload.pHandle->Data.EndstopZone )
                {
                  pEgia->ITripProfile.TurnsPosition[(pEgia->ITripProfile.NumEntries - 1)] = ME->Reload.pHandle->Data.EndstopZone;
                }
            }
            // Calculate the maximum fire Motor Ticks to be moved.
            pEgia->Ticks = (EGutil_GetMaxFireTurns(ME)) + Position + (int32_t)FIRE_BACKLASH_TICKS;


            ///\todo 2/21/23 BS: should we include fire retries?
            /*
            if (pData->fire_retrys > 0)               // If Current Limit previously detected
            {                                         // Yes,
              time_delay = EGIA_TIMEOUT_50MSECS;      // Reduce timeout
              fire_speed = egiaData.fireSpeeds[EGIA_FIRELOW_INDX]; // Set Speed to lowest
              current_limit = EGIA_ADC_RETRY;         // Set a fixed Current Limit
              curlimit_profile = NULL;                // Remove Current Limit Profile
            }
            */


            TM_Hook(HOOK_SG_FIRING_SIMULATE, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing} */
        case Q_EXIT_SIG: {
            AO_TimerDisarm(&ME->Timer);

            /* Clear Bottom Key Press Info */
            pEgia->FiringInfo.Key          = KEY_COUNT;
            pEgia->FiringInfo.SameKeyCount = 0;

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::TIMEOUT} */
        case TIMEOUT_SIG: {
            static uint16_t toggle;
            int32_t  Position;

            AO_Unsubscribe(AO_Handle, P_SAFETY_RELEASE_SIG);
            L4_GpioCtrlToggleSignal ( GPIO_GN_LED );
            toggle++;

            // Read the motor position on every 5Sec (timeout is 500 mSec)
            if ( (toggle % MOTOR_POS_GET_TIME) == 0)
            {
                Signia_MotorGetPos(FIRE_MOTOR, &Position);
                Log(REQ, "**** Firing Pos %d  ****",Position);
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_OPEN_PRESS} */
        case P_OPEN_PRESS_SIG: {
            MM_STATUS Status;
            AO_TimerDisarm(&ME->Timer);
            Log(REQ, "**** Firing-Open Press After Fire Key Press ****");

            Status = Signia_MotorStart(
                             FIRE_MOTOR,
                             FIRE_RETRACT_POS,
                             FIRE_MOTOR_SHAFT_RETRACT_RPM,
                             TIME_DELAY_200,
                             FIRE_MOTOR_HARDSTOP_TIMEOUT,
                             FIRE_MOTOR_CURRTRIP_7080, /// ID 318721/// \todo 07/30/2021 DAZ - Mild current trip to start
                             FIRE_MOTOR_CURRLIMIT,
                             true,
                             MOTOR_VOLT_15,
                             REPORT_INTERVAL,
                             NULL
                             );
            TM_Hook(HOOK_RETRACT_MTR_CRNT_SIMULATE, NULL);
            TM_Hook(HOOK_SG_FIRING_RETRACTION_SIMULATE, NULL);
            /*.${AOs::EGIA::SM::Operate::Firing::P_OPEN_PRESS::[OkToRetract]} */
            if (MM_STATUS_OK == Status) {
                // Motor was stopped when the open key was pressed.

                // NOTE: This function will return error if there
                //       is no move to be made - that is, the motor
                //       is already at the fully retracted/fully
                //       clamped position. (Note that they are the
                //       same position.)
                /* Req-ID 327462 */
                /// \todo 04/05/2022 NP - Motor Moved and not reached Fire Position...
                /// \todo 04/05/2022 NP - Needs to handled for UP-Key press before updating MULU Fire Count updateSignia_MotorGetPos(FIRE_MOTOR, &Position);
                AO_TimerDisarm(&ME->FiringTimer);

                /* Increment Fire Counter on Open Key Press Req ID: EGIA - 318757 */
                EGutil_FireModeHandling(ME);

                EGutil_FireModeOpenPress(ME);
                status_ = Q_TRAN(&EGIA_Firing_Retract);
            }
            /*.${AOs::EGIA::SM::Operate::Firing::P_OPEN_PRESS::[else]} */
            else {
                // Motor was running when the open  key was pressed.
                // This is an indication of a stuck close key. In this
                // case, stop the motor and wait for the open key to be
                Signia_MotorStop(FIRE_MOTOR);
                L4_GpioCtrlClearSignal(GPIO_GN_LED);

                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_OPEN_RELEASE} */
        case P_OPEN_RELEASE_SIG: {
            Log(REQ, "**** Entering Firing Open Release  ****");
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_FIRE_PRESS} */
        case P_FIRE_PRESS_SIG: {
            uint16_t FiringSpeedRPM;
            MM_STATUS MotorStatus;


            /* Set the  Down Keypress handling flag */
            /// \todo 02/08/2022 - NP Keypress handling is taken in separate story-add key levels to key signals
            #ifdef DOWN_KEYPRESS
            pEgia->DownKeypress = true;
            #endif

            int32_t Position;

            do
            {
                if (pEgia->ExcessiveLoad)
                {
                    /* Play Caution Tone */
                    Log(REQ, "**** Excessive Load, Press Fire Open Key ****");
                    Signia_PlayTone(SNDMGR_TONE_CAUTION);
                    break;
                }

                Signia_MotorGetPos(FIRE_MOTOR, &Position);
                if ((pEgia->Ticks) >= (Position))
                {
                    // Get the Motor Position -Req ID - 327486
                    Log(REQ, "**** Fire End Stop Reached Already %ld ****",Position);
                    Signia_PlayTone(SNDMGR_TONE_EXIT_FIRE_MODE);
                    break;
                }
                /* get the motor state running/stopped */
                Signia_MotorIsStopped(MOTOR_ID1, &pEgia->MotorStopped);
                if ((pEgia->MotorStopped == false) || (pEgia->UpKeypress))
                {
                    Log(REQ, "**** Down keypress while Up Key Pressed  ****");
                    Signia_MotorStop(MOTOR_ID1);
                    break;
                }
                Log(REQ, "**** Firing start %ld",OSTimeGet());
                FiringSpeedRPM = EGutil_GetFireSpeedFromClampForce(ME);

                if ( FiringSpeedRPM != 0 )
                {
                    // Start the Timer to show Firing Progression Update on screen (300ms)
                    AO_TimerArm(&ME->FiringTimer, FIRING_SCREEN_UPDATE_TIME, FIRING_SCREEN_UPDATE_TIME);
                    // Register call back handler to update ASA during each Motor Tick
                    Signia_MotorSetExternalProcess(FIRE_MOTOR, EGutil_ASAUpdateCallBack);

                    pEgia->NonIntReloadEOL = true;
                    pEgia->MotorId = FIRE_MOTOR;
                    pEgia->ShaftRpm = FiringSpeedRPM;
                    pEgia->Timeout = FIRE_MOTOR_HARDSTOP_TIMEOUT;
                    pEgia->CurrentLimit = FIRE_MOTOR_CURRLIMIT;
                    pEgia->CurrentTrip = FIRE_MOTOR_CURRTRIP_6000;
                    pEgia->TimeDelay = TIME_DELAY_200;
                    pEgia->InitCurrent = true;
                    pEgia->MotorVoltage = MOTOR_VOLT_15;


                    /// \todo 09/27/2021 CPK - Mild current trip to start
                    MotorStatus=  Signia_MotorStart(
                                                    pEgia->MotorId,
                                                    pEgia->Ticks,
                                                    pEgia->ShaftRpm,
                                                    pEgia->TimeDelay,
                                                    pEgia->Timeout,
                                                    pEgia->CurrentTrip,
                                                    pEgia->CurrentLimit,
                                                    true,
                                                    pEgia->MotorVoltage,
                                                    REPORT_INTERVAL,
                                                    &pEgia->ITripProfile
                                                   );

                    pEgia->FiringInfo.FiringInProgress = (MotorStatus == MM_STATUS_OK)?true:false;
                }
                TM_Hook(HOOK_PERM_FAIL_WOP_SIMULATE, NULL);
            }while (false);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_FIRE_RELEASE} */
        case P_FIRE_RELEASE_SIG: {
            Signia_MotorStop(MOTOR_ID1);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_FIRE_STOP} */
        case P_FIRE_STOP_SIG: {
            static int32_t Position;
            static uint32_t PrevPosition;
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            AO_TimerDisarm(&ME->FiringTimer);
            AO_TimerDisarm(&ME->Timer);
            Log(REQ, "**** EGIA Firing - stop status 0x%04X  pos %d ****",pStopInfo->StopStatus,pStopInfo->Position);

            pEgia->FiringInfo.FiringInProgress = false;

            /* Firing is Complete - Req ID - 327473 and 327486 */
            if (pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS)
            {
                Log(REQ, "**** EGIA Firing - End stop Reached **** time %ld",OSTimeGet());
                Signia_PlayTone(SNDMGR_TONE_EXIT_FIRE_MODE);

                if( (RELOAD_MULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_SULUINTELLIGENT == pEgia->ReloadType) )
                {
                    //IntReloadScreenProgress(pEgia->FiringStateLast,MAX_PERCENT,false,true,true);
                }
                else
                {
                    NonIntReloadScreenProgress((RELOAD_NON_INT_SCREEN_STATE) pEgia->FiringStateLast,MAX_PERCENT,false,true);
                }
            }
            else if (pStopInfo->StopStatus & MOT_STOP_STATUS_STRAINGAGE)
            {
                Log(REQ, "**** Excessive Load - Motor Stopped ****");

                /* Update the Screen with Max Force Dial */
                FiringProgress(pEgia, FIRINGSPEED_SLOW);

                /* Play Caution Tone */
                Signia_PlayTone(SNDMGR_TONE_CAUTION);

                //handle the excessive load Req ID:327608
                /* Get the motor Position */
                Signia_MotorGetPos(FIRE_MOTOR, &Position);

                /* Allow firing if moving forward direction */
                /* Distal Movement of Fire rod is always negative number, so abs() function is used */
                if ((abs(Position) - MOT_POSITION_TOLERANCE) > PrevPosition)
                {
                    PrevPosition = abs(Position);
                    pEgia->ExcessiveLoad = false;
                }
                else
                {
                    pEgia->ExcessiveLoad = true;
                    Log(REQ, "**** Excessive Load, No Forward Movement, Stopping Fire Mode Entry ****");
                }
            }
            else if (pStopInfo->StopStatus & MOT_STOP_STATUS_FPGA_SPI)
            {
                pEgia->FPGAResetFireMode = true;
            }
            else
            {
                ;//Do Nothing
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_LATERAL_LEFT_DOWN_PRESS} */
        case P_LATERAL_LEFT_DOWN_PRESS_SIG: {
            KEY_ID Key;
            bool Status;

            Key = LATERAL_LEFT_DOWN;

            Status = EGutil_GetBottomKeyPressedTwiceInHalfSecond(me, Key);

            /*  Bottom Key clicked twice in 500ms */
            if ( Status )
            {
                EGutil_UpdateSpeedBasedOnKeyPress();
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_LATERAL_RIGHT_DOWN_PRESS} */
        case P_LATERAL_RIGHT_DOWN_PRESS_SIG: {
            KEY_ID Key;
            bool Status;

            Key = LATERAL_RIGHT_DOWN;

            Status = EGutil_GetBottomKeyPressedTwiceInHalfSecond(me, Key);

            /*  Bottom Key clicked twice in 500ms */
            if ( Status )
            {
                EGutil_UpdateSpeedBasedOnKeyPress();
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_BATTERY_LOW,P_BATTERY_LEVEL_IN~} */
        case P_BATTERY_LOW_SIG: /* intentionally fall through */
        case P_BATTERY_LEVEL_INSUFF_SIG: /* intentionally fall through */
        case P_BATT_COMM_SIG: /* intentionally fall through */
        case P_CLAMSHELL_REMOVED_SIG: /* intentionally fall through */
        case P_RELOAD_REMOVED_SIG: /* intentionally fall through */
        case P_CLAMSHELL_CONNECTED_SIG: /* intentionally fall through */
        case P_CARTRIDGE_CONNECTED_SIG: /* intentionally fall through */
        case P_BATT_TEMP_SIG: /* intentionally fall through */
        case P_RELOAD_CONNECTED_SIG: /* intentionally fall through */
        case P_REQ_RST_SIG: {
            AO_Defer(&ME->super,&ME->DeferQueue,e);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::FIREMODE_TIMEOUT} */
        case FIREMODE_TIMEOUT_SIG: {
            SG_FORCE       SGData;
            SG_STATUS      SgStatus;
            static uint8_t Count;
            static uint8_t PercentFlag;
            static uint8_t PrevPercentFlag = 0xFF;
            static uint16_t State;
            static uint8_t PrevState = 0xFF;

            State = pEgia->AsaInfo.FiringState;

            // Force Dial Update as per Motor Ticks movememnt
            if( (RELOAD_MULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_SULUINTELLIGENT == pEgia->ReloadType) )
            {
                FiringProgress(pEgia, pEgia->AsaInfo.FiringState);
            }
            else
            {
                if (PERCENT_VALUE_RANGE1 >= pEgia->AsaInfo.FiringPercentageComplete)
                {
                    PercentFlag = PERCENT_VALUE_ZONE1;
                }
                else if (PERCENT_VALUE_RANGE2 >= pEgia->AsaInfo.FiringPercentageComplete)
                {
                    PercentFlag = PERCENT_VALUE_ZONE2;
                }
                else
                {
                    PercentFlag = PERCENT_VALUE_ZONE3;
                }

                if ((PercentFlag != PrevPercentFlag) || (State != PrevState))
                {
                    PrevState = State;
                    PrevPercentFlag = PercentFlag;
                    NonIntReloadScreenProgress((RELOAD_NON_INT_SCREEN_STATE) (State+SCREEN_INDEX),PercentFlag,false,true);
                }
            }

            /* Check SG data is not updating for 3 times continuously */
            SgStatus = ME->Adapter.pHandle->pGetStrainGaugeData(&SGData);
            if (SgStatus & SG_STATUS_STALE_DATA)
            {
                Count++;
                if (Count > MAX_RETRY)
                {
                    pEgia->AsaInfo.SGLost = true;
                    Log(DBG,"SG data lost during Firing");
                }
            }
            else
            {
                Count = 0;
            }
            pEgia->FiringStateLast = State+SCREEN_INDEX;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Firing::P_ADAPTER_CONNECTED, P_ADAPTER_R~} */
        case P_ADAPTER_CONNECTED_SIG: /* intentionally fall through */
        case P_ADAPTER_REMOVED_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Operate);
            break;
        }
    }
    return status_;
}
/*.${AOs::EGIA::SM::Operate::PostFire} .....................................*/
QState EGIA_PostFire(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::PostFire} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering Post-Fire State  ****");
            pEgia->RotateAllowed = true;
            pEgia->ArticAllowed  = true;
            TM_Hook(HOOK_SG_POST_FIRE_SIMULATE, NULL);
            Log(REQ,"SG: PostFireForce : %3.2f lbs, Current : %u Counts",pEgia->SGForce.ForceInLBS,pEgia->SGForce.Current );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::PostFire::P_OPEN_PRESS} */
        case P_OPEN_PRESS_SIG: {
            Log(REQ, "**** Entering PostFire UP_PRESS  ****");
            //Move B1 shaft to Homing Position
            Signia_MotorStart( FIRE_MOTOR,
                           FIRE_FULL_OPEN_POS,
                           FIRE_SHAFT_RPM,
                           TIME_DELAY_200,
                           FIRE_HOMING_TIMEOUT,
                           FIRE_HOMING_CURRENTTRIP, /// \todo 07/30/2021 DAZ - Mild current trip to start
                           FIRE_HOMING_CURRENTLIMIT,
                           true,
                           MOTOR_VOLT_15,
                           REPORT_INTERVAL,
                           NULL
            );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::PostFire::P_FIRE_STOP} */
        case P_FIRE_STOP_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            /*.${AOs::EGIA::SM::Operate::PostFire::P_FIRE_STOP::[PostFire-Open]} */
            if ((pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS)) {
                /* Republish deferred signals */
                EGutil_RepublishDeferredSig(ME);  /// \todo 05052022 KA: still needed after merge 1431_1502_1596 ?
                status_ = Q_TRAN(&EGIA_Clamping);
            }
            /*.${AOs::EGIA::SM::Operate::PostFire::P_FIRE_STOP::[Else]} */
            else {
                // Wait for full open before going back to clamp.
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::PostFire::P_EGIA_RELOAD_REMOVED} */
        case P_EGIA_RELOAD_REMOVED_SIG: {
            EGutil_ProcessDeviceConnEvents(ME,e);
            Log(REQ, "**** Reload Removed in Post Fire State ****");
            Log(REQ, "**** Retry timer stopped ****");
            AO_TimerDisarm(&ME->RetryFireCountUpdateTimer);

            /*Check if Screen is locked temporarily and unlock the screen */
            Gui_SuluMuluReload_ScreenUnlock();

            if( (pEgia->ReloadType == RELOAD_MULUINTELLIGENT) || (pEgia->ReloadType == RELOAD_SULUINTELLIGENT) )
            {
                IntReloadScreenProgress(RELOAD_INT_DISCONNECT_STATE,pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
            }
            else
            {
                NonIntReloadScreenProgress(RELOAD_NON_INT_DISCONNECT_STATE,NOT_USED,false,false);
            }

            pEgia->ArticAllowed = false;

            //Move B1 shaft to Homing Position
            Signia_MotorStart( FIRE_MOTOR,
                           FIRE_HOMING_POS,
                           FIRE_SHAFT_RPM,
                           TIME_DELAY_200,
                           FIRE_HOMING_TIMEOUT,
                           FIRE_HOMING_CURRENTTRIP, /// \todo 07/30/2021 DAZ - Mild current trip to start
                           FIRE_HOMING_CURRENTLIMIT,
                           true,
                           MOTOR_VOLT_15,
                           REPORT_INTERVAL,
                           NULL
            );

            status_ = Q_TRAN(&EGIA_Clamptest);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::PostFire::P_RELOAD_CONNECTED} */
        case P_RELOAD_CONNECTED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            /* MULU Reload FIRE COUNT TEST */
            if ( pEgia->ReloadType == RELOAD_MULUINTELLIGENT && ME->Reload.Status == AM_DEVICE_CONNECTED )
            {
                EGutil_ReloadMULUFireCountTest(me);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::PostFire::P_RELOAD_REMOVED} */
        case P_RELOAD_REMOVED_SIG: {
            Log(REQ, "**** Post-Fire-Retry timer stopped ****");
            AO_TimerDisarm(&ME->RetryFireCountUpdateTimer);
            HNutil_ProcessDeviceConnEvents(ME,e);
            /*Unlock screen if locked due to any failure on Reload connection*/
            Gui_MULUErrorWarning_ScreenUnlock();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::PostFire::P_OPEN_RELEASE} */
        case P_OPEN_RELEASE_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Operate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the Clamping Procedure
 *
 *  \details      in procedure is executed when Reload is fully open
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamping} .....................................*/
QState EGIA_Clamping(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamping} */
        case Q_ENTRY_SIG: {
            pEgia->ClampCycle = EGIA_CLAMPCYCLE_CLAMPTEST_DONE;

            // Clear the Maximum Clamping Force
            pEgia->MaxClampForce = 0;
            pEgia->ManualFireModeExit = false;

            /// \todo 08/16/2021 NP Reload type and Length to be handled by reading reload info

            if( (pEgia->ReloadType == RELOAD_MULUINTELLIGENT) || (pEgia->ReloadType == RELOAD_SULUINTELLIGENT) )
            {
                if(ME->Clamshell.ClamshellEOL)
                {
                    IntReloadScreenProgress(RELOAD_INT_CONNECT,pEgia->ReloadLen, pEgia->ReloadCartColor,true,false);
                }
                else
                {
                    IntReloadScreenProgress(RELOAD_INT_CONNECT,pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                }
            }
            else
            {
                if(ME->Clamshell.ClamshellEOL)
                {
                    NonIntReloadScreenProgress(RELOAD_NON_INT_CONNECT,NOT_USED,true,false);
                }
                else
                {
                    NonIntReloadScreenProgress(RELOAD_NON_INT_CONNECT,NOT_USED,false,false);
                }
            }

            pEgia->RotateAllowed = true;
            pEgia->ArticAllowed  = true;

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&EGIA_PreFire);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::P_CARTRIDGE_REMOVED} */
        case P_CARTRIDGE_REMOVED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            /*Unlock the screen Temporary, if locked */
            Gui_MULUCartridgeErrorWarning_ScreenUnlock();

            Gui_Used_Cartridge_ScreenUnlock();
            EGutil_ProcessDeviceConnEvents(ME,e);

            /* Reload Connected is of MULU Type and Reload is communicating on OneWire */
            if ( (pEgia->ReloadType == RELOAD_MULUINTELLIGENT && ME->Reload.Status == AM_DEVICE_CONNECTED) )
            {
                Log(DBG,"Clamping-PreFire: Insert Cartridge");
                Gui_Insert_Cartridge_Screen();
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::P_CARTRIDGE_CONNECTED} */
        case P_CARTRIDGE_CONNECTED_SIG: {
            pEgia->IsCartridgeCompatible = false;
            HNutil_ProcessDeviceConnEvents(ME,e);
            /* Unlock, if screen got locked due to Insert Cartridge*/
            Gui_Insert_Cartridge_ScreenUnlock();
            EGutil_ProcessDeviceConnEvents(ME,e);
            EGutil_UsedCartridgeTest(me);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::P_RELOAD_REMOVED} */
        case P_RELOAD_REMOVED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            /*Unlock screen if locked due to any failure on Reload connection*/
            Gui_MULUErrorWarning_ScreenUnlock();
            AO_TimerDisarm(&ME->RetryFireCountUpdateTimer);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::P_RELOAD_CONNECTED} */
        case P_RELOAD_CONNECTED_SIG: {
            HNutil_ProcessDeviceConnEvents(ME,e);
            /* MULU Reload FIRE COUNT TEST */
            if ( pEgia->ReloadType == RELOAD_MULUINTELLIGENT && ME->Reload.Status == AM_DEVICE_CONNECTED )
            {
                EGutil_ReloadMULUFireCountTest(me);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::P_EGIA_RELOAD_REMOVED} */
        case P_EGIA_RELOAD_REMOVED_SIG: {
            /*Check if Screen is locked temporarily and unlock the screen */

            Gui_SuluMuluReload_ScreenUnlock();
            Gui_Used_Cartridge_ScreenUnlock();
            Gui_Insert_Cartridge_ScreenUnlock();

            if ( (pEgia->ReloadType == RELOAD_MULUINTELLIGENT) || (pEgia->ReloadType == RELOAD_SULUINTELLIGENT) )
            {
                Log(DBG,"Mulu/Sulu Egia Reload removed ");
            }
            else
            {
                 Log(DBG,"Non-Intelligent Egia Reload removed ");
            }

            /* Handle in Error while Reload removed */
            if (ME->Handle.HandleBusShort)
            {
                Log(DBG, "****Reload Removed-Handle In Error State ****");
                /// \todo 02/10/2023 NP - Add the Handle Error Swimlane with Adapter and Reload Request Screen
                Signia_PlayTone(SNDMGR_TONE_FAULT);
            }
            else
            {
                /* Check for Clamshell EOL */
                if (ME->Clamshell.ClamshellEOL)
                {
                    Gui_Request_Reload_Screen(true, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }
                else
                {
                    Gui_Request_Reload_Screen(false, pEgia->HandleProcRemaining, pEgia->AdapterProcRemaining);
                }
            }

            EGutil_ProcessDeviceConnEvents(ME,e);
            pEgia->ArticAllowed = false;
            pEgia->FiringComplete = false;
            pEgia->FPGAResetFireMode = false;

            status_ = Q_TRAN(&EGIA_Clamptest);
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Operate);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        This is the first step in the Clamping Procedure
 *
 *  \details      in this first step the Firing motor is moved distally on close key press till the Clamping ticks reached Once fully clamped if tissue relaxation required in transit to tissue relaxation
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamping::PreFire} ............................*/
QState EGIA_PreFire(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire} */
        case Q_ENTRY_SIG: {
            /// \todo 08/12/2021 NP Reload type to be handled for the screens
            Log(REQ, "**** Entering EGIA Clamping -Pre-Fire State ****");

            memcpy(&pEgia->AdapterProcedureLimit, &ME->Adapter.pHandle->Data.ProcedureLimit, sizeof(uint16_t));
            /// \todo 10/22/2021 NP Adapter ID needs to be populated in Handle.c while processing Adapter Connect Event
            /// \todo 10/22/2021 NP Faking AdapterDeviceID to one, To be taken from ME pointer Ex.ME->Adapter.DeviceID
            pEgia->AdapterDeviceID = 1;
            TM_Hook(HOOK_SG_PREFIRE_SIMULATE, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_TOGGLE_DOWN_PRESS} */
        case P_TOGGLE_DOWN_PRESS_SIG: {
            /* Set the  Down Keypress handling flag */
            uint16_t KeyState;

            do
            {
                KeyState = ME->KeyState;
                BREAK_IF(EGUtil_StopRotArtOnMultiKey(TOGGLE_DOWN, KeyState));
                pEgia->ClampCycle = EGIA_CLAMPCYCLE_CLAMPING_CLOSE;
                /* Start the B1 Shaft only if Handle not in Firing Mode */
                if(pEgia->FiringMode == false)
                {
                    /// \todo 05/17/2022 - NP JA has new code which has callback to update the SG force value
                    // Register call back handler to update Maximum Clamp Force during Full clamp
                    Signia_MotorSetExternalProcess(FIRE_MOTOR, EGutil_UpdateMaxClampForceCallBack);

                    /// \todo 08/04/2021 NP - Mild current trip to start
                    Signia_MotorStart(
                                     FIRE_MOTOR,
                                     FIRE_FULL_CLOSE_POS,
                                     FIRE_MOTOR_SHAFT_RPM,
                                     TIME_DELAY_200,
                                     FIRE_MOTOR_HARDSTOP_TIMEOUT,
                                     FIRE_MOTOR_CURRTRIP_6000, /// \todo 07/30/2021 DAZ - Mild current trip to start
                                     FIRE_MOTOR_CURRLIMIT,
                                     true,
                                     MOTOR_VOLT_15,
                                     REPORT_INTERVAL,
                                     NULL
                                     );
                }


            } while ( false );
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_TOGGLE_DOWN_RELEASE} */
        case P_TOGGLE_DOWN_RELEASE_SIG: {
            /* Stop the B1 Shaft */
            Signia_MotorStop(MOTOR_ID1);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_TOGGLE_UP_PRESS} */
        case P_TOGGLE_UP_PRESS_SIG: {
            /* Set the  Up Keypress handling flag */
            uint16_t KeyState;
            do
            {
                KeyState = ME->KeyState;
                BREAK_IF(EGUtil_StopRotArtOnMultiKey(TOGGLE_UP, KeyState));
                pEgia->ClampCycle = EGIA_CLAMPCYCLE_CLAMPING_OPEN;
                L4_GpioCtrlClearSignal(GPIO_GN_LED);
                /// \todo 08/04/2021 NP - Mild current trip to motor start
                Signia_MotorStart(
                                 FIRE_MOTOR,
                                 FIRE_FULL_OPEN_POS,
                                 FIRE_MOTOR_SHAFT_RPM,
                                 TIME_DELAY_200,
                                 FIRE_MOTOR_HOMING_TIMEOUT,
                                 FIRE_MOTOR_CURRTRIP_6000, /// \todo 07/30/2021 DAZ - Mild current trip to start
                                 FIRE_MOTOR_CURRLIMIT,
                                 true,
                                 MOTOR_VOLT_15,
                                 REPORT_INTERVAL,
                                 NULL
                                 );


            } while ( false );

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_TOGGLE_UP_RELEASE} */
        case P_TOGGLE_UP_RELEASE_SIG: {
            /* Stop the B1 Shaft */

            Signia_MotorStop(MOTOR_ID1);

            /// \todo 08/16/2021 NP Reload type and Length to be handled by reading reload info
            if( (RELOAD_MULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_SULUINTELLIGENT == pEgia->ReloadType) )
            {
                if(ME->Clamshell.ClamshellEOL)
                {
                    IntReloadScreenProgress(RELOAD_INT_CONNECT,pEgia->ReloadLen, pEgia->ReloadCartColor,true,false);
                }
                else
                {
                    IntReloadScreenProgress(RELOAD_INT_CONNECT,pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                }
            }
            else
            {
                if(ME->Clamshell.ClamshellEOL)
            {
                    NonIntReloadScreenProgress(RELOAD_NON_INT_CONNECT,NOT_USED,true,false);
                }
                else
                {
                    NonIntReloadScreenProgress(RELOAD_NON_INT_CONNECT,NOT_USED,false,false);
                }
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_MOTOR_1_STOP_INFO} */
        case P_MOTOR_1_STOP_INFO_SIG: {
            pStopInfo = (QEVENT_MOTOR_STOP_INFO *)e;
            uint8_t ReloadFireCount;            /* Reload fire count */
            /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_MOTOR_1_STOP_I~::[ErrorHandling]} */
            if (!(pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS)) {
                /// \todo 08/11/2021 NP Error handling to be done based on Stop return status
                Signia_PlayTone(SNDMGR_TONE_CAUTION);    // Fully Open - Play Caution Tone
                Log(REQ, "**** EGIA Pre-fire - Clamping Not Full Close status 0x%04X  pos %d ****",pStopInfo->StopStatus,pStopInfo->Position);

                status_ = Q_HANDLED();
            }
            /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_MOTOR_1_STOP_I~::[TissueRelaxation]} */
            else if ((!EGutil_IsFPGAReset(e)) && (pStopInfo->StopStatus & MOT_STOP_STATUS_IN_POS)) {
                int32_t TempPos;
                int32_t TempPosition;

                /// \todo 08/16/2021 NP Reload type and Length to be handled by reading reload info
                /// \todo 08/13/2021 NP handle to be added to transit to tissue relaxation state
                Log(REQ, "**** EGIA Clamping - Clamping stop status 0x%04X  pos %d ****",pStopInfo->StopStatus,pStopInfo->Position);

                TempPosition = (int32_t)CLAMP_MIDPOINT;
                Signia_MotorGetPos(FIRE_MOTOR, &TempPos);

                //Clear the Maximum Clamp force only if close to open position of firerod crosses the midpoint position
                if (abs(TempPos) < abs(TempPosition))
                {
                     pEgia->MaxClampForce = 0;
                }
                else
                {
                    ;//Do nothing
                }

                //Reload is fully clamped
                pEgia->FullyClamped = true;

                if (pEgia->ClampCycle == EGIA_CLAMPCYCLE_CLAMPING_CLOSE) /* stop condition for close only */
                {
                    /* Check for Battery Level */
                    if (EGIA_BAT_INSUFFICIENT >= pEgia->BatteryLevel)
                    {
                        // Insufficient Battery Tone
                        Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
                        L4_GpioCtrlClearSignal(GPIO_GN_LED);    // Turn off Ready LED
                    }
                    else
                    {
                         Signia_PlayTone(SNDMGR_TONE_CLAMP_CONFIRMATION);    // Pre-Fire Close - Play Clamp Confirmation
                         L4_GpioCtrlSetSignal(GPIO_GN_LED);
                    }

                    /* Check for Intelligent SULU to stop Safety LED ON or Used Clamshell */
                    DeviceMem_READ(ME->Reload,FireCount,ReloadFireCount);
                    if (((RELOAD_SULUINTELLIGENT == pEgia->ReloadType) && (ReloadFireCount == 1)) || (ME->Clamshell.ClamshellEOL)
                            || ((RELOAD_MULUINTELLIGENT == pEgia->ReloadType) && (ME->Cartridge.Status != AM_DEVICE_CONNECTED)) ||
                             ((RELOAD_NONINTELLIGENT == pEgia->ReloadType) && (pEgia->NonIntReloadEOL)))
                    {
                        L4_GpioCtrlClearSignal(GPIO_GN_LED);
                    }
                    else
                    {
                        L4_GpioCtrlSetSignal(GPIO_GN_LED);
                    }

                    if (pEgia->MaxClampForce < CLAMPINGFORCE_RANGE_1)
                    {
                        pEgia->FiringStateLast = RELOAD_INT_FD1_STATE;
                    }
                    else if (pEgia->MaxClampForce < CLAMPINGFORCE_RANGE_2)
                    {
                        pEgia->FiringStateLast = RELOAD_INT_FD2_STATE;
                    }
                    else if (pEgia->MaxClampForce < CLAMPINGFORCE_RANGE_3)
                    {
                        pEgia->FiringStateLast = RELOAD_INT_FD3_STATE;
                    }

                    if( (RELOAD_MULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_SULUINTELLIGENT == pEgia->ReloadType) )
                    {
                        /// \todo 09/24/2021 CPK - The FD1 state shows 30% completed..need to change to 0%
                        if(ME->Clamshell.ClamshellEOL)
                        {
                            IntReloadScreenProgress(RELOAD_INT_CONNECT,pEgia->ReloadLen, pEgia->ReloadCartColor,true,false);
                        }
                        else
                        {
                            IntReloadScreenProgress((RELOAD_INT_SCREEN_STATE)pEgia->FiringStateLast,pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
                        }
                    }
                    else
                    {
                        if(ME->Clamshell.ClamshellEOL)
                        {
                            NonIntReloadScreenProgress((RELOAD_NON_INT_SCREEN_STATE)pEgia->FiringStateLast,NOT_USED,true,false);
                        }
                        else
                        {
                            NonIntReloadScreenProgress((RELOAD_NON_INT_SCREEN_STATE)pEgia->FiringStateLast,NOT_USED,false,false);
                        }
                    }
                }

                Log(REQ,"SG: ForceInPreFire: %3.2f lbs, Current: %u Counts",pEgia->SGForce.ForceInLBS,pEgia->SGForce.Current );
                status_ = Q_HANDLED();
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_SAFETY_RELEASE} */
        case P_SAFETY_RELEASE_SIG: {
            Log(REQ, "**** Safety key released  ****");
            /* Stop the B1 Shaft */
            Signia_MotorStop(MOTOR_ID1);
            if (pEgia->ManualFireModeExit)
            {
                pEgia->ManualFireModeExit = false;
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_SAFETY_PRESS} */
        case P_SAFETY_PRESS_SIG: {
            /// \todo 09/28/2021 SE - Currently we do not have fire mode State. So, please move this P_SAFETY_PRESS Signal Handle to fire mode State.
            /// \todo 09/28/2021 SE - Currently we do not have fire mode State. So, please move this below code on P_SAFETY_PRESS/RELASE in Fire State.

            bool PrecondToFire;
            bool ClampMotStatus;
            bool Status;
            uint8_t ReloadFireCount;
            uint16_t KeyState;

            PrecondToFire = false;
            Status = false;

            DeviceMem_READ(ME->Reload, FireCount, ReloadFireCount);
            do
            {
                //Save Fully Clamped Status to the Handle
                ME->Reload.ReloadClamped = pEgia->FullyClamped;

                /* Reload is not clamped fully, then break */
                BREAK_IF(!pEgia->FullyClamped);
                KeyState = ME->KeyState;
                Status = EGUtil_StopRotArtOnMultiKey(SAFETY_LEFT , KeyState);
                Status = EGUtil_StopRotArtOnMultiKey(SAFETY_RIGHT, KeyState) && Status;
                Signia_MotorIsStopped(FIRE_MOTOR  ,&ClampMotStatus );
                if ( !ClampMotStatus || Status )
                {
                    /* Stop Fire Motor */
                    Signia_MotorStop(FIRE_MOTOR);
                    break;
                }
                // Checks the pre-condition to enter Firing
                PrecondToFire = EGutil_IsOKToFire(me);
            } while ( false );
            /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_SAFETY_PRESS::[FireConditionPass]} */
            if (PrecondToFire) {
                status_ = Q_TRAN(&EGIA_FireIdle);
            }
            /*.${AOs::EGIA::SM::Operate::Clamping::PreFire::P_SAFETY_PRESS::[FireConditionFailed]} */
            else {
                /// \todo 09/26/2021 SE - Call API - To check Error Condition for Clamshell & Handle Error before displays screen and fault tone
                /// \todo 09/26/2021 SE - Call API - Display the Adapter Error screen without ADAPTER Uses Remaining once it is available.
                /// \todo 09/13/2022 SE - Has to play Fault tone as per requirement 318679 to be implemented*/

                Log(REQ,"Safety Key pressed: Fire mode is not allowed");

                // Handle when reload is fully closed
                if (pEgia->FullyClamped)
                {
                    if (EGIA_BAT_INSUFFICIENT >= pEgia->BatteryLevel)
                    {
                        // Insufficient Battery Tone
                        Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
                    }
                    else
                    {
                        /* Play Caution Tone - Req-ID 327464 */
                        Signia_PlayTone(SNDMGR_TONE_CAUTION);
                    }
                }
                else
                {
                    Signia_PlayTone(SNDMGR_TONE_CAUTION);
                }

                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Clamping);
            break;
        }
    }
    return status_;
}

/**
 *
 *  \brief        Wait for initial press of the fire key
 *
 *  \details      This state waits for the fire key to be pressed, which initiates firing, or the open
 *                key to be pressed, which exits fire mode & starts opening the anvil.
 *
 *
 *  \param    me  - Extended state variables of the Handle object
 *  \param    e   - Event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
/*.${AOs::EGIA::SM::Operate::Clamping::FireIdle} ...........................*/
QState EGIA_FireIdle(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::EGIA::SM::Operate::Clamping::FireIdle} */
        case Q_ENTRY_SIG: {
            Log(REQ, "**** Entering Fire Idle state ****");

            Signia_PlayTone(SNDMGR_TONE_ENTER_FIRE_MODE);

            AO_TimerArm(&ME->Timer, FIRING_GREENLED_TOGGLE_TIME, FIRING_GREENLED_TOGGLE_TIME);

            /// \todo 09/13/2022 SE - Call Fire Mode Screen (EGIA SRS ID 338414) after New GUI Screens are Implemented

            pEgia->ArticAllowed  = false;
            TM_Hook(HOOK_SG_FIREIDLE_SIMULATE, NULL);

            // Get the Reload type and Length
            EGutil_GetReloadDeviceTypeLength(ME);

            if( (RELOAD_MULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_SULUINTELLIGENT == pEgia->ReloadType) )
            {
                IntReloadScreenProgress((RELOAD_INT_SCREEN_STATE)pEgia->FiringStateLast,pEgia->ReloadLen, pEgia->ReloadCartColor,false,true);
            }
            else
            {
                NonIntReloadScreenProgress((RELOAD_NON_INT_SCREEN_STATE)pEgia->FiringStateLast,NOT_USED,false,true);
            }
            TM_Hook(HOOK_ONE_WIRE_GET_ID_DATA, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::FireIdle::P_SAFETY_RELEASE} */
        case P_SAFETY_RELEASE_SIG: {
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::FireIdle::P_OPEN_PRESS} */
        case P_OPEN_PRESS_SIG: {
            Log(REQ, "**** Fire Open Press before Fire Close Key Press ****");

            AO_TimerDisarm(&ME->Timer);

            L4_GpioCtrlClearSignal (GPIO_GN_LED);    // Turn off Ready LED

            // Repost fire key to start motor after transition
            AO_Post(AO_Handle, e, NULL);

            pEgia->RotateAllowed = true;
            pEgia->ArticAllowed  = true;

            status_ = Q_TRAN(&EGIA_PreFire);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::FireIdle::P_FIRE_PRESS} */
        case P_FIRE_PRESS_SIG: {
            AO_Post(AO_Handle, e, NULL);    // Repost Fire key to start motor after transition
            status_ = Q_TRAN(&EGIA_Firing);
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::FireIdle::TIMEOUT} */
        case TIMEOUT_SIG: {
            L4_GpioCtrlToggleSignal (GPIO_GN_LED);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::EGIA::SM::Operate::Clamping::FireIdle::P_SAFETY_PRESS} */
        case P_SAFETY_PRESS_SIG: {
            Log(REQ, "Exiting fire mode on safety key press");
            static QEvt Signal = { P_TOGGLE_UP_PRESS_SIG, 0, 0 };
            AO_TimerDisarm(&ME->Timer);
            Signia_PlayTone(SNDMGR_TONE_EXIT_FIRE_MODE);
            L4_GpioCtrlSetSignal(GPIO_GN_LED);
            // post safety key press to exit the fire mode
            AO_Post(AO_Handle, &Signal, NULL);
            pEgia->RotateAllowed = true;
            pEgia->ArticAllowed  = true;
            pEgia->ManualFireModeExit = true;

            if( (RELOAD_MULUINTELLIGENT == pEgia->ReloadType) || (RELOAD_SULUINTELLIGENT == pEgia->ReloadType) )
            {
                IntReloadScreenProgress((RELOAD_INT_SCREEN_STATE)pEgia->FiringStateLast,pEgia->ReloadLen, pEgia->ReloadCartColor,false,false);
            }
            else
            {
                NonIntReloadScreenProgress((RELOAD_NON_INT_SCREEN_STATE)pEgia->FiringStateLast,NOT_USED,false,false);
            }
            status_ = Q_TRAN(&EGIA_PreFire);
            break;
        }
        default: {
            status_ = Q_SUPER(&EGIA_Clamping);
            break;
        }
    }
    return status_;
}
/*.${AOs::EGIA::SM::Operate::Adapter_Error} ................................*/
QState EGIA_Adapter_Error(EGIA * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&EGIA_Operate);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::EGIA} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


/******************************************************************************/
/*                             Global Function(s)                             */
/******************************************************************************/

/* ========================================================================== */
/**
 * \brief   Get pointer to EGIA local data store
 *
 * \details In the current implementation, the EGIA data store is NOT part of
 *          the overall App data store. (It should be). This function is provided
 *          so that the external helper functions (currently in EGIAutil.c) can
 *          have access to the EGIA local data without altering the local pEgia
 *          pointer. In the future, this should be done by returning a pointer
 *          to the App object. (This function could be supplied by App itself.)
 *
 * \param   < None >
 *
 * \return  Pointer to EGIA local data store
 *
 * ========================================================================== */
APP_EGIA_DATA * EGIA_GetDataPtr(void)
{
    return &Egia;
}

/**
*\} Doxygen group end tag
*/
