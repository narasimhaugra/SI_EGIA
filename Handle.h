/*.$file${.::Handle.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: Handle.qm
* File:  ${.::Handle.h}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-SP-170817A
* Issued to   : Covidien LP
* Framework(s): qpc
* Support ends: 2022-08-17
* Product(s)  :
* Signia Powered Stapler
*/
/*.$endhead${.::Handle.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifndef HANDLE_H
#define HANDLE_H

#ifdef __cplusplus  /* header compatible with C++ project */
extern "C"
{
#endif

/* ========================================================================== */
/**
 * \brief   Header file for Handle AO
 *
 * \details Global defines and prototypes defined here.
 *
 * \copyright 2021 Covidien - Surgical Innovations. All Rights Reserved.
 *
 * \file    Handle.h
 *
 * ========================================================================== */
/******************************************************************************/
/*                             Include                                        */
/******************************************************************************/
#include "Common.h"
#include "L3_Motor.h"
#include "L3_OneWireRtc.h"
#include "Signia_SoundManager.h"
#include "Signia_AdapterManager.h"
#include "Signia_Motor.h"
#include "WelcomeScreen.h"
#include "Screen_InsertClamshell.h"
#include "Screen_AdapterCompatible.h"
#include "Screen_AdapterRequest.h"
#include "Screen_AdapterCheck.h"
#include "Signia_AdapterEvents.h"
#include "Signia_KeypadEvents.h"
#include "Signia_FaultEvents.h"
#include "Signia_ChargerManager.h"
#include "Signia_BatteryHealthCheck.h"
#include "Version.h"
#include "Signia_PowerControl.h"
#include "Signia_Keypad.h"
#include "Signia_Accelerometer.h"
#include "FaultHandler.h"
#include "Screen_ClamshellError.h"
#include "Screen_BatConnectionErr.h"
#include "Screen_HandleEndOfLife.h"
#include "Screen_HandleError.h"
#include "Screen_ReqReset1.h"
#include "Screen_ReqReset2.h"
#include "Screen_ReqReset3.h"
#include "Screen_ReqReset4.h"
#include "Screen_ReqReset5.h"
#include "Screen_ReqReset6.h"
#include "Screen_ResetErr.h"
#include "McuX.h"
#include "Screen_DepletedBatt.h"
#include "Screen_RotationButton.h"
#include "L2_OnchipRtc.h"
//#include "Screen_Battery.h"
#include "Screen_UsedClamshell.h"
#include "Screen_LowBattPR2.h"

/******************************************************************************/
/*                             Global Define(s) (Macros)                      */
/******************************************************************************/
#define DeviceMem_READ(x, y, z)  {memcpy (&z, (uint8_t *) &x.pHandle->Data.y, sizeof (x.pHandle->Data.y));}
#define DeviceMem_WRITE(x, y, z) {memcpy ((uint8_t *)&x.pHandle->Data.y, &z, sizeof(x.pHandle->Data.y)); x.pHandle->Update();}

/* Clamshell Status stored in 1-w EEPROM memory */
#define   CLAMSHELL_STATUS_FLAG_REMOVED             (0x01u)
#define   CLAMSHELL_STATUS_FLAG_ONEWIRE_CONNECTED   (0x02u)
#define   CLAMSHELL_STATUS_FLAG_ONEWIRE_AUTHEN      (0x04u)
#define   CLAMSHELL_STATUS_FLAG_ONEWIRE_WRITEABLE   (0x08u)
#define   CLAMSHELL_STATUS_FLAG_ONEWIRE_DATA_GOOD   (0x10u)
#define   CLAMSHELL_STATUS_FLAG_ONEWIRE_PROCESSED   (0x20u)
#define   CLAMSHELL_STATUS_FLAG_USED                (0x40u)
#define   CLAMSHELL_STATUS_FLAG_DIRTY               (0x80u)

#define ONCHARGER_TIMETOFIRSTSLEEP              (MIN_2)    // How long to wait before going to sleep when on the charger - value taken from legacy
#define ONCHARGER_TIMETOSLEEP                   (SEC_30)

/******************************************************************************/
/*                             Global Type(s)                                 */
/******************************************************************************/
/* Ask QM to declare the Handle class --------------------------------------*/
/* This is normally declared local to the C file, but since we are sharing
   this machine among multiple models, the local data structure must be made
   available to those other modles that are part of the Handle state machine.
*/

// Handle device object
typedef struct
{
    DEVICE_UNIQUE_ID    DevAddr;        ///< Device Address of Handle
    DEVICE_ID_ENUM      DevID;          ///< Device ID (Type/Instance)
    AM_DEVICE_STATUS    Status;         ///< Connection status
    AM_HANDLE_IF        *pHandle;       ///< Clamshell access interface
    bool                HandleEOL;      ///< Handle EOL Status
    bool                HandleBusShort; ///< Handle Bus Shorted
    bool                HandleComConnected;     ///< Handle Com Status
} HANDLE;

// Clamshell device object
typedef struct
{
    DEVICE_UNIQUE_ID    DevAddr;        ///< Device Address of Clamshell
    DEVICE_ID_ENUM      DevID;          ///< Device ID (Type/Instance)  /// \todo 01/18/2022 DAZ - Make this an _IF function?
    AM_DEVICE_STATUS    Status;         ///< Connection status
    AM_CLAMSHELL_IF     *pHandle;       ///< Clamshell access interface
    bool                ClamshellEOL;   ///< Clamshell EOL
    bool                ClamshellBusShort; ///< Clamshell Bus Shorted
} CLAMSHELL;

// Adapter device object
typedef struct
{
                                      		/// \todo 01/18/2022 DAZ - Why no DevAddr?
    DEVICE_ID_ENUM      DevID;          	///< Device ID (Type/Instance)
    AM_DEVICE_STATUS    Status;         	///< Connection status
    AM_ADAPTER_IF       *pHandle;       	///< Adapter access interface
    bool                AdapterEOL;     	///< Adapter EOL
    bool                ConnectorBusShort; 	///< Adapter Bus Shorted
    bool                AdapterUnsupported;	///< Unsupported Adapter
    bool                Authenticated;     	///< Adapter Authenticate status
} ADAPTER;

// Reload device object
typedef struct
{
    DEVICE_ID_ENUM      DevID;          ///< Device ID (Type/Instance)
    AM_DEVICE_STATUS    Status;         ///< Connection status
    AM_RELOAD_IF        *pHandle;       ///< Reload access interface
} RELOAD;

// Cartridge device object
typedef struct
{
    DEVICE_ID_ENUM      DevID;          ///< Device ID (Type/Instance)
    AM_DEVICE_STATUS    Status;         ///< Connection status
    AM_CARTRIDGE_IF     *pHandle;       ///< Cartridge access interface
} CARTRIDGE;

/// Active Faults Info
typedef struct
{
    bool IsPermFailWop;        // Permanent Failure WOP status
    bool IsErrShell;           // Error shell status
    bool IsAccelErr;           // Accelerometer Error
    bool IsFileSysErr;         // Is File Sys Error
    bool BattTempError;        // Battery Temperatur Error
} FAULT_INFO;

// Charger manager event information
typedef struct
{
     QEvt           Event;
     CHARGER_INFO   Info;
} QEVENT_CHARGER;

// Accelerometer event information
typedef struct
{
     QEvt       Event;
     ACCELINFO  Info;
} QEVENT_ACCEL;

typedef enum                     ///< Request Reset Error Screens Sequence
{
    REQRSTSCREEN_SEQA,          ///< Request Reset Screen Sequence A
    REQRSTSCREEN_SEQB,          ///< Request Reset Screen Sequence B
    REQRSTSCREEN_SEQC,          ///< Request Reset Screen Sequence C
    REQRSTSCREEN_SEQD           ///< Request Reset Screen Sequence D
} REQRST_SEQ;

typedef enum                   ///< Screens to display for each Req Reset Screen Seq
{
    REQRST_SCREEN_ONE,         ///< Screen 1
    REQRST_SCREEN_TWO          ///< Screen 2
} REQRST_SCREEN;

typedef struct                         ///< Request Reset Screen Info
{
    REQRST_SEQ     ReqRstSeq:2;        ///< Request Reset Current Sequence
    REQRST_SCREEN  ReqRstScreen:1;     ///< Request Reset Current Screen in given Sequence
    uint8_t        ScreenDispCount:5;  ///< Screen1, Screen2 Display Count in given Sequence
} REQRST_SCREENINFO;

/*.$declare${AOs::Handle} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Handle} ..........................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */
    QTimeEvt Timer;
    QTimeEvt IdleTimer;
    QTimeEvt SleepTimer;
    uint8_t MotorsOK;
    uint8_t MotorsChecked;
    HANDLE Handle;
    CLAMSHELL Clamshell;
    ADAPTER Adapter;
    RELOAD Reload;
    CARTRIDGE Cartridge;
    QTimeEvt FaultTimer;
    QEQueue DeferQueue;
    QTimeEvt BatteryLowTimer;
    QTimeEvt IdleModeTimer;
    uint8_t PrevStateUSB;
    uint16_t BatChgrCntCycle;
    FAULT_INFO ActiveFaultsInfo;
    QTimeEvt MotorIdleTimer;
    QTimeEvt RotationConfigScreenTimer;
    QTimeEvt CountDownScreenTimer;
    QTimeEvt RotationConfigTimer;
    QTimeEvt ReloadSwitchTimer;
    RELOAD EgiaReload;
    bool WaitFor1WireReload;
    uint32_t OnChargerTimetoSleep;
    CHARGER_INFO* pChargerInfo;
    QTimeEvt RetryFireCountUpdateTimer;
    QTimeEvt FiringTimer;
    REQRST_SCREENINFO ReqRstScreenInfo;

    /// Display alternate screen
    bool DisplayAlternateScreen;

    /// Insufficient battery tone already played when set
    bool IsInsuffBatteryToneAlreadyPlayed;

    /// Key side (left or right)
    uint8_t KeySide;

    /// Rotation configuration enabled/disabled
    bool IsKeySideRotationDisabled;

    ///Key Press/Release State
    uint16_t KeyState;
    uint16_t HandleRemainingProcedures;
    QTimeEvt ClamshellOWShortTimer;

    /// Flag to check Handle Procedure and Firing count Test Pass or fail
    bool HandleProcFireCountTestFailed;
    QTimeEvt WaitforBHTimer;
    bool LowBatteryTriggered;
    bool InsufficientBatteryTriggered;
    bool ShutdownBatteryTriggered;
    QTimeEvt AdapterCheckTimer;
} Handle;

/* protected: */
QState Handle_initial(Handle * const me, void const * const par);

// Top level state.
//
// WARNING: This state name is accessed
//          by external routines. Be sure
//          to update all instances if
//          renaming.
QState Handle_Operate(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_Idle(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_AdapterTypeCheck(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_Banner(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_MotorTest(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_Fault(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_Startup(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_PowerDown(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_AdapterConnected(Handle * const me, QEvt const * const e);

// EEA state
//
// Control EEA adapter.
//
// This is simply a placeholder for the external model. It is never executed.
QState Handle_EEA_Operate(Handle * const me, QEvt const * const e);

// EGIA state
//
// Control EGIA adapter.
//
// This is simply a placeholder for the external model. It is never executed.
QState Handle_EGIA_Operate(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_OnCharger(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_WaitForBH(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_Reset(Handle * const me, QEvt const * const e);

/* ========================================================================== */
QState Handle_Sleep(Handle * const me, QEvt const * const e);
/*.$enddecl${AOs::Handle} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/******************************************************************************/
/*                             Global Constant Declaration(s)                 */
/******************************************************************************/

/******************************************************************************/
/*                             Global Variable Declaration(s)                 */
/******************************************************************************/
extern QActive * const AO_Handle;  // Opaque pointer to Handle Active Object

/******************************************************************************/
/*                             Global Function Prototype(s)                   */
/******************************************************************************/
extern void HNutil_ProcessDeviceConnEvents(Handle * const pMe, QEvt const * const pSig);
extern void Gui_AlterInsuffBattNoClamshell_Screen(void);
extern void Gui_AlterLowBattNoClamshell_Screen(uint16_t ProcedureCount);
/*.$declare${AOs::HandleCtor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/* ========================================================================== */
/*.${AOs::HandleCtor} ......................................................*/
void HandleCtor(void);
/*.$enddecl${AOs::HandleCtor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

#ifdef __cplusplus  /* header compatible with C++ project */
}
#endif

#endif  /* HANDLE_H */

