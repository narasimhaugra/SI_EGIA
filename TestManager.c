/*.$file${.::TestManager.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: TestManager.qm
* File:  ${.::TestManager.c}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-SP-170817A
* Issued to   : Covidien LP
* Framework(s): qpc
* Support ends: 2022-08-17
* Product(s)  :
* Signia Powered Stapler
*/
/*.$endhead${.::TestManager.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifdef __cplusplus  /* header compatible with C++ project */
extern "C"
{
#endif

/* ========================================================================== */
/**
 * \addtogroup TestManager
 * \{
 *
 * \brief   Active Object for Signia Test Manager.
 *
 * \details This module is responsible for entering to TestMode, executing the
 *             requested test case.
 *
 * \copyright 2021 Covidien - Surgical Innovations. All Rights Reserved.
 *
 * \file    TestManager.c
 * \todo 5/31/2022 BS: Encapsulate with compiler switch if the module is not needed in Release build
 * ========================================================================== */
/******************************************************************************/
/*                             Include                                        */
/******************************************************************************/
#include "TestManager.h"
#include "ActiveObject.h"
#include "Signia_ChargerManager.h"
#include "Signia_AdapterEvents.h"
#include "Signia_FaultEvents.h"
#include "McuX.h"
#include "TaskMonitor.h"
#include "L4_ConsoleManager.h"
#include "FileSys.h"
#include "L2_Timer.h"
#include "Signia_Motor.h"
#include "L3_Motor.h"
#include "L3_Fpga.h"

#include "Signia_AdapterManager.h"
#include "L3_GpioCtrl.h"
#include "Signia_Keypad.h"
#include "L2_Gpio.h"
#include "L4_OwMemoryFormats.h"
#include "L3_Battery.h"
#include "Signia_SoundManager.h"
#include "FaultHandler.h"
#include "NoInitRam.h"

/******************************************************************************/
/*                             Global Constant Definitions(s)                 */
/******************************************************************************/
/******************************************************************************/
/*                             Local Define(s) (Macros)                       */
/******************************************************************************/
#define LOG_GROUP_IDENTIFIER    (LOG_GROUP_TESTS)

#define TM_STACK_SIZE       (256u)                 /* Test Manager Stack Size*/
#define TM_EVQ_SIZE         (10u)                 /* Test Manager queue size */

#define TM_TIMEOUT_TIME_MS  (MIN_15)             ///< TestMode Timeout Time
#define TM_TIMEOUT_FLASH_INTEGRITY_CHECK  (HOUR_2) ///< Flash Integrity check Timeout time

#define HANDLE_SERIALNO_SIZE (10u)              ///< Handle Serial number size

#define TM_TESTTASKPRIO      (TASK_PRIORITY_RESERVE_10)      ///< TestTask Priority
#define TM_TESTTASKMONSTKSZ  (64u)                              ///< TestTask Size
#define TM_TESTSTACKSZ       (56u)                              ///< TestTask stack size for stack fault simulation

#define TM_TESTID_OFFSET            (2u)       ///< Offset for TestID
#define TM_BATTSIMDATA_OFFSET       (4u)       ///< Offset for Battery simulation data

#define BIT1                 (0X01u)   ///< Offset value
#define BIT_8                (8u)    	///< defines 8-bits
#define BITS_24              (24u)   	///< defines 24-bits
#define BITS_16              (16u)   	///< defines 16-bits
#define ZERO                 (0u)    	///< offset value
#define ONE                  (1u)    	///< offset value
#define TWO                  (2u)       ///< offset value
#define DATA_OFFSET          (5u)       ///< offset value
#define SHORT_MAX            (65535u) 	///< Max value of unsigned integer

#define TM_ONEWIRE_PAGEEND_OFFSET       (31u)        ///< Onewire PAGE end offset


#define TM_CPULOADTEST_LOOPTIME  (15u)        ///< Cpu load test loop time

#define TM_TEST_FILE_NAME                  ("sdcard:0:\\TestFile.txt")

#define TM_SD_MAX_STRING_LEN              (30u)
#define TM_MAXSDCARDRDWRSIZE              (10000u)
#define GET_PIT_CVAL3_TICK                ((UINT32_MAX_VALUE  - (uint32_t) PIT_CVAL3))  ///< This macro returns the current PIT timer value which is a countdown timer
#define TM_TIMER_PRESCALE                 ((SYSTEM_FREQ_HZ / 1000000u) / 2u)            ///< with 120Mhz System Clock, 1uS = 120 Cycles.
#define TM_TIMER_MAX_MICROSECONDS         ((UINT32_MAX_VALUE / TM_TIMER_PRESCALE))      ///< timer capacity
#define USBPERFTESTTIME                   MSEC_10
#define USBRXPERFTIESTTIME                SEC_1

#define MAXSPEEDSTORUN                  (5u)     ///< Maximum Speeds
#define MAXMOTORIDS                     (3u)     ///< Maximum Motor ID's
#define MOTSTARTUPDELAY                 (30u)    ///< Motor Startup Delay
#define MOTCURNTTRIP                    (8000u)  ///< Current Value to stop move when exceeded
#define MOTCURNTLMT                     (0x1FF)  ///< Motor Current Limit
#define MOT_POS                         (90000u)  ///< Motor Position (Ticks)
#define MOT_RUN_TIMEOUT                 (50000u) ///< Maximum Time to run Motor
#define FIRING_SPEED_FAST_VALUE         (1348u)  ///< Firing Speed FAST
#define FIRING_SPEED_MEDIUM_VALUE       (755u)   ///< Firing Speed MEDIUM
#define FIRING_SPEED_SLOW_VALUE         (377u)   ///< Firing Speed SLOW
#define MINIMUM_SPEED_VALUE             (25u)    ///< Minimum Speed
#define MAXIMUM_SPEED_VALUE             (1800u)  ///< Maximum Speed
#define TM_ONSTARTUP    0xD0C0FFEEu ///< Magic Number in NoinitRAM indicates Request for TestMode active mode during startup
#define TM_HANDLEBATTERY   0x03u    ///< Handle and Battery bits


#define INT_RAM_START_ADD         (0x1FFF1C00u) ///< Internal RAM START Address
#define INT_RAM_END_ADD           (0x2000FB00u) ///< Internal RAM END Address
#define EXT_RAM_START_ADD         (0xC0000000u) ///< External RAM START Address
#define EXT_RAM_END_ADD           (0xC0040000u) ///< External RAM END Address


#define TM_MAXKEYSEQ              (20u)         ///< Max key sequences per command
#define SG_STATE_MAX              (8u)         ///< Maximum States to simulate Strain Gauge values
#define CRNT_LMIT_STATE_MAX       (5u)        ///< Maximum States to simulate Motor Current Limit values

#define TO16U(pData)    (((uint16_t)((pData[1])<<(BITS_8))) | ((uint16_t)(pData[0])))
#define TO32U(pData)    (((uint32_t)((pData[3])<<(BITS_24))) | ((uint32_t)((pData[2])<<(BITS_16))) | ((uint32_t)((pData[1])<<(BITS_8))) | ((uint32_t)(pData[0])))

#define BATT_COMM_FAIL_TEST_POS    (0x4000u)  ///< CW for Battery Com Fialure

/******************************************************************************/
/*                             Global Variable Definitions(s)                 */
/******************************************************************************/
//#pragma location=".sram"
OS_STK      TMStack[TM_STACK_SIZE + MEMORY_FENCE_SIZE_DWORDS];         /* Stack for AO */
OS_EVENT *pTstMutex = NULL;
OS_EVENT *pTstQ = NULL;
extern uint8_t  Uart0RxDataBuffer[];                     /* Usb Rx data buffer */

/******************************************************************************/
/*                    Local Type Definition(s)  / Function Prototypes         */
/******************************************************************************/
typedef enum{
    BATTLEVEL,              ///< Battery (Rsoc)level
    BATTVOLTAGE,            ///< battery Voltage
    BATTCURRENT,            ///< Battery current
    BATTTEMP,               ///< Battery temperature
    BATTCHGRCNTCYCLE,       ///< Battery Charger Count Cycle
    BATTCELL0VOLTAGE,       ///< Battery Cell0 Voltage in mV
    BATTCELL1VOLTAGE,       ///< Battery Cell1 Voltage in mV
    BATTLEVELBQ,            ///< Battery (RSOC) level from BQ chip in %
    BATTCHARGESTS,          ///< Battery Charging Status
    BATTGAUGSTS,            ///< Battery Gauging Satus
    BATTSAFETYSTS,          ///< Battery Safety Status
    BATTOPERTAIIONSTS,      ///< Battery Operation Status
    BATTPFSTS,              ///< Battery Permanent Fail Status
    BATTTYPE,               ///< Battery Type
    BATTINTERNALTEMP,       ///< Internal Temperature
    TS1TEMP,                ///< Cell1 Temperature
    TS2TEMP,                ///< Cell2 Temperature
    ISVALID,                ///< Flag to check if the Battery parameters are valid
    BATTPARAM_COUNT
}BATTPARAM_BITPOS;

typedef enum{
    ADAPTERERR_STOP,            ///< Stop Adapter to simulate Uart/Com timeout
    ADAPTERERR_COUNT
}ADAPTERERRS;

typedef enum 
{
  EGIA_STATE_IDLE,                ///< SG Value simulation during IDLE State
  EGIA_STATE_CALIBINPROGRESS,     ///< SG Value simulation during Calibration In-Progress 
  EGIA_STATE_CALIBSUCCESS,        ///< SG Value simulation during Calibration Success State 
  EGIA_STATE_CLAMPTSTFULLCLOSE,   ///< SG Value simulation during Clamp Test Full Close State 
  EGIA_STATE_CLAMPTSTFULLOPEN,    ///< SG Value simulation during Clamp Test Full Open State
  EGIA_STATE_PREFIRE,             ///< SG Value simulation during Pre-Fire State        
  EGIA_STATE_FIREIDLE,            ///< SG Value simulation during Fire IDLE State
  EGIA_STATE_FIRING,              ///< SG Value simulation during Firing State
  EGIA_STATE_FIRINGRETRACT,       ///< SG Value simulation during Firing Retraction State
  EGIA_STATE_POSTFIRE             ///< SG Value simulation during Post Fire State
}EGIA_STATES;

typedef enum 
{
  MTRCRNT_STATE_ROTATION_LUP,         ///< MtrCrnt Value simulation during Left Rotation 
  MTRCRNT_STATE_ROTATION_RUP,        ///< MtrCrnt Value simulation during Right Rotation 
  MTRCRNT_STATE_ARTICULATION_LEFT,   ///<  MtrCrnt Value simulation during Articulation Left
  MTRCRNT_STATE_ARTICULATION_RIGHT, ///<  MtrCrnt Value simulation during Articulation Right
  MTRCRNT_STATE_RETRACTION          ///<  MtrCrnt Value simulation during Retraction
}MTR_CRNT_STATES;

typedef enum{
    WDTERRS_ONOFAILURE,      ///< NO WATCHDOG FAILURE
    WDTERRS_TIMEOUT,        ///< SIMULATE WATCHDOG TIMEOUT
    WDTERRS_INITFAIL,       ///< SIMULATE WATCDGO INIT FAILURE
    WATCHDOGERR_COUNT
}WATCHDOGERRS;

typedef union{                          ///< structures to be added based on the test cases
    struct
    {
        uint32_t CW;                        ///< Control word indicating which of the following parameters should be simulated
        float32_t BatteryLevel;             ///< Battery (Rsoc)level
        uint16_t BatteryVoltage;            ///< battery Voltage
        int16_t BatteryCurrent;             ///< Battery current
        float32_t  BatteryTemperature;      ///< Battery temperature
        uint16_t BatChgrCntCycle;           ///< Battery Charger Count Cycle
        uint16_t BatteryCell0Voltage;       ///< Battery Cell0 Voltage in mV
        uint16_t BatteryCell1Voltage;       ///< Battery Cell1 Voltage in mV
        uint16_t BatteryLevelBQ;            ///< Battery (RSOC) level from BQ chip in %
        uint16_t BatteryChargeSts;          ///< Battery Charging Status
        uint16_t BatteryGaugSts;            ///< Battery Gauging Satus
        uint32_t BatterySafetySts;          ///< Battery Safety Status
        uint32_t BatteryOperationSts;       ///< Battery Operation Status
        uint32_t BatteryPFSts;              ///< Battery Permanent Fail Status
        CHGR_MNGR_BATTERYTYPES BatteryType; ///< Battery Type
        float32_t InternalTemperature;      ///< Battery Internal Temperature
        float32_t TS1Temperature;           ///< Cell1 Temperature
        float32_t TS2Temperature;           ///< Cell2 Temperature
        bool IsValid;
    } BattParam;

    struct{
        uint8_t MotorIDCW;      ///< Motor Control word indicating Motor Number (Id)
    }MTR_PERFPARAM;

    struct{
        uint16_t MtrID;         ///< Motor Control word indicating Motor Number (Id)
        uint16_t Mtr0SpeedinRpm;  ///< Motor 0 Speed in RPM
        int16_t Mtr0PositioninTicks;  ///< Motor 0 Position in TICKS
        uint16_t Mtr1SpeedinRpm;  ///< Motor 1 Speed in RPM
        int16_t Mtr1PositioninTicks;  ///< Motor 1 Position in TICKS
        uint16_t Mtr2SpeedinRpm;  ///< Motor 2 Speed in RPM
        int16_t Mtr2PositioninTicks;  ///< Motor 2 Position in TICKS
    }MTR_POSITION;

    struct{
        uint8_t RamDecide;     ///  RAM Decision   ( INTERNAL RAM - 0, EXTERNAL RAM - 1 )
        uint8_t PatternDecide; ///  Pattern decide ( PATTERN - 0, ANTI PATTERN - 1 )
    }MEM_PARAMETERS;

     struct{
        uint8_t TestToDO;     ///  OS Failures Decision
    }OS_FAILURES;

    struct{
        uint16_t KeySeqCount;               ///< Key sequence in the command
        uint16_t KeySeqDelay;               ///< Delay between key sequences
        uint16_t KeyBM[TM_MAXKEYSEQ];       ///< Key BitMap
    }KEYDATA;

    struct{
        uint16_t CW;                    ///< ControlWord (Bit Coded value) indicating which test to be performed
        uint16_t Delay;                 ///< Initial Delay from Adapter connected to Adapter com interrupted
        uint8_t StrainVal[2];           ///< Strain Guage value to be simulated
    }ADAPTERERR;

    struct{
        uint8_t ToneID;                 ///  Tone to Play decision byte
        uint8_t ScreenID;               ///  Screen to Play decision byte
    }SIGNIATONESCREEN;
    
    struct {
          uint16_t MtrCW;               ///< ControlWord(Bit coded value) indicating which test to be performed
          uint16_t MtrCrntTrip;         ///< Signia Motor Current TRIP 
    }MTRCRNTSIMUL;


    uint16_t OWDeviceBM;            	///< One wire Devices to be teseted ( Bit code as per ONEWIRE_DEVICES enum)
    uint16_t SDCDErrID;   				///< SD Card Error to Trigger
    uint16_t EventLogID;  				///< Event Log to Trigger
    uint16_t CrcFailureID; 				///< CRC Command ID of Charger, Battery, Adapter
    uint16_t BattDFCW;                  ///< CW for Battery DF Params(selection) Simlation
    uint16_t WatchdogErr;               ///< Watchdog error to simulate
    uint16_t ErrTypeID;                 ///< Signia Error Type ID
    uint16_t ProcedureFireCntBM;        ///< procedure and fire count Bit mask
    uint16_t TypeofFenceErrorBM;        ///< Type of Memory Fence Errors ( TaskRam(stack) Utilization, buffers ) Bit mask
}TESTDATA;

typedef struct
{
  uint16_t SubClID;                 	///< Sub Class ID - Battery Default Parameters Class ID's
  uint8_t  DofSet;                  	///< Setting Offset ID for Battery Default Parameter Values
  uint8_t  DSize;                   	///< Data Size - Battery Default Parameter Size of the Data
  uint16_t DFdata;                 		///< Data - Battery Default Parameter Data 
  BATTERY_DF_NAMES   BitPos;      		///< Bit Position Selection of Battery DF Params
}BDF_MAPPER;

typedef struct
{
 uint8_t HookCallID;             ///< Hook ID Selection for SG Value Simulation from Table
 uint8_t CwBitpos;               ///< CW Selection for SG Value Simulation from Table
}SG_MAPPER;

typedef struct
{ 
  uint8_t ID;                   ///< Hook ID Selection for Motor Current Value Simulation from Table
  uint8_t CwBit;               ///< CW Selection for Motor Current Value Simulation from Table
}MTR_CRNT_MAPPER;

typedef struct
{
    uint32_t TestTime;                 ///< TestTime
    float32_t AvgWrPerf;               ///< Average Write speed
    float32_t AvgRdPerf;               ///< Average Read speed
    float32_t MaxWrPerf;               ///< Max Write speed
    float32_t MaxRdPerf;               ///< Max Read speed
    uint16_t WrPerfCount;              ///< Write test count
    uint16_t RdPerfCount;              ///< Read test count

}SDCARD_PERFPARAM;

typedef struct
{
    uint32_t TestTime;                  ///< Testtime
    float32_t AvgTxPerf;                ///< Average USB TX Throughtput
    float32_t AvgRxPerf;                ///< Average USB RX Throughtput
    float32_t MaxTxPerf;                ///< Max USB TX Throughtput
    float32_t MaxRxPerf;                ///< Min USB TX Throughtput
    uint16_t TxPerfCount;
    uint16_t RxPerfCount;

}USB_PERFPARAM;

typedef enum
{
    SIMULATE_SEMAPHORE_FAILURE,
    SIMULATE_MUTEX_FAILURE,
    SIMULATE_TASK_FAILURE,
    SIMULATE_QUEUE_FAILURE,
    SIMULATE_TIMEOUT_FAILURE
} TEST_FAILURE_ID;

typedef enum              ///< Enum for onewire devices bitmap
{
    HANDLE,
    BATTERY,
    CLAMSHELL,
    CHARGER,
    ADAPTER,
    RELOAD,
    CATRIDGE,
    DEVICECOUNT,
    DEVICEUNKOWN
}ONEWIRE_DEVICES;

typedef void (*TM_TESTCASE_IF)(void *pData, TESTDATA *pTdata, HOOKID HookId);

typedef struct{
    TESTCASE TestCaseID;
    TM_TESTCASE_IF TestCaseInterface;
}TM_TC_IF;

typedef struct
{
    uint16_t Key;
    uint16_t Testdata;
    uint32_t TM_OnStarup;
    uint8_t TestID;
} TestManagerNoinitData;

/******************************************************************************/
/*                             Local Constant Definition(s)                   */
/******************************************************************************/

/* The lookup table translates BQ Chip Flash Paramters to enumerated Command Ids.
   Enumerated command IDs are used in code to simulate flash paramters simple.
*/
static const BDF_MAPPER DFEnumMapperTable[] =
{
//  ClsID, OfSetID, Size, DataValue, Enum(Bitpos),
  { 249u,   0u,     2u,     50u,     DSG_CURRENT_THD         },
  { 249u,   2u,     2u,     50u,     CHG_CURRENT_THD         },
  { 249u,   4u,     2u,     35u ,    QUIT_CURRENT            },
  { 489u,   18u,    1u,     100u,    CYCLE_COUNT_PERC        },
  { 197u,   0u,     2u,     0xEEFBu, ENABLED_PF_0_15         },
  { 230u,   2u,     1u,     1u,      SHUTDOWN_TIME           },
  { 148u,   0u,     2u,     320u,    PRECHARGING_CURRENT     },
  { 168u,   4u,     1u,     10u,     MIN_START_BALANCE_DELTA },
  { 103u,   0u,     1u,     2u,      CURRENT_DEADBAND        },
  { 228u,   0u,     2u,     4500u,   VALID_VOLTAGE_UPDATE    },
  { 201u,   9u,     2u,     0x0C2Fu, SBS_DATA_CONFIG_0_15    },
  { 201u,   3u,     1u,     0x21u,   CHARGING_CONFIG         },
  { 578u,   2u,     2u,     4125u,   CLEAR_VOLTAGE_THD       },

};

/* The lookup table translates Signia Faults to enumerated Command Ids.
   Enumerated command IDs are used in code to simulate Error Type.
*/
static const ERROR_CAUSE ERRCauseMapper[] =
{
//  ReqCauseID, CausePos(Enum From FaultHandler.h),
  {  BATTERY_COMMFAIL                 },
  {  BATT_CHARGECYCLE_EOL             },
  {  BATTSHUTDN_VOLTAGE_TOOLOW        },
  {  BATTERY_TEMP_OUTOFRANGE          },
  {  BATTWARN_CHARGECYCLE_INCREMENT   },
  {  HANDLE_EOL_ZEROPROCEDURECOUNT    },
  {  HANDLE_MEMORY_ERROR              },
  {  PERMFAIL_ONEWIRE_READFAIL        },
  {  ONEWIRE_NVM_TESTFAIL             },
  {  REQRST_MOTOR_TEST                },
  {  ACCEL_SELFTEST_FAIL              },
  {  BATTERY_ISLOW                    },
  {  BATTERY_ISINSUFFICIENT           },
  {  GREENKEY_GPIO_FAIL               },
  {  PIEZO_GPIO_FAIL                  },
  {  USB_COMMUNICATION_FAIL           },
  {  HEARTBEAT_GPIO_FAIL              },
  {  ERRSHELL_UNSUPPORTED_CLAMSHELL   },
  {  ERRUSED_CLAMSHELLID_DOESNTMATCH  },
  {  UNSUPPORTED_ADAPTER_DETECTED     },
  {  ADAPTER_SGCOEFF_ZERO             },
  {  FILESYS_INTEGRITYFAIL            },

};

/* The lookup table translates Adapter Strain Gauage Values to enumerated Command Ids.
   Enumerated command IDs are used in code to simulate the Force value.
*/
static const SG_MAPPER SGCWTable[] =
{
  //  HookID, CW,
  {  HOOK_SG_CALIB_SUCCES_SIMULATE,             EGIA_STATE_CALIBSUCCESS,        },
  {  HOOK_SG_CLAMP_FULLCLOSE_SIMULATE,          EGIA_STATE_CLAMPTSTFULLCLOSE,   },
  {  HOOK_SG_CLAMP_FULLOPEN_SIMULATE,           EGIA_STATE_CLAMPTSTFULLOPEN,    },
  {  HOOK_SG_PREFIRE_SIMULATE,                  EGIA_STATE_PREFIRE,             },
  {  HOOK_SG_FIREIDLE_SIMULATE,                 EGIA_STATE_FIREIDLE,            },
  {  HOOK_SG_FIRING_SIMULATE,                   EGIA_STATE_FIRING,              },
  {  HOOK_SG_FIRING_RETRACTRACTION_SIMULATE,    EGIA_STATE_FIRINGRETRACT,       },
  {  HOOK_SG_POST_FIRE_SIMULATE,                EGIA_STATE_POSTFIRE             },
};

/* The lookup table translates Motor Current Limit Values to enumerated Command Ids.
   Enumerated command IDs are used in code to simulate the Motor Current.
*/
static const MTR_CRNT_MAPPER MtrCrntStateTable[] =
{  
  //  HookID, CW,
  {  HOOK_LUP_RDN_ROTATION_MTR_CRNT_SIMULATE,   MTRCRNT_STATE_ROTATION_LUP,       },
  {  HOOK_LDN_RUP_ROTATION_MTR_CRNT_SIMULATE,   MTRCRNT_STATE_ROTATION_RUP,       },
  {  HOOK_ARTIC_LEFT_MTR_CRNT_SIMULATE,         MTRCRNT_STATE_ARTICULATION_LEFT,  },
  {  HOOK_ARTIC_RIGHT_MTR_CRNT_SIMULATE,        MTRCRNT_STATE_ARTICULATION_RIGHT, },
  {  HOOK_RETRACT_MTR_CRNT_SIMULATE,            MTRCRNT_STATE_RETRACTION,         },
};

static const uint8_t *KeySignalTM[KEY_COUNT] =
{
    "GPIO_CLOSE_KEYn",
    "GPIO_OPEN_KEYn",
    "GPIO_LEFT_ARTIC_KEYn",
    "GPIO_RIGHT_ARTIC_KEYn",
    "GPIO_LEFT_CW_KEYn",
    "GPIO_RIGHT_CW_KEYn",
    "GPIO_LEFT_CCW_KEYn",
    "GPIO_RIGHT_CCW_KEYn",
    "GPIO_GN_KEY1n",
    "GPIO_GN_KEY2n",
};

static const uint8_t *KeyStateTM[KEY_STATE_STUCK] =
{
  "KEY_STATE_RELEASE",
  "KEY_STATE_PRESS"
};
static uint8_t MicroSecTmrOvf;

/* ask QM to declare the TestManager Class -----------------------------------*/
/*.$declare${AOs::TestManager} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TestManager} .....................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */

    /// Timer Object
    QTimeEvt TMTimer;

    //Timer to hold key time
    QTimeEvt TMKeyHoldTmr;
} TestManager;

/* protected: */
static QState TestManager_initial(TestManager * const me, void const * const par);

/* ========================================================================== */
static QState TestManager_Idle(TestManager * const me, QEvt const * const e);

/* ========================================================================== */
static QState TestManager_Active(TestManager * const me, QEvt const * const e);
/*.$enddecl${AOs::TestManager} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

static uint16_t TM_CalculateKey(void);
static void TestSimulateBattParam(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void TestSimulateMotorParam(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void TestRAMIntegrityFault(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void TestSimulateMotorPosition(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateOSTaskErrors(TESTDATA *pTdata);
static void SimulateOSFailures(void *pData, TESTDATA *pTdata, HOOKID id);
static void SimulateSDCardErrors(void *pData, TESTDATA *pTdata, HOOKID id);
static void SimulateLoggingEvents(void *pData, TESTDATA *pTdata, HOOKID id);
static void SimulateCRCFailures(void *pData, TESTDATA *pTdata, HOOKID id);

static void TestSimulateTaskMonitorFault(void *pData, TESTDATA *pTdata, HOOKID HookId);

static void TaskMonitorStackTestExecute(void *pArg);
static void TaskMonitorLoadTestExecute(void *pArg);
static void TaskMonitorCheckinTestExecute(void *pArg);
static void DummyTaskCreation(void *pArg);

static void TestSDCardPerformance(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void TestUSBPerformance(void *pData, TESTDATA *pTdata, HOOKID HookId);

static TM_STATUS TMResetMicroTimer(void);
static TM_STATUS TMInitMicroTimer(void);
static void TM_TimerHandler(void);
static float32_t GetTimeElapsed(uint32_t StartTick);
static uint32_t GetServoTimeElapsed(uint32_t StartTick);
static void TestOneWireFailure(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void OneWireFailureSimulation(void *pData, HOOKID HookId, ONEWIRE_DEVICES device);
static ONEWIRE_DEVICES GetOneWireDevice(uint8_t *pData);

static void TMSimulateKey(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void TM_UpdateNoInitAndReset(uint8_t TestId, uint16_t TestData);
static void SimulateAdapterErrors(void* pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateOWMasterFail(void* pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateBatteryFlashParameters(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateTonesAndScreens(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateSigniaErrorTypes(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateWatchdogFail(void* pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateMotorReversal(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateMotorCurrentTrip(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateHandleProcFireCountSimulation(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateMemoryFenceErrors(void *pData, TESTDATA *pTdata, HOOKID HookId);
static void SimulateFlashIntergityFault(void *pData, TESTDATA *pTdata, HOOKID HookId);

static void ClearTestManagerNoinitData(void);
static void GetTestManagerNoinitData(TestManagerNoinitData *pData);
static void UpdateTestManagerNoinitData(TestManagerNoinitData *pData);

/******************************************************************************/
/*                             Local Constant Definition(s)                   */
/******************************************************************************/

/******************************************************************************/
/*                             Local Variable Definition(s)                   */
/******************************************************************************/
/* Instantiate the TestManager active object (and local data)--------------------*/
static TestManager      LocalTestManager;                            /* Local data */
QActive *const          AO_TestManager = &LocalTestManager.super;    /* Opaque pointer to Logger Active Object */

//#pragma location=".sram"
static QEvt const *TMEventQueue[TM_EVQ_SIZE];      /* Event Queue for AO */
static uint8_t    *AOname = "TESTMANAGER";

#pragma default_variable_attributes = @ ".sram"
static uint8_t TM_TestID;
static TESTDATA TM_TestData;

static bool TestModeActive;

static OS_STK TM_TestTaskMonStk[TM_TESTTASKMONSTKSZ];


static TestManagerNoinitData TM_NoinitData;

static GPIO_uP_INT_CALLBACK_T WakeupPinCallback;
static uint8_t SeqCount;
static bool KeySimEnd;

#pragma default_variable_attributes =

static bool MotorSpeedTestStatus[MAXMOTORIDS] = {false,false,false};
static bool SGStateFlag[SG_STATE_MAX] = {false};
static bool MotorCrntLmtFlag[CRNT_LMIT_STATE_MAX] = {false};
static const uint8_t SerialKey[] = {'S','i','g','n','i','a'};
static uint8_t *TestTaskName = "TestTaskMonitor";


static const TM_TC_IF TestCaseIFTable[TC_COUNT] = {
    { TC_DUMMY, NULL},
    { TC_TASKMONITOR_STACKFAULT,        TestSimulateTaskMonitorFault },      ///< TestID = 1 -> Simulate Stack Fault
    { TC_TASKMONITOR_CPUUTILIFAULT,     TestSimulateTaskMonitorFault },      ///< TestID = 2 -> Simulate CPU Utilization Fault
    { TC_TASKMONITOR_TASKCHKFAIL,       TestSimulateTaskMonitorFault },      ///< TestID = 3 -> Simulate TaskCheckin Failure
    { TC_TESTWATCHDOG,                  SimulateWatchdogFail },              ///< TestID = 4 -> Simulate Watchdog falures
    { TC_SIM_BATTPARAM,                 TestSimulateBattParam },                ///< TestID = 5 -> Battery Parameter simulation
    { TC_SDCARD_RDWRPERFORMANCE,        TestSDCardPerformance },         ///< TestID = 6 -> SD Card read write performance
    { TC_USB_PERFORMANCE,               TestUSBPerformance },            ///< TestID = 7 -> USB performance
    { TC_MTR_PERFORMANCE,               TestSimulateMotorParam },            ///< TestID = 8 -> Motor performance
    { TC_ONEWIREAUTHENTICATIONFAIL,     TestOneWireFailure },      ///< TestID = 9 -> OneWireAuthentication Fail
    { TC_ONEWIRENVMTESTFAIL,            TestOneWireFailure },         ///< TestID = 10 -> OneWire NVM test Fail
    { TC_ONEWIRECRCTESTFAIL,            TestOneWireFailure },        ///< TestID = 11 -> OneWire CRC test Fail
    { TC_MTR_POSITION_CHECK,            TestSimulateMotorPosition },        ///< TestID = 12 -> Motor Position Check
    { TC_MEM_FAULT_RAMINTEXTINTGRTY,    TestRAMIntegrityFault },     ///< TestID = 13 -> Memory Fault RAM (Internal & External )Integrity Check
    { TC_OS_FAILURES,                   SimulateOSFailures },        ///< TestID = 14 -> OS Failures
    { TC_SD_CARD_ERRORS,                SimulateSDCardErrors },        ///< TestID = 15 -> SD Card Errors
    { TC_KEYSIMULATION,                 TMSimulateKey },         ///< TestID = 16 -> Simulate the Key signals
    { TC_ONEWIREMASTERFAIL,             SimulateOWMasterFail },        ///< TestID = 17 -> OneWire master failure
    { TC_EVE_LOGGING,                   SimulateLoggingEvents },         ///< TestID = 18 -> Event Logging
    { TC_CRCFAILURES,                   SimulateCRCFailures },         ///< TestID = 19 -> CRC Failures of SPI BUS, UART SERIAL PORT
    { TC_ONEWIRE_READFAIL,              TestOneWireFailure },          ///< TestID = 20 -> OneWire Read fail
    { TC_ONEWIRE_WRITEFAIL,             TestOneWireFailure },          ///< TestID = 21 -> OneWire Write fail
    { TC_BATTFLASHPARAMFAIL,            SimulateBatteryFlashParameters }, ///< TestID = 22 -> Simualting Battery Data Flash Params
    { TC_ADAPTERERRORS,                 SimulateAdapterErrors },          ///< TestID = 23 -> Adapter Errors simulation
    { TC_TONEANDSCREENSIMULATION,       SimulateTonesAndScreens }, ///< TestID = 24 -> Signia Tones And Screens simulation
    { TC_ERRORTYPESIMULATION,           SimulateSigniaErrorTypes }, ///< TestID = 25 -> Signia Error Types Simulation
    { TC_MOTOR_REVERSAL,                SimulateMotorReversal },///< TestID = 26 -> Signia Motor Run Direction Reversal Simualtion
    { TC_MOTOR_CRNTRIP_SIMULATION,      SimulateMotorCurrentTrip}, ///< TestID = 27 -> Signia Motor Current Trip Simulation 
    { TC_PROCEDURE_FIRE_CNT_SIMULATION, SimulateHandleProcFireCountSimulation }, ///< TestID = 28 -> Handle Procedure Fire Count Simulation 
    { TC_MEOMRY_FENCE_ERROR_SIMULATION, SimulateMemoryFenceErrors },    ///< TestID = 29 -> Handle Memory Errors (Fence) Simulation
    { TC_MEMORY_FALUT_FLASH_INEGRITY,   SimulateFlashIntergityFault }  ///< TestID = 30 -> Memory Fault Internal Flash Integrity Check 

};

/******************************************************************************/
/*                             Local Function(s)                              */
/******************************************************************************/
/* Local helper functions for TestManager: */

/* ========================================================================== */
/**
 * \brief   Calculate the Key value based on Serial Number
 *
 * \details This Function calcuates the Key value from the Handle serial number
 *              Serial Number (10bytes) = b9b8b7b6b5b4b3b2b1b0
 *              Step1: add serial number wordwise Sum = b0b1+b2b3+b4b5+b6b7+b8b9 (ignore carry if any)
 *              Step2: One's complement of sum (ISum)
 *              Step3: Xor with Serial Key "Signia": ((ISum ^ 0x5369)^0x676E)^0x6961)
 *                                      0x5369 = "Si", 0x676E = "gn", 0x6961 = "ia"
 *
 * \param   < none >
 *
 * \return  uint16_t - Calculated key
 *
 * ========================================================================== */
static uint16_t TM_CalculateKey(void)
{
    uint16_t CalcKey;
    uint16_t Temp;
    uint8_t i;
    uint8_t* pHandleSrNo;
    AM_HANDLE_IF* pHandleData;

    CalcKey = 0;

    do
    {
        pHandleData = Signia_GetHandleIF();
        pHandleSrNo = pHandleData->Data.LotNumber;  // get handle serial number from handle interface
        i = 0;
        while (i < (HANDLE_SERIALNO_SIZE))
        {
           Temp = (((uint16_t)(pHandleSrNo[i] << BIT_8)) | ((uint16_t)pHandleSrNo[i+1]));
           CalcKey += Temp;
           i+=2;
        }
        CalcKey = ~CalcKey;

        i = 0;
        while (i< (sizeof(SerialKey)))
        {
            Temp = (((uint16_t)(SerialKey[i]<< BIT_8)) | ((uint16_t)(SerialKey[i+1])));
            CalcKey ^= Temp;
            i+=2;
        }

    } while (false);
    return CalcKey;
}

/* ========================================================================== */
/**
 * \brief   Test to Simulate Stack Fault
 *
 * \details This Function simulates the Stack fault
 *
 * \param   Test - Tasmonitor test id that needs to be run
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSimulateTaskMonitorFault(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint32_t stacksz;
    void (*testfn)(void *) = NULL;

    do
    {
        BREAK_IF (HOOK_TM != HookId);
        switch(TM_TestID)
        {
            case TC_TASKMONITOR_STACKFAULT:
                Log(TST, "TestMode: TaskMonitor Stack fault simulation");
                testfn = &TaskMonitorStackTestExecute;
                stacksz = TM_TESTSTACKSZ;
                break;

            case TC_TASKMONITOR_CPUUTILIFAULT:
                Log(TST, "TestMode: TaskMonitor Load fault simulation");
                testfn = &TaskMonitorLoadTestExecute;
                stacksz = TM_TESTTASKMONSTKSZ;
                break;

            case TC_TASKMONITOR_TASKCHKFAIL:
                Log(TST, "TestMode: TaskMonitor Task checking fault simulation");
                testfn = &TaskMonitorCheckinTestExecute;
                stacksz = TM_TESTTASKMONSTKSZ;
                break;

            default:
                break;
        }
        if (NULL != testfn)
        {
            SigTaskCreate(testfn,
                          NULL,
                          &TM_TestTaskMonStk[0],
                          TM_TESTTASKPRIO,
                          stacksz,
                          TestTaskName);
        }
    } while(false);
}


/* ========================================================================== */
/**
 * \brief   Task Monitor test stub for Task Load Test.
 *
 * \details Task is created to simulate a Over utilization of CPU.
 *              This is done by running task in ready state for most of the time.
 *                     The task is desingend to starv low priority tasks of CPU time.
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void TaskMonitorLoadTestExecute(void *pArg)
{
    uint32_t tsttimer;
    tsttimer = 0;
    TaskMonitorRegisterTask(SEC_1);
    while(true)
    {
      TaskMonitorTaskCheckin(OSTCBCur->OSTCBPrio);
      tsttimer = SigTime();
       while(1)
       {
          if((SigTime() - tsttimer) > TM_CPULOADTEST_LOOPTIME)
          {
              break;
          }
       }
       OSTimeDly(MSEC_1);
    }
}

/* ========================================================================== */
/**
 * \brief   Task Monitor Stack Test stub execution.
 *
 * \details the task is created with Stack size equal to its min stack utilization size (56bytes)
 *            The below task is registered with Taskmonitor during TaskStartup
 *            Taskmonitor module should detect the Stack uitilization and raise a Stack fault
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void TaskMonitorStackTestExecute(void *pArg)
{
    TaskMonitorRegisterTask(SEC_1);
    while(true)
    {
        TaskMonitorTaskCheckin(OSTCBCur->OSTCBPrio);

        OSTimeDly(MSEC_100);

    }
}

/* ========================================================================== */
/**
 * \brief   Task Monitor test for Task Checkin faults.
 *
 * \details Task Monitor test  - with Task Checkin time > timeout time
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void TaskMonitorCheckinTestExecute(void *pArg)
{
    TaskMonitorRegisterTask(SEC_1);
    while(true)
    {
       TaskMonitorTaskCheckin(OSTCBCur->OSTCBPrio);

          OSTimeDly(SEC_3);  // Task check in error simulation
    }
}

/* ========================================================================== */
/**
 * \brief   Dummy Task Creation to Simulate OS Task Failures.
 *
 * \details Simply delay creating so that, Task Creation Fn should call and
 *          Simulate OS Task Error
 *
 * \param   pArg - Pointer to argument block from micrium. (Not used)
 *
 * \return  None
 *
 * ========================================================================== */
static void DummyTaskCreation(void *pArg)
{
    do
    {
        OSTimeDly(SEC_3);
    } while(true);
}

/* ========================================================================== */
/**
 * \brief   Test to simulate Battery parameters
 *
 * \details This Function overrides the Battery parameters
 *              Data[0] to Data[3] - 3bytes - Controlword (bitcoded word indicating which BatteryParameters to be simulated
 *                                                                               - see enum BATTPARAM_BITPOS for details)
 *              Data[4], .... - data bytes in order of BattaeryParameters enabled in ControlWord
 *
 * \param   CHARGER_INFO * - pointer to the charger info
 *
 * \param   uint8* - pointer to the Simulation data
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSimulateBattParam(void *pData, TESTDATA *pTdata, HOOKID HookId)
{

    BATTPARAM_BITPOS BatParm;
    CHARGER_INFO *pBattData;

    do
    {
    BREAK_IF(HOOK_BATTERYPARAMETER != HookId);
    pBattData = (CHARGER_INFO *)pData;
    BatParm = BATTLEVEL;

        while (BatParm < BATTPARAM_COUNT)
        {
            if( pTdata->BattParam.CW & (BIT1 << BatParm) )
            {
                switch(BatParm)
                {
                  case BATTLEVEL:
                      pBattData->BatteryLevel = pTdata->BattParam.BatteryLevel;
                      break;

                  case BATTVOLTAGE:
                      pBattData->BatteryVoltage = pTdata->BattParam.BatteryVoltage;
                      break;

                  case BATTCURRENT:
                      pBattData->BatteryCurrent = pTdata->BattParam.BatteryCurrent;
                      break;

                  case BATTTEMP:
                      pBattData->BatteryTemperature = pTdata->BattParam.BatteryTemperature;
                      break;

                  case BATTCHGRCNTCYCLE:
                      pBattData->BatChgrCntCycle = pTdata->BattParam.BatChgrCntCycle;
                      break;

                  case BATTCELL0VOLTAGE:
                      pBattData->BatteryCell0Voltage = pTdata->BattParam.BatteryCell0Voltage;
                      break;

                  case BATTCELL1VOLTAGE:
                      pBattData->BatteryCell1Voltage = pTdata->BattParam.BatteryCell1Voltage;
                      break;

                  case BATTLEVELBQ:
                      pBattData->BatteryLevelBQ = pTdata->BattParam.BatteryLevelBQ;
                      break;

                  case BATTCHARGESTS:
                      pBattData->BatteryChargeSts = pTdata->BattParam.BatteryChargeSts;
                      break;

                  case BATTSAFETYSTS:
                      pBattData->BatterySafetySts = pTdata->BattParam.BatterySafetySts;
                      break;

                  case BATTGAUGSTS:
                      pBattData->BatteryGaugSts = pTdata->BattParam.BatteryGaugSts;
                      break;

                  case BATTOPERTAIIONSTS:
                      pBattData->BatteryOperationSts = pTdata->BattParam.BatteryOperationSts;
                      break;

                  case BATTPFSTS:
                      pBattData->BatteryPFSts = pTdata->BattParam.BatteryPFSts;
                      break;

                  case BATTTYPE:
                      pBattData->BatteryType = pTdata->BattParam.BatteryType;
                      break;

                  case BATTINTERNALTEMP:
                      pBattData->InternalTemperature = pTdata->BattParam.InternalTemperature;
                      break;

                  case TS1TEMP:
                      pBattData->TS1Temperature = pTdata->BattParam.TS1Temperature;
                      break;

                  case TS2TEMP:
                      pBattData->TS2Temperature = pTdata->BattParam.TS2Temperature;
                      break;

                  case ISVALID:
                      pBattData->IsValid = pTdata->BattParam.IsValid;
                      break;

                  default:
                     break;
                }
            }
            BatParm++;
        }
    } while (false);
}
/* ========================================================================== */
/**
 * \brief   Test to simulate Motor Performance
 *
 * \details This Function Simulates the Motor Parameters( Performance )
 *
 * \note    This function ensures that following tests:
 *          a) All three Motors Runs with Minimum RPM(i.e 25 RPM) And Maximum RPM (i.e 1800 RPM )
 *          b) All three Motors Stops with in the specified time
 *          c) All three Motors Controls the MOTOR speed within 10% of the setpoint, within 200 ms of the set speed
 *             when motors are operating between Minimum RPM to Maximum RPM.
 *
 * \param   pMotorData - Pointer to the motor control parameters
 *          pTdata     - Pointer to the motor Id's input data
 *          id         - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSimulateMotorParam(void *pData, TESTDATA *pTdata, HOOKID HookId)
{

    uint8_t  MotrID[MAXMOTORIDS]        = { MOTOR_ID0, MOTOR_ID1, MOTOR_ID2 };
    uint32_t  MotrSpeed[MAXSPEEDSTORUN] = { MINIMUM_SPEED_VALUE, FIRING_SPEED_SLOW_VALUE, FIRING_SPEED_MEDIUM_VALUE,
                                                FIRING_SPEED_FAST_VALUE, MAXIMUM_SPEED_VALUE }; // In RPM's
    uint8_t    MtrIdIndx;
    MOTOR_CTRL_PARAM *pMotorData;

    static uint32_t MotorSpdUpdateTime[MAXMOTORIDS];
    static uint32_t MotorRunTime[MAXMOTORIDS];
    static uint8_t  Motspeedidx[MAXMOTORIDS];
    static uint32_t MotorSettlingTime[MAXMOTORIDS];
    static uint32_t IntialServotick;
    static uint32_t ElapsedServotime;
    static uint32_t ServoLogtime;
    static uint32_t PerValue;
    static uint8_t  SampleCntr[MAXMOTORIDS];

      pMotorData = (MOTOR_CTRL_PARAM *)pData;
      switch(HookId)
      {
       case HOOK_TM:
               for(MtrIdIndx = 0; MtrIdIndx < MAXMOTORIDS; MtrIdIndx++)
               {
                 if( pTdata->MTR_PERFPARAM.MotorIDCW & ( 0x01 << MtrIdIndx) )
                 {
                    Motspeedidx[MtrIdIndx] = 0;
                    Signia_MotorStart((MOTOR_ID)MotrID[MtrIdIndx], MOT_POS, MotrSpeed[Motspeedidx[MtrIdIndx]], MOTSTARTUPDELAY, MOT_RUN_TIMEOUT, MOTCURNTTRIP, MOTCURNTLMT, true, MOTOR_VOLT_15, 0);
                    MotorRunTime[MtrIdIndx] = SigTime();
                    MotorSpeedTestStatus[MtrIdIndx] = false;
                 }
               }
           break;

      case HOOK_MTRSPEED:
            if(pMotorData->State == MOTOR_STATE_RUNNING)
            {
                /*calculating the percentage value of the MOTOR speed within 10% of the set speed. for all defined speeds */
                PerValue = (uint32_t)(( MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO)*0.1 );

                if( ( pMotorData->MotorAvgSpeed <=  ((MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO) + PerValue )) &&
                    ( pMotorData->MotorAvgSpeed >=  ((MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO) - PerValue )) )
                {
                    SampleCntr[pMotorData->MotorId]++;

                    if( 1 == SampleCntr[pMotorData->MotorId] )
                    {
                      MotorSettlingTime[pMotorData->MotorId] =  SigTime();
                    }

                    if( 100 >= SampleCntr[pMotorData->MotorId] && !MotorSpeedTestStatus[pMotorData->MotorId])
                    {
                          Log(TST, "TestManager: Motor ID: %d, Setting Speed: %ld, Avg Speed: %lu, Time: %1u ms, Current: %lu",
                                 pMotorData->MotorId,
                                (MotrSpeed[Motspeedidx[pMotorData->MotorId]] * HANDLE_PARAM_GEAR_RATIO),
                                pMotorData->MotorAvgSpeed,
                                (MotorSettlingTime[pMotorData->MotorId] - MotorRunTime[pMotorData->MotorId]),
                                pMotorData->MotorCurrent);

                          MotorSpeedTestStatus[pMotorData->MotorId] = true;
                    }
                }
                else
                {
                    SampleCntr[pMotorData->MotorId] = 0;
                }

                if((SigTime() - MotorRunTime[pMotorData->MotorId]) >= SEC_5 )
                {
                    if( Motspeedidx[pMotorData->MotorId] < MAXSPEEDSTORUN )
                    {
                        MotorRunTime[pMotorData->MotorId] = SigTime();
                        MotorSettlingTime[pMotorData->MotorId] = SigTime();
                        Motspeedidx[pMotorData->MotorId]++;
                        Signia_MotorUpdateSpeed(pMotorData->MotorId, MotrSpeed[Motspeedidx[pMotorData->MotorId]], MOTOR_VOLT_15);
                        MotorSpeedTestStatus[pMotorData->MotorId] = false;
                        SampleCntr[pMotorData->MotorId] = 0;
                    }
                    else
                    {
                        MotorSpdUpdateTime[pMotorData->MotorId] = SigTime();
                        Signia_MotorStop(pMotorData->MotorId);
                    }
                }
            }
            else if(pMotorData->State == MOTOR_STATE_STOPPING)
            {
                Log(TST, "TestManager: Speed Stop Time : %lu in ms", (SigTime() - MotorSpdUpdateTime[pMotorData->MotorId]));
            }
            else
            {
                /* Do noting in idle state */
            }
        break;

      case HOOK_MTRSERVOSTART:/* Motor Servo Loop time execution Test:- Warning. No other task should resetting the CPU_COUNTER. Currently No other task is using it.*/
            IntialServotick = CPU_COUNTER_READ();
            ServoLogtime = SigTime();
            break;

      case HOOK_MTRSERVOEND:
            ElapsedServotime = GetServoTimeElapsed(IntialServotick);

            if( 0 == ServoLogtime%1000 )
            {
              Log(TST, "TestManager: Control Loop Execution Time = %lu microSeconds", ElapsedServotime);
            }
            break;
        default:
            break;
      }
}

/* ========================================================================== */
/**
 * \brief   Test to simulate Memory Fault
 *
 * \details This Function Simulates the Memory Fault Scenarios
 *
 * \note    This function ensures that following tests:
 *          a) Integrity of the Internal RAM check Fault Scenario.
 *          b) Integrity of the External RAM check Fault Scenario.
 *
 * \param   pData     - Pointer to data ( It carries the address of the Internal & External RAM Addresses.)
 *          pTdata  - Pointer to the input data ( RAM Decision, Pattern Decision to make fail )
 *          id        - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void TestRAMIntegrityFault(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
 static  uint8_t RamToValidate;
 static  uint8_t PatternToValidate;

      switch(HookId)
      {

        case HOOK_TM:
            RamToValidate =  pTdata->MEM_PARAMETERS.RamDecide;
            PatternToValidate = pTdata->MEM_PARAMETERS.PatternDecide;
            break;

        case HOOK_RAMPATTERNFAIL:
             if( ( 0 == RamToValidate ) && ( 0 == PatternToValidate) ) // Internal RAM Validation Fails & Actual Pattern data corrupting
             {
               if( ((uint32_t *)(pData)  >= (uint32_t*)INT_RAM_START_ADD) &&
                  ( (uint32_t *)(pData) <= (uint32_t*)INT_RAM_END_ADD ) )
               {
                 *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ZERO );
                 Log(TST, "TestManager: Internal RAM Check for Pattern  at Address = %X ", (uint32_t*)(pData));
               }
             }
             else if( ( 1 == RamToValidate ) && ( 0 == PatternToValidate) ) // External RAM Validation Fails & Anti Pattern data corrupting
             {
                if( ((uint32_t*)(pData)  >= (uint32_t*)EXT_RAM_START_ADD ) &&
                ((uint32_t*)(pData) <= (uint32_t*)EXT_RAM_END_ADD ) )
                {
                    *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ZERO );
                    Log(TST, "TestManager: External RAM Check for Pattern  at Address = %X ", (uint32_t*)(pData));
                }
             }
            else
            {
              /* Do nothing */
            }
             break;

        case HOOK_RAMANTIPATTERNFAIL:
             if( ( 0 == RamToValidate ) && ( 1 == PatternToValidate) ) // Internal RAM Validation Fails & Actual Pattern data corrupting
             {
               if( ((uint32_t*)(pData)  >= (uint32_t*)INT_RAM_START_ADD  ) &&
                  ((uint32_t*)(pData) <= (uint32_t*)INT_RAM_END_ADD ) )
               {
                 *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ONE );
                 Log(TST, "TestManager: Internal RAM Check for Anti Pattern  at Address = %X ", (uint32_t*)(pData));
               }
             }
             else if( ( 1 == RamToValidate ) && ( 1 == PatternToValidate) ) // External RAM Validation Fails & Anti Pattern data corrupting
             {
                if( ((uint32_t*)(pData)  >= ((uint32_t*)EXT_RAM_START_ADD ) ) &&
                ((uint32_t*)(pData) <= ((uint32_t*)EXT_RAM_END_ADD) ))
                {
                    *(uint32_t*)(pData) = *(uint32_t*)(pData) | ( 1 << ONE );
                    Log(TST, "TestManager: External RAM Check for Anti Pattern  at Address = %X ", (uint32_t*)(pData));
                }
             }
            else
            {
              /* Do nothing */
            }
             break;


        default:
            break;
      }
}


/* ========================================================================== */
/**
 * \brief   Test to  SimulateFlashIntergityFault.
 *
 * \details This Function Simulates the Controller Internal Flash Integrity check.
 *
 * \note    For simulating FlashIntegrity Error masking the Calculated CRC( Final CRC ) for the flash.
 *
 * \param   pData     - Pointer to the address of CRC Information 
 *          pTdata    - Pointer to the input data( received from the MCP or Serial term )
 *          HookId    - HookId represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateFlashIntergityFault(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
     CRC_INFO *pcrcMasking;
     
     pcrcMasking = (CRC_INFO *)pData;
     
    do
    { 
      if( TC_MEMORY_FALUT_FLASH_INEGRITY == TM_TestID )
      {
        BREAK_IF (HOOK_TM != HookId);
        
        if( HOOK_FLASH_INTEGRITY_SIMULATE == HookId )
        {
           pcrcMasking->CrcCalculated =   pcrcMasking->CrcCalculated + 1;        
        }
      }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Test to Motor Position
 *
 * \details This Function Starts(Moves) the Motor with the receied Parameters from the input
 *
 * \note    The Intention of the test is to see if the Motor stops with in the 20 ticks of the set position
 *          this can be observed by the logs which is received from the Motor Logs
 *
 * \param   pMtrData   - Pointer to the motor control parameters
 *          pTdata     - Pointer to the input data ( Speed in RPM, Position in Ticks, Motor ID's )
 *          id         - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */

static void TestSimulateMotorPosition(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint8_t  MotrID[MAXMOTORIDS]      = { MOTOR_ID0, MOTOR_ID1, MOTOR_ID2 };
    uint8_t    MtrIdx;
    uint16_t  MotrPosition[MAXMOTORIDS];
    uint16_t  MotrSpeed[MAXMOTORIDS];

    do
    {
        BREAK_IF( HOOK_TM != HookId );

        MtrIdx = 0;
        MotrPosition[MtrIdx]  = pTdata->MTR_POSITION.Mtr0PositioninTicks;
        MotrSpeed[MtrIdx] = pTdata->MTR_POSITION.Mtr0SpeedinRpm;
        MtrIdx++;
        MotrPosition[MtrIdx]  = pTdata->MTR_POSITION.Mtr1PositioninTicks;
        MotrSpeed[MtrIdx] = pTdata->MTR_POSITION.Mtr1SpeedinRpm;
        MtrIdx++;
        MotrPosition[MtrIdx]  = pTdata->MTR_POSITION.Mtr2PositioninTicks;
        MotrSpeed[MtrIdx] = pTdata->MTR_POSITION.Mtr2SpeedinRpm;

        for(MtrIdx = 0; MtrIdx < MAXMOTORIDS; MtrIdx++)
        {
            if( pTdata->MTR_POSITION.MtrID & ( 0x01 << MtrIdx) )
            {
                Signia_MotorSetPos((MOTOR_ID)MotrID[MtrIdx], 0);
                Signia_MotorStart((MOTOR_ID)MotrID[MtrIdx], MotrPosition[MtrIdx], MotrSpeed[MtrIdx], MOTSTARTUPDELAY, MOT_RUN_TIMEOUT, MOTCURNTTRIP, MOTCURNTLMT, true, MOTOR_VOLT_15, 0);
            }
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the SD Card Errors.
 *
 * \details This Function Simulates the File System Read Return value.
 *          Once an Error is detected with in the file system, it continues
 *          its Operation
 *
 * \param   pData        - Pointer to the motor control parameters
 *          pTdata   - Pointer to the input data ( SD Card Error to Simulate  )
 *          id           - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateSDCardErrors(void *pData, TESTDATA *pTdata, HOOKID id)
{
    uint8_t ErrID;
    ErrID =  pTdata->SDCDErrID;

    if (( HOOK_FILESYSTEMERROR == id ) && ( ErrID == 2 ))
    {
        *(uint16_t*)(pData) = FS_ERR_FILE_ERR;
        Log(TST, "TestManager: Simualting SD Card File Read Error ");
    }
    else if (( HOOK_SIMULATEXPMODEERROR == id ) && ( ErrID == 3 ))
    {
        *(uint16_t*)(pData) = FS_ERR_DEV;
        Log(TST, "TestManager: Simualting SDFile Sys Exception Mode ( Permanent Fail)Error ");
    }
    else if (HOOK_TM == id )
    {
        if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) && (TM_TestData.SDCDErrID))
        {
            TM_UpdateNoInitAndReset(TM_TestID, TM_TestData.SDCDErrID);
        }
        else if (TM_NoinitData.Testdata)
        {
            ClearTestManagerNoinitData();
        }
        else
        {
            /* Do nothing */
        }
    }
    else
    {
        /* Do nothing */
    }
}
/* ========================================================================== */
/**
 * \brief   Test to Simulating the CRC data of SPI Bus ( Battery & Charger ) and
 *          Adapter UArt Serial Port
 *
 * \details This Function Simulates the CRC Failures of the SPI_BUS,
 *          Adapter UART Serial port
 *
 * \param   pData        - Pointer to the address if the Checksum data
 *          pTdata   - Pointer to the input data ( CRC Failures ID )
 *          id           - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateCRCFailures(void *pData, TESTDATA *pTdata, HOOKID id)
{
   uint16_t TestCrcID;

    do
    {
        if (NULL == pData || NULL == pTdata )
        {
            break;
        }

        TestCrcID = pTdata->CrcFailureID;

        if (( HOOK_SPICRCFAIL == id ) && ( TestCrcID == 1 ) )
        {
           Log(TST, "TestManager: Simulating SPI Bus CRC Failure", );
           *(uint16_t*)(pData) = *(uint16_t*)(pData) + ONE;
        }
        else if( ( HOOK_ADAPTERCRCFAIL == id ) && ( TestCrcID == 2 ))
        {
          Log(TST, "TestManager: Simulating ADAPTER - UART CRC Failure", );
          *(uint8_t*)(pData) = *(uint8_t*)(pData) + ONE;
        }
        else
        {
            /* Do nothing */
        }

    } while ( false );
}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the Battery Falsh data Parameters
 *
 * \details This Function Simulates the BQ chip Battery Flash data Parameters.
 *
 * \note Simulating Battery Data Flash parameters capturing enum data(values) from the Mapping Default Parameters Table
 * \param   pData        - Pointer to the address of Simulating data
 *          pTdata   - Pointer to the input data ( CW - Paramter Selection Which Test todo, followed with
                           which DF params needs to be Simulated  )
 *          HookId           - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateBatteryFlashParameters(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint8_t u8Count;
    uint16_t DataBq;
    static uint8_t MappedEnum = NULL;
    static uint8_t FalshData[2] = {0};
    static BATT_DF_TM_DATA *pDFdata;

    pDFdata = (BATT_DF_TM_DATA *)pData;


    do
    {
        if ( HOOK_BATTERYDFFAIL == HookId || HOOK_BATTCOMMSIMULATE == HookId)
        {

            if (NULL == pData || NULL == pTdata )
            {
                break;
            }

            if( ( pTdata->BattDFCW == BATT_COMM_FAIL_TEST_POS ) && ( HOOK_BATTCOMMSIMULATE == HookId ))
            {
              *(uint8_t*)(pData) = *(uint8_t*)(pData) + ONE;
              break;
            }

            if( HOOK_BATTERYDFFAIL == HookId )
            {
               for( u8Count = 0; u8Count < sizeof(DFEnumMapperTable)/ sizeof(DFEnumMapperTable[0]); u8Count++)
                {
                    /*Capturing Enum value by comparing Default BQ Chip Falsh parametrs */
                    if( (DFEnumMapperTable[u8Count].SubClID == pDFdata->DFparameter->SubClsId ) &&
                      ( DFEnumMapperTable[u8Count].DofSet == pDFdata->DFparameter->Offset ) &&
                      ( DFEnumMapperTable[u8Count].DSize == pDFdata->DFparameter->Size) )
                    {
                          MappedEnum = (BATTERY_DF_NAMES)DFEnumMapperTable[u8Count].BitPos;
                          break;
                    }
                }

               /*Selection of Enum, and Control WD - Simulating Default parametrs */
                if( (pTdata->BattDFCW & ((uint16_t)BIT1 << MappedEnum)) )
                {
                    if( TWO == pDFdata->DFparameter->Size )
                    {
                        FalshData[0] = ( *pDFdata->pValue ) << 8;
                        FalshData[1] = *( pDFdata->pValue + 1);
                        DataBq = FalshData[0] | FalshData[1];
                        *( pDFdata->pValue + 1) = DataBq + ONE; //Lowwer Byte Simulating
                    }
                    else
                    {
                        FalshData[0] = ( *pDFdata->pValue );
                        DataBq = FalshData[0];
                        *( pDFdata->pValue ) = DataBq + ONE; //Byte Simulating
                    }
                }
            }
        }
        else if (HOOK_TM == HookId )
        {

            if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) && (TM_TestData.BattDFCW))
            {
                TM_UpdateNoInitAndReset(TM_TestID, TM_TestData.BattDFCW);
            }
            else if (TM_NoinitData.Testdata)
            {
                ClearTestManagerNoinitData();
            }
            else
            {
              /* Do nothing */
            }
        }
        else
        {
              /* Do nothing */
        }

    }while(false);
}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the Signia Tones And Screens.
 *
 * \details This Function Simulates the Signia Handle Tones List based on the requested tone And
 *          Screens.
 *
 * \note   Simulating Signia Tones by capturing the Requested Tone Play ID Minus One.
 *         ( which is equal to the Enum ((SNDMGR_TONE)) vaules defined in Signia_SoundManager.h).
 *
 *
 * \param   pData        - Pointer to the address of Simulating data
 *          pTdata      - Pointer to the input data ( CW - Tone Selection Which Test todo.)
 *          id           - HookId represents the Function call Parameter
 *
 * \return  None
 *
 * \todo 09/01/2022 UN: Currently Screens Implementation is on Hold ( Reason: UI Design update is in-progress)
 * ========================================================================== */
static void SimulateTonesAndScreens(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint8_t SoundReqID;

    /*Capturing Tone to Play And Screen to Display*/
    SoundReqID = pTdata->SIGNIATONESCREEN.ToneID ;

    do
    {
        BREAK_IF(HOOK_TM != HookId);

        BREAK_IF(!SoundReqID); // No Tone to Play

        /*Selecting the Tone and Playing based on the requested Tone*/
        Signia_PlayTone((SNDMGR_TONE)( SoundReqID - 1));

    }while(false);
}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the SimulateSigniaErrorTypes.
 *
 * \details This Function Simulates the Signia Errors Types based on the requested ErrType
 *          MOO_ERR_XXXX.Cause selects then it publishes the Cause signia to the Handle.c
 *
 * \note   Simulating Signia Error Types by capturing the Requested Error Type ID.
 *         ( which is defined in the  ERRCauseMapper Table to the Enum ((ERROR_CAUSE)).
 *
 * \param   pData     - Pointer to the address of Simulating data
 *          pTdata    - Pointer to the input data ( Requested Error type ID .)
 *          HookId    - HookId represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateSigniaErrorTypes(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    do
    {
        BREAK_IF(HOOK_TM != HookId);

        if( NULL == pTdata )
        {
          break;
        }

        /*Selecting the Cause of the Error on requested Error Type */
       FaultHandlerSetFault((ERROR_CAUSE)ERRCauseMapper[pTdata->ErrTypeID], SET_ERROR);

    }while(false);
}

/* ========================================================================== */
/**
 * \brief   Test Manager Key Handler Events.
 *
 * \details This Function Capture Key states identified by Key ID's.
 *
 * \note   None
 *
 * \param   Key       - Key Sequence (Key pattern)
 *          State     - Current Key State (Pressed or Release)
 *          KeyState  - All key states
 *
 * \return  None
 *
 * ========================================================================== */
static void TMKeyHandler(KEY_ID Key, KEY_STATE State, uint16_t KeyState)
{
  uint8_t KeyID;
  Log(TST, "TM KeyHandler: Current Key=%s, current state = %s",KeySignalTM[Key],KeyStateTM[State]);
  Log(TST, "Other Keys value: %x",KeyState);

  for(KeyID = TOGGLE_DOWN; KeyID < KEY_COUNT; KeyID++)
  {
    State = (KeyState & (1 << KeyID)) > 0? KEY_STATE_PRESS:KEY_STATE_RELEASE;
  }
}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the Motor Reversal.
 *
 * \details This Function Simulates the Signia Motor to run in Reverse Direction.
 *          Intention is to change the direction of the Motor Run.wherever applicable to Start the Motor.
 *          When to change the direction - actions takes as follows:
 *          1. During Rotation (While connecting the Adapter once calibration is done, perform any Rotation Operation)
 *          2. During ClampTest (While connecting the Reload, perform ClamTest Operation)
 *          3. During Articulation(While connecting the Reload without performing ClampTest, perform Articulation Operation)
 *
 * \note   Simulating Signia Motor Direction in Reverse Order
 *
 * \param   pData     - Pointer to the address of Motor direction data
 *          pTdata    - Pointer to the input data
 *          HookId    - HookId represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateMotorReversal(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
  uint8_t KeyIdx = GPIO_CLOSE_KEYn;

    do
    {
        if(HOOK_SIMULATEMOTOREVERSAL == HookId)
        {
            /*register key change handler*/
            L4_KeypadHandlerSetup(&TMKeyHandler);

            if( pData != NULL )
            {
                for( KeyIdx = 0; KeyIdx < KEY_COUNT; KeyIdx++ )
                {
                    if( KEY_STATE_PRESS == L4_KeypadGetKeyState((KEY_ID)KeyIdx))
                    {
                        /*Inverting the Motor Direction */
                        *(bool *)pData = !(*(bool *)pData);
                    }
                }
            }
        }

    }while(false);
}
/* ========================================================================== */
/**
 * \brief   Test to Simulating the logging Events
 *
 * \details This Function Simulates the Logging Events
            i.e. Rollover of the Logger Counts, Log the Greter than REQ Log levels
 *
 * \param   pData        - Pointer to the Logging data Parameters
 *          pTdata   - Pointer to the input data ( Event Logs Input Data  )
 *          id           - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateLoggingEvents(void *pData, TESTDATA *pTdata, HOOKID id)
{
   uint16_t LogID;
   static bool LogEndCnt;

    do
    {
        if (NULL == pData || NULL == pTdata )
        {
            Log(DBG, "SimulateLoggingEvents: pData or pTdata is NULL ");
            break;
        }

        LogID = pTdata->EventLogID;

        if (( HOOK_LOGCNTROLLOVER == id ) && ( LogID == 1 ) && ( LogEndCnt == false ))
        {
            if (NULL == pData)
            {
                Log(DBG, "SimulateLoggingEvents: pData is NULL ");
                break;
            }
			
            *(uint16_t*)(pData) = SHORT_MAX-2;
             LogEndCnt = true;
        }
        else if( ( HOOK_TM == id ) && ( LogID == 2 ))
        {
           Log(REQ, "TestManager: Log Level :  REQ ");
           Log(WNG, "TestManager: Log Level :  WNG ");
           Log(ERR, "TestManager: Log Level :  ERR ");
           Log(FLT, "TestManager: Log Level :  FLT ");
           Log(TST, "TestManager: Log Level :  TST ");
        }
        else
        {
            /* Do nothing */
        }
    } while ( false );
}

/* ========================================================================== */
/**
 * \brief   Test to simulating the OS Fault Failures.
 *          Caputring the input data based on which OS Failure Suppose to do.
 *
 * \details This Function Creates the IPC primitives.
 *           ( Not Implemented : Semaphore, Memory Create, Implemented: Mutuex, Task, Queue )
 *
 * \param   pTdata  - Pointer to the input data ( OS Error to Simulate )
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateOSTaskErrors(TESTDATA *pTdata)
{
    uint8_t  OsError;
    void* pTMQueue[ONE];
    uint8_t OSFailureID;

    OSFailureID = pTdata->OS_FAILURES.TestToDO;

    switch(OSFailureID)
    {
        case SIMULATE_MUTEX_FAILURE:
            pTstMutex = SigMutexCreate("TestHook-Mutex", &OsError);
            break;

        case SIMULATE_TASK_FAILURE:
            OsError = SigTaskCreate( &DummyTaskCreation,
                                     NULL,
                                     &TM_TestTaskMonStk[0],
                                     TM_TESTTASKPRIO,
                                     TM_TESTTASKMONSTKSZ,
                                     TestTaskName);
             break;

        case SIMULATE_QUEUE_FAILURE:
            pTstQ = SigQueueCreate(pTMQueue, ONE);
            break;

        default:
        break;
    }

}

/* ========================================================================== */
/**
 * \brief   Test to simulate OSTask Errors
 *
 * \details This Function Simulates OS Failure Errors.
 *
 * \param   pData     - Pointer to data ( It carries the address of the Error, and Simulating its value.)
 *          id        - Hook Id represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
void SimulateOSFailures(void *pData,TESTDATA *pTdata, HOOKID id)
{
    switch(id)
    {
        case HOOK_OSMUTEXFAIL:
            *(uint8_t*)(pData) = OS_ERR_MEM_INVALID_PART;
            Log(TST, "TestManager: Mutext Simulation Failure ");
            break;

        case HOOK_OSTASKFAIL:
            *(uint8_t*)(pData) = OS_ERR_MEM_INVALID_PART;
            Log(TST, "TestManager: Task Simulation Failure ");
            break;

        case HOOK_OSQUEFAIL:
            *(uint32_t*)pData = 0;
            Log(TST, "TestManager: Queue Simulation Failure ");
            break;

        case HOOK_TM:
            SimulateOSTaskErrors(pTdata);
            break;

        default:
            break;
    }
}
/* ========================================================================== */
/**
 * \brief   Test to check SD Card peformance
 *
 * \details For the test to calculate the SD card wirte/read times,
 *              a SD card write or read during the test needs to be performed.
 *              (preferable upload/read a blob from MCP)
 *
 * \param   id - HOOK id indicating if the calling Hook position in code ( either start or finish of Tx/Rx )
 *
 * \param   pData - pointer to data ( for Start hook its Null, for End hook it carries the size of Tx/Rx data )
 *
 * \return  None
 *
 * ========================================================================== */
static void TestSDCardPerformance( void *pData, TESTDATA *pTdata , HOOKID HookId)
{
    static SDCARD_PERFPARAM sdperf;

    static uint32_t SDWrTick;
    static uint32_t WrSize;
    static float32_t WrTime;
    static uint32_t SDRdTick;
    static uint32_t RdSize;
    static float32_t RdTime;
    do
    {
        BREAK_IF( (HOOK_SDWRSTART != HookId) && (HOOK_SDWREND != HookId) &&\
                  (HOOK_SDRDSTART != HookId) && (HOOK_SDRDEND != HookId) &&\
                  (HOOK_TM != HookId) );

        switch(HookId){
            case HOOK_SDWRSTART:
                SDWrTick = GET_PIT_CVAL3_TICK;
                break;

            case HOOK_SDWREND:
                WrTime += GetTimeElapsed(SDWrTick);
                WrSize += *(uint16_t *)(pData);
                break;

            case HOOK_SDRDSTART:
                SDRdTick = GET_PIT_CVAL3_TICK;
                break;

            case HOOK_SDRDEND:
                RdTime += GetTimeElapsed(SDRdTick);
                RdSize += *(uint16_t *)(pData);
                break;

            case HOOK_TM:
                WrSize = 0;
                WrTime = 0;
                RdSize = 0;
                RdTime = 0;
                sdperf.RdPerfCount = 0;
                sdperf.WrPerfCount = 0;
                sdperf.AvgWrPerf = 0;
                sdperf.AvgRdPerf = 0;
                TMInitMicroTimer();
                sdperf.TestTime = SigTime();
                break;

            default:

                break;
        }

        if (WrSize > TM_MAXSDCARDRDWRSIZE){
          sdperf.WrPerfCount++;
          sdperf.AvgWrPerf += (float32_t)((WrSize * 8))/WrTime;
          sdperf.AvgWrPerf /= sdperf.WrPerfCount;
          if (sdperf.AvgWrPerf > sdperf.MaxWrPerf)
          {
              sdperf.MaxWrPerf = sdperf.AvgWrPerf;
          }
          WrSize = 0;
          WrTime = 0;
        }
        if (RdSize > TM_MAXSDCARDRDWRSIZE){
          sdperf.RdPerfCount++;
          sdperf.AvgRdPerf += (float32_t)((RdSize * 8))/RdTime;
          sdperf.AvgRdPerf /=sdperf.RdPerfCount;
          if (sdperf.AvgRdPerf > sdperf.MaxRdPerf)
          {
              sdperf.MaxRdPerf = sdperf.AvgRdPerf;
          }
          RdSize = 0;
          RdTime = 0;
        }
        if(MIN_4 < (SigTime() - sdperf.TestTime))
        {
            Log(TST, "TestManager: SDCard Average Write speed: %3.3f Mbps, Max Write speed: %3.3f Mbps ", sdperf.AvgWrPerf, sdperf.MaxWrPerf);
            Log(TST, "TestManager: SDCard Average Read speed: %3.3f Mbps, Max Read speed: %3.3f Mbps", sdperf.AvgRdPerf, sdperf.MaxRdPerf);
            (void)TMResetMicroTimer();
            Log(TST, "Test completed" );
            TestModeActive = false;
            ClearSystemStatus();
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Handler for Timer 3
 *
 * \details
 *
 * \param   < none >
 *
 * \return  None
 *
 * ========================================================================== */

static void TM_TimerHandler(void)
{
    /* Do nothing */
  MicroSecTmrOvf++;
}
/* ========================================================================== */
/**
 * \brief   Test to check USB performance
 *
 * \details  The function calculates the Average and Max throughput for USB
 *              Every 10ms interval - Tx/Rx data transfered / time taken to transfer
 *              Results are averaged for 4min and Logged
 *
 * \param   id - HOOK id indicating if the calling Hook position in code ( either start or finish of Tx/Rx )
 *
 * \param   pData - void pointer to data ( for Start hook its Null, for End hook it carries the size of Tx/Rx data )
 *
 * \return  None
 *
 * ========================================================================== */
static void TestUSBPerformance(void *pData, TESTDATA *pTdata , HOOKID HookId)
{
    static uint32_t USBTXTime;
    static uint32_t TxSize;
    static uint32_t TxTime;
    static uint32_t USBRXTime;
    static uint32_t RxSize;
    static uint32_t RxTime;
    static USB_PERFPARAM USBPerf;

    do
    {
        BREAK_IF( (HOOK_USBTXSTART != HookId) && (HOOK_USBTXEND != HookId) &&\
                  (HOOK_USBRXSTART != HookId) && (HOOK_USBRXEND != HookId) &&\
                  (HOOK_TM != HookId) );

        switch(HookId)
        {
            case HOOK_USBTXSTART:
                USBTXTime = GET_PIT_CVAL3_TICK;
                break;

            case HOOK_USBTXEND:
                TxTime += GetTimeElapsed(USBTXTime);
                TxSize += *(uint32_t *)(pData);
                break;

            case HOOK_USBRXSTART:
                USBRXTime = GET_PIT_CVAL3_TICK;
                break;

            case HOOK_USBRXEND:
                RxTime += GetTimeElapsed(USBRXTime);
                RxSize += *(uint32_t *)(pData);
                break;

            case HOOK_TM:
                TxSize = 0;
                TxTime = 0;
                RxSize = 0;
                RxTime = 0;
                USBPerf.RxPerfCount = 0;
                USBPerf.TxPerfCount = 0;
                TMInitMicroTimer();
                USBPerf.TestTime = SigTime();
                break;

            default:
                break;
        }

        if (USBPERFTESTTIME < (TxTime/1000))
        {
          USBPerf.TxPerfCount++;
          USBPerf.AvgTxPerf += (float32_t)((TxSize * 8))/TxTime;
          USBPerf.AvgTxPerf /= USBPerf.TxPerfCount;
          if (USBPerf.AvgTxPerf > USBPerf.MaxTxPerf)
          {
              USBPerf.MaxTxPerf = USBPerf.AvgTxPerf;
          }
          TxSize = 0;
          TxTime = 0;
        }
        if (USBRXPERFTIESTTIME < (RxTime/1000))
        {
          /// \todo 06/13/2022 BS: USB RX calculation should be revisited
          USBPerf.RxPerfCount++;
          USBPerf.AvgRxPerf += (float32_t)((RxSize * 8))/RxTime;
          USBPerf.AvgRxPerf /= USBPerf.RxPerfCount;
          if (USBPerf.AvgRxPerf > USBPerf.MaxRxPerf)
          {
              USBPerf.MaxRxPerf = USBPerf.AvgRxPerf;
          }
          RxSize = 0;
          RxTime = 0;
        }

        if(MIN_4 < (SigTime() - USBPerf.TestTime))
        {
            Log(TST, "                                                                      "); /// \todo KIA 10/03/2022 - kludge to clean up log/console messages from BatteryLogInfo()
            Log(TST, "TestManager USB Average TX speed: %3.3f Mbps, MAX TX speed: %3.3f Mbps", USBPerf.AvgTxPerf, USBPerf.MaxTxPerf);
            Log(TST, "TestManager USB Average RX speed: %3.3f Mbps, MAX RX speed: %3.3f Mbps", USBPerf.AvgRxPerf, USBPerf.MaxRxPerf);
            (void)TMResetMicroTimer();
            Log(TST, "Test completed");
            TestModeActive = false;
            ClearSystemStatus();
        }
    } while(false);
}

/* ========================================================================== */
/**
 * \brief   Test OneWire failures
 *
 * \details The function executes the fault simulation if the calling device matches
 *              the device of interest (received from Test command)
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData ( bit map indicating Devices to be tested )
 *
 * \param  HookId - HOOKID
 *
 * \return  None
 *
 * ========================================================================== */
static void TestOneWireFailure(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    ONEWIRE_DEVICES Dev;
    ONEWIREPACKET *pPacketData;

    Dev = DEVICEUNKOWN;
    pPacketData = NULL;
    do
    {
        if (HOOK_TM == HookId )
        {
            // OneWire Authentication for Handle and Battery occurs during Handle startup
            // to simulate the Failure we store the Test data in noInit ram and reset the Handle
            // during startup the TestManager init routine should check for the TM_noInit data and take necessary action
            // The If condition is entered only if there is no data in No init ram indicating instance of command received from USB
            if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) &&
                  (TM_TestData.OWDeviceBM & TM_HANDLEBATTERY) )
            {
                TM_UpdateNoInitAndReset(TM_TestID,TM_TestData.OWDeviceBM);
            }
            else if (TM_NoinitData.Testdata)// if the reset is to simulate Handle or Battery onewire Authentication failure clear the noinit data
            {
                ClearTestManagerNoinitData();
            }
            else
            {
                /* Do nothing */
            }
        }
        // Extract the device information from the data pointer received
        else
        {
            if((HOOK_ONEWIRE_READFAIL == HookId && TC_ONEWIRE_READFAIL == TM_TestID) ||
               (HOOK_ONEWIRE_WRITEFAIL == HookId && TC_ONEWIRE_WRITEFAIL == TM_TestID) )
            { //  EEPROM Read and Write failure simulation

                pPacketData = (ONEWIREPACKET *)pData;
                // check if the page being written is page 0 if yes then extract the
                // device information from the page data
                if ( pPacketData->pTxData[1] == 0)
                {
                    pPacketData++;
                    if(HOOK_ONEWIRE_READFAIL == HookId)
                    {
                        // Device information in the Received frame
                        Dev = GetOneWireDevice( (uint8_t *)&(pPacketData->pRxData[0]));
                    }
                    else
                    {
                        // Device information is in the Transmitt frame
                        Dev = GetOneWireDevice( (uint8_t *)&(pPacketData->pTxData[0]));
                    }
                }
            }

            else // for other one wire error simulations
            {
                Dev = GetOneWireDevice((uint8_t *)pData);
            }

            BREAK_IF(DEVICEUNKOWN == Dev);
            if( (*(uint16_t *)pTdata & ((uint16_t)BIT1 << Dev)) )
            {
                OneWireFailureSimulation(pData, HookId, Dev);
            }
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Simulate OneWire failures
 *
 * \details
 *           Authentication fail:
 *           function compares the device being authenticated to the device of interest (received from USB command)
 *           if yes the pData (1st page of Slave EEPROM received from hook in L3_OneWireController OWComputeAuthMac ) is garbled
 *           by making the first byte (Data version number) is made zero.
 *           the same is sent to Master as challenge to calculate the slave MAC. This would result in MAC mismatch resulting in a
 *           UnAuthenticated device
 *
 *           NVM write test fail:
 *           function compare the device under NVM readwirte test to the device of interest (received from USB command)
 *           if yes the NVM Write test byte in EEPROM under test is made zero.
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  HookId - HOOKID
 *
 * \return  None
 *
 * ========================================================================== */
static void OneWireFailureSimulation(void *pData, HOOKID HookId, ONEWIRE_DEVICES device)
{
  static const uint8_t *devicename[DEVICECOUNT] = { "Handle",
                                                    "Battery",
                                                    "Clamshell",
                                                    "Charger",
                                                    "Adapter",
                                                    "Reload",
                                                    "Catridge"
                                                  };

    BasicOneWireMemoryLayout_Ver2  *pOneWireData;
    ONEWIREPACKET *pPacketData;

    pOneWireData = (BasicOneWireMemoryLayout_Ver2 *)pData;
    do
    {
       if ( (HOOK_ONEWIREAUTH == HookId) && (TC_ONEWIREAUTHENTICATIONFAIL == TM_TestID) )
        {
            Log(TST, "TestManager: Simulating %s Authentication Failure", devicename[device]);
            pOneWireData->dataVersion = 0;
        }
        else if ( (HOOK_ONEWIRENVMTEST == HookId) && (TC_ONEWIRENVMTESTFAIL == TM_TestID) )
        {
            Log(TST, "TestManager: Simulating %s NVMTest Failure", devicename[device]);
            pOneWireData->writeTest = 0;

        }
        else if ( (HOOK_ONEWIRECRCTEST == HookId) && (TC_ONEWIRECRCTESTFAIL == TM_TestID) )
        {
            Log(TST, "TestManager: Simulating %s CRCTest Failure", devicename[device]);
            ((uint8_t *)pData)[TM_ONEWIRE_PAGEEND_OFFSET]++;
        }
        else if ( (HOOK_ONEWIRE_READFAIL == HookId && TC_ONEWIRE_READFAIL == TM_TestID) ||
                  (HOOK_ONEWIRE_WRITEFAIL == HookId && TC_ONEWIRE_WRITEFAIL == TM_TestID) )
        {
            pPacketData = (ONEWIREPACKET *)pData;
            *pPacketData->pRxData = 0;
            if (HOOK_ONEWIRE_READFAIL == HookId)
            {
              Log(TST, "TestManager: Simulating %s Read Failure", devicename[device]);
            }
            else
            {
              Log(TST, "TestManager: Simulating %s Write Failure", devicename[device]);
            }
        }
        else
        {
            /* Do Nothing*/
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Get ONeWire Device from the OneWire EEPROM Data
 *
 * \details The function Maps the Signia Device id from EEPROM Data to local ONEWIRE_DEVICES enum
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData ( bit map indicating Devices to be tested )
 *
 * \param  id - HOOKID
 *
 * \return  None
 *
 * ========================================================================== */
static ONEWIRE_DEVICES GetOneWireDevice(uint8_t *pData)
{
    uint16_t SigniaDevID;
    uint16_t DevType;
    uint16_t DevInstance;
    ONEWIRE_DEVICES device;

    device = DEVICEUNKOWN;

    memcpy(&SigniaDevID, &(pData[1]), sizeof(uint16_t));
    DevType = ONEWIRE_ID_TYPE(SigniaDevID);
    DevInstance = ONEWIRE_INSTANCE(SigniaDevID);

    if ( DEVICE_TYPE_MISC == DevType)
    {
      if (DEVICE_HANDLE == DevInstance)
      {
          device = HANDLE;
      }
      if (DEVICE_BATTERY == DevInstance)
      {
          device = BATTERY;
      }
      if (DEVICE_CLAMSHELL == DevInstance)
      {
          device = CLAMSHELL;
      }
    }
    else if (DEVICE_TYPE_ADAPTER == DevType){
        device = ADAPTER;
    }
    else if ((DEVICE_TYPE_EGIA_SULU == DevType ) || (DEVICE_TYPE_EGIA_MULU == DevType ) ||
             (DEVICE_TYPE_EGIA_RADIAL == DevType ) || (DEVICE_TYPE_EEA_RELOAD == DevType ))
    {
        device = RELOAD;
    }
    else if (DEVICE_TYPE_EGIA_CART == DevType ){
        device = CATRIDGE;
    }
    else {
        device = DEVICEUNKOWN;
    }
    return device;

}

/* ========================================================================== */
/**
 * \brief Simulates the GPIO signals for keys based on data from serial command
 *
 * \details  Serial command sets the number of key sequences to be simulated , the delay between key patterns and the bitmap (pattern) of the key sequences.
 *          ( provision given to simulate max of 20 keys patterns in sequence)
 * |-----------|------|-------|-------|-------|-------|-------|-------|-------|-------|-------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
 * |KeySeqCount| Delay| KeyBM1| KeyBM2| KeyBM3| KeyBM4| KeyBM5| KeyBM6| KeyBM7| KeyBM8| KeyBM9|	KeyBM10| KeyBM11| KeyBM12| KeyBM13| KeyBM14| KeyBM15| KeyBM16| KeyBM17| KeyBM18| KeyBM19| KeyBM20|
 * |-----------|------|-------|-------|-------|-------|-------|-------|-------|-------|-------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
 *
 * \param  *pData - pointer to Gpio infomation
 *
 * \param  *pTdata - pointer to TestData
 *
 * \return  None
 *
 * ========================================================================== */
static void TMSimulateKey(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint8_t KeyId;

  /*! GPIO signals for keys, The order here should match with enum KEY_ID*/
    static const uint8_t KeySignal[KEY_COUNT] =
    {
        GPIO_CLOSE_KEYn,
        GPIO_OPEN_KEYn,
        GPIO_LEFT_ARTIC_KEYn,
        GPIO_RIGHT_ARTIC_KEYn,
        GPIO_LEFT_CW_KEYn,
        GPIO_RIGHT_CW_KEYn,
        GPIO_LEFT_CCW_KEYn,
        GPIO_RIGHT_CCW_KEYn,
        GPIO_GN_KEY1n,
        GPIO_GN_KEY2n
    };
    
    GPIO_TM_DATA *pKeyInfo;
    pKeyInfo = (GPIO_TM_DATA *)pData;

    do
    {
        if ( HOOK_GPIOSIGNAL == HookId )
        {
            BREAK_IF(KeySimEnd);
            if ( ( GPIO_GN_KEY1n == pKeyInfo->Signal )        || ( GPIO_GN_KEY2n == pKeyInfo->Signal )       ||
                 ( GPIO_OPEN_KEYn == pKeyInfo->Signal )       || ( GPIO_CLOSE_KEYn == pKeyInfo->Signal )     ||
                 ( GPIO_LEFT_CW_KEYn == pKeyInfo->Signal )    || ( GPIO_LEFT_CCW_KEYn == pKeyInfo->Signal )  ||
                 ( GPIO_RIGHT_CW_KEYn == pKeyInfo->Signal )   || ( GPIO_RIGHT_CCW_KEYn == pKeyInfo->Signal ) ||
                 ( GPIO_LEFT_ARTIC_KEYn == pKeyInfo->Signal ) || ( GPIO_RIGHT_ARTIC_KEYn == pKeyInfo->Signal ) )
            {
                for ( KeyId = 0; KeyId < KEY_COUNT; KeyId++ )
                {
                    BREAK_IF( pKeyInfo->Signal == KeySignal[KeyId]);
                }
                if (( KeyId < KEY_COUNT ))
                {
                    *pKeyInfo->pValue = ( pTdata->KEYDATA.KeyBM[SeqCount] & ((uint16_t)BIT1 << KeyId) )? false : true;
                }
            }
        }
        else if ( HOOK_TM == HookId )
        {
            // publish the Semaphore via the WakeupPinCallback function. This is required to get the Keypad module out of wait state.
            WakeupPinCallback = L2_GpioGetPinConfig(GPIO_uP_PORT_C,GPIO_PIN_03);
            if(WakeupPinCallback != NULL)
            {
                KeySimEnd = false;
                SeqCount = 0;
                WakeupPinCallback();

            }
        }
        else
        {
            /* Do nothing */
        }

    } while (false);
}

/* ========================================================================== */
/**
 * \brief Simulates the Adapter Errors
 *
 * \details  Depending on the Control word the function simulates
 *              1. Adapter Uart com break or
 *              2. StrainGuage value
 *                 |------|------|-------|------|
 *                 |  CW  | Delay| StrainGuage  |
 *                 |------|------|-------|------|
 *           CW - ControlWord bit coded indicating which test to perform
 *                      Bit 0 - ADAPTERSTOP ( Adapter Uart com break is sumulated by switching 5v off to the Adapter)
 *                      Bit 1 - SimulateStrianGauge value
 *           Delay - Initial delay from Adapter is detected to simulate Adapter uart error
 *           StrainGuage - StrainGuage value to be simulated (Raw ADC value is forced)
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData
 *
 * \param  HookId - Hook id indicating which part of Sw is calling this function
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateAdapterErrors(void* pData, TESTDATA *pTdata, HOOKID HookId)
{
    AM_DEVICE_INFO  *pDevData;
    static uint32_t TimeToTest;
    bool PinVal;
    uint8_t StIndx;
    uint8_t SgState;

    do
    {
        BREAK_IF( HOOK_ADAPTERMANAGER != HookId && HOOK_STRAINGUAGE1VAL != HookId && 
                 HOOK_SG_PREFIRE_SIMULATE != HookId && HOOK_SG_CALIB_SUCCES_SIMULATE != HookId &&
                 HOOK_SG_CLAMP_FULLCLOSE_SIMULATE != HookId  && HOOK_SG_CLAMP_FULLOPEN_SIMULATE != HookId &&
                 HOOK_SG_FIREIDLE_SIMULATE != HookId && HOOK_SG_FIRING_SIMULATE != HookId  && 
                 HOOK_SG_FIRING_RETRACTRACTION_SIMULATE != HookId && HOOK_SG_POST_FIRE_SIMULATE != HookId );
        
        // Check for the HOOK ID. If the Hook is called from Adapter manager and
        // requested test is to simulate Adapter Uart com break
        if( HOOK_ADAPTERMANAGER == HookId && GET_BIT(pTdata->ADAPTERERR.CW, ADAPTERERR_STOP) )
        {
            BREAK_IF(NULL == pData);
            pDevData = (AM_DEVICE_INFO*)pData;
            if (AM_DEVICE_STATE_AUTHENTICATE == pDevData[AM_DEVICE_ADAPTER].State)
            {
                // If the Adapter state is in Authenticate then start a delay timer.
                // Delay value is received from Test command
                TimeToTest = SigTime() + pTdata->ADAPTERERR.Delay;
            }
            //Simulate Adapter Uart Communication Break, Adapter Active State.
            BREAK_IF(AM_DEVICE_STATE_ACTIVE != pDevData[AM_DEVICE_ADAPTER].State);

            BREAK_IF(SigTime() < TimeToTest);
            L3_GpioCtrlGetSignal(GPIO_EN_5V, &PinVal);
            if(PinVal){
                 // The Initial delay is expired and the Adapter is powered then switch the Adapter 5V off
                 L3_GpioCtrlClearSignal(GPIO_EN_5V);
                 // Clear the control word, this is to avoid the test to run indefinetly
                 pTdata->ADAPTERERR.CW &= 0xFFFEU;
                 Log(DBG,"TestManager: Simulate Adapter Commmunication Break");
            }

        }
        else if( HOOK_STRAINGUAGE1VAL == HookId )
        {           
          for( StIndx = 0; StIndx < sizeof(SGStateFlag); StIndx++)
          {
            if( true == SGStateFlag[StIndx] )
            {
              // force the values received in test command to the ADC raw values.
              ((uint8_t *)pData)[0] = pTdata->ADAPTERERR.StrainVal[0];
              ((uint8_t *)pData)[1] = pTdata->ADAPTERERR.StrainVal[1];
              break;
            }
          }
        }
        else if( HOOK_SG_CALIB_SUCCES_SIMULATE == HookId   || HOOK_SG_CLAMP_FULLCLOSE_SIMULATE == HookId ||
                 HOOK_SG_CLAMP_FULLOPEN_SIMULATE == HookId || HOOK_SG_PREFIRE_SIMULATE == HookId        ||
                 HOOK_SG_FIREIDLE_SIMULATE == HookId      || HOOK_SG_FIRING_SIMULATE == HookId         ||
                 HOOK_SG_FIRING_RETRACTRACTION_SIMULATE == HookId  || HOOK_SG_POST_FIRE_SIMULATE == HookId )
        {          
          for( StIndx = 0; StIndx < sizeof(SGCWTable); StIndx++)
          {
            if( HookId == SGCWTable[StIndx].HookCallID  )
              {
                  SgState = SGCWTable[StIndx].CwBitpos;
                  break;
              }
          }
          
          if(  pTdata->ADAPTERERR.CW  & ( 1 << SgState) )
          {
             SGStateFlag[SgState - 2] = true;
          }
        }
        else
        {
            /* Do nothing */
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Test to Simulating the Motor Current Limit For EGIA Application.
 *
 * \details This Function Simulates the Signia Motor Current Limit.
 *          Motor Current Limit simulated as follows:
 *          1. During Rotation (While connecting the Adapter once calibration is done, perform any Rotation Operation)
 *          2. During Articulation(While connecting the Reload without performing ClampTest, perform Articulation Operation)
 *          3. During Retraction ( Firing open key press after fire key press )
 *
 * \param   pData     - Pointer to the address of Motor Current Limit( Raw ADC Counts ) data
 *          pTdata    - Pointer to the input data
 *          HookId    - HookId represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateMotorCurrentTrip(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint8_t StIdx;
    uint8_t EgiaOperation;
    
    do
    {
        BREAK_IF( HOOK_MTR_CRNTRIP_SIMULATE != HookId && HOOK_LUP_RDN_ROTATION_MTR_CRNT_SIMULATE != HookId &&
                  HOOK_LDN_RUP_ROTATION_MTR_CRNT_SIMULATE != HookId && HOOK_ARTIC_LEFT_MTR_CRNT_SIMULATE != HookId && 
                  HOOK_ARTIC_RIGHT_MTR_CRNT_SIMULATE != HookId && HOOK_RETRACT_MTR_CRNT_SIMULATE != HookId );

        /*Simulating Motor Current Trip Value*/
        if(HOOK_MTR_CRNTRIP_SIMULATE == HookId)
        {
           for( StIdx = 0; StIdx < sizeof(MotorCrntLmtFlag); StIdx++)
          {
              if( true == MotorCrntLmtFlag[StIdx] )
              {
                *(uint16_t *)pData = pTdata->MTRCRNTSIMUL.MtrCrntTrip;
                break;
              }
          }
        }
        
        /*Simulating Stage wise Motor Current Trip value*/
        if(HOOK_LUP_RDN_ROTATION_MTR_CRNT_SIMULATE == HookId || HOOK_LDN_RUP_ROTATION_MTR_CRNT_SIMULATE == HookId ||
           HOOK_ARTIC_RIGHT_MTR_CRNT_SIMULATE == HookId || HOOK_ARTIC_LEFT_MTR_CRNT_SIMULATE == HookId ||
           HOOK_RETRACT_MTR_CRNT_SIMULATE == HookId )
        {  
          for( StIdx = 0; StIdx < sizeof(MtrCrntStateTable); StIdx++)
          {           
            if( HookId == MtrCrntStateTable[StIdx].ID  )
            {
              EgiaOperation = MtrCrntStateTable[StIdx].CwBit;
              break;
            }
          }
          
          if(pTdata->MTRCRNTSIMUL.MtrCW & (1 << EgiaOperation) )
          {
            MotorCrntLmtFlag[StIdx] = true;
          }
        }
    }while(false);
}


/* ========================================================================== */
/**
 * \brief   Test to  SimulateHandleProcFireCountSimulation.
 *
 * \details This Function Simulates the SimulateHandle Procedure And Fire Count Simulation.
 *
 * \param   pData     - Pointer to Handle one wire memory format 
 *          pTdata    - Pointer to the input data
 *          HookId    - HookId represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateHandleProcFireCountSimulation (void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint16_t UsageCntID;
    UsageCntID = pTdata->ProcedureFireCntBM;
    MemoryLayoutHandle_Ver2  *pOneWireMem;
    pOneWireMem = (MemoryLayoutHandle_Ver2 *)pData;
    
    do
    {     
        if((HOOK_PROCEDURE_FIRE_CNT_SIMULATE == HookId) && (TC_PROCEDURE_FIRE_CNT_SIMULATION == TM_TestID))
        {
            if(1 == UsageCntID)
            {
                pOneWireMem->ProcedureCount = pOneWireMem->ProcedureCount - 1;
                Log(DBG,"TestManager: Simulate Handle Procedure Count Fail ");
            }
            else if(2 == UsageCntID)
            {
                pOneWireMem->FireCount = pOneWireMem->FireCount - 1;
                Log(DBG,"TestManager: Simulate Handle Fire Count Fail ");
            }
            else
            {
              /*Do nothing*/
            }
        }
        else if (HOOK_TM == HookId)
        {
            if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) && (TM_TestData.ProcedureFireCntBM))
            {
                TM_UpdateNoInitAndReset(TM_TestID, TM_TestData.ProcedureFireCntBM);
            }
            else if (TM_NoinitData.Testdata)
            {
                ClearTestManagerNoinitData();
            }
            else
            {
              /* Do nothing */
            }
        }
        
    } while (false);
}


/* ========================================================================== */
/**
 * \brief   Test to  SimulateMemoryFenceError.
 *
 * \details This Function Simulates the Memory Fence Errors for the stackover flow 
 *           and Bufferover flow.
 *
 * \note    For simulating Stackoverflow Fence Error Writing few bytes of AntiPattern 
 *          data into the stackOverflow memory fence region - Task RAM utilization exceeds
 *          For simulating Buffer overflow Fence Error Writing a byte of AntiPattern data into the 
 *          Bufferoverflow memory fence region - Memory Fence Error
 *
 * \param   pData     - Pointer to MemoryFence for the stack or memory array has overflowed.
 *          pTdata    - Pointer to the input data( received from the MCP or Serial term )
 *          HookId    - HookId represents the Function call Parameter
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateMemoryFenceErrors(void *pData, TESTDATA *pTdata, HOOKID HookId)
{
    uint16_t TypeOfFence;
    uint8_t  MaskMemErrBytes[DATA_OFFSET]; 
    TypeOfFence = pTdata->TypeofFenceErrorBM;
    
    do
    { 
      
      if( TC_MEOMRY_FENCE_ERROR_SIMULATION == TM_TestID )
      {
        BREAK_IF (HOOK_TM != HookId);

        if(ONE == TypeOfFence)
        {
           for(uint8_t i=0; i< sizeof(MaskMemErrBytes); i++)
           {
              TMStack[i] = 0x5A5A5A5A;// Writing Anti-Pattern into the StackUtilization Fence Location
           }            
           Log(DBG,"TestManager: Memory Fence Task RAM Utilizatin Requested ");
        }
        else if(TWO == TypeOfFence)
        {
           Uart0RxDataBuffer[(MAX_DATA_BYTES + MEMORY_FENCE_SIZE_BYTES) - 1] = 0x5A;// Writing Anti-Pattern into the Buffer Fence Location;
           Log(DBG,"TestManager: Memory Fence Buffer Requested ");
        }
        else
        {
            /*Do nothing*/
        }
      }
        
    } while (false);
}


/* ========================================================================== */
/**
 * \brief Simulates OneWire Master chip fail
 *
 * \details
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData
 *
 * \param  HookId - Hook id indicating which part of Sw is calling this function
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateOWMasterFail(void* pData, TESTDATA *pTdata, HOOKID HookId)
{
    if (HOOK_TM == HookId )
    {
        if ( (TM_ONSTARTUP != TM_NoinitData.TM_OnStarup) )
        {
            TM_UpdateNoInitAndReset(TM_TestID,0);
        }
        else // Clear no init data
        {
            ClearTestManagerNoinitData();
        }
    }
    else if ( HOOK_ONEWIREMASTERFAIL == HookId)
    {
        *(uint16_t *)pData = 0;
    }
    else
    {
        /* Do nothing */
    }

}

/* ========================================================================== */
/**
 * \brief Simulates Watchdog Failures
 *
 * \details  Simulates the below Watchdog filure
 *              1. Watchdog Timout - This is done by Suspending the TaskMonitor which is responsible for
 *                                   Watchdog refresh.
 *              2. Watchdog Init failure
 *
 * \param  *pData - pointer to Onewire EEPROM Data
 *
 * \param  *pTdata - pointer to TestData
 *
 * \param  HookId - Hook id indicating which part of Sw is calling this function
 *
 * \return  None
 *
 * ========================================================================== */
static void SimulateWatchdogFail(void* pData, TESTDATA *pTdata, HOOKID HookId)
{
    do
    {
        if ( (WDTERRS_INITFAIL == pTdata->WatchdogErr)  )
        {
         if (HOOK_TM == HookId)
          {
            TaskMonitorDisable();
            TaskMonitorEnable();
          }
          // Disable Watchdog to simulate Watchdog initialization failure
          if(HOOK_WATCHDOGINIT == HookId)
          {
               if(NULL != pData)
               {
                   *(bool *)pData = false;
               }
          }
        }
        else if( (WDTERRS_TIMEOUT == pTdata->WatchdogErr) && (HOOK_TM == HookId) )
        {
            // Suspending Taskmonitor would not give a chance to refresh the watchdog timer
            Log(TST, "Simulate Watchdog Timeout Failure");
            OSTaskSuspend(TASK_PRIORITY_TASK_MONITOR);
        }
        else
        {
            /* Do nothing */
        }
    } while (false);
}

/* ========================================================================== */
/**
 * \brief   Initialize a PIT timer for micro second resolution
 *
 * \details  function initializes PIT TIMER 3 as microsecond timer
 *              - Decrement timer with 60Mhz frequency (60 ticks = 1microsecond)
 *
 * \param   < none >
 *
 * \return  TM_STATUS - TM_STATUSOK if Init successful,
 *                    - TM_STATUSFAIL in case of error
 *
 * \todo 06/13/2022 BS: Check the use of DWT from CpuCycles.h and remove usage of Timer3
 * ========================================================================== */
static TM_STATUS TMInitMicroTimer(void)
{
    TimerControl pControl;
    TIMER_STATUS TimerStatus;
    TM_STATUS Status;
    Status = TM_STATUSFAIL;
    do
    {
        MicroSecTmrOvf = 0;
            /* configure PIT timer3*/
        pControl.TimerId = TIMER_ID4;
        pControl.Mode = TIMER_MODE_PERIODIC;
        pControl.Value = TM_TIMER_MAX_MICROSECONDS-1;
        pControl.pHandler = (&TM_TimerHandler);
        TimerStatus = L2_TimerConfig (&pControl);
        if(TIMER_STATUS_ERROR == TimerStatus)
        {
            Log(TST,"TestManager: L2_TimerConfig Error, SD Card Test not performed ");
            break;
        }
        TimerStatus = L2_TimerStart(TIMER_ID4);
        if(TIMER_STATUS_ERROR == TimerStatus)
        {
            Log(TST,"TestManger: MicroSecond Timer start fail, SD Card Test not performed ");
            break;
        }

        Status = TM_STATUSOK;
    } while (false);
    return Status;
}
/* ========================================================================== */
/**
 * \brief   Reset a PIT timer for micro second resolution
 *
 * \details  function resets PIT TIMER 3 as microsecond timer
 *
 * \param   < none >
 *
 * \return  TM_STATUS - TM_STATUSOK if Init successful,
 *                    - TM_STATUSFAIL in case of error
 *
 * ========================================================================== */
static TM_STATUS TMResetMicroTimer(void)
{
    TM_STATUS Status;
    Status = TM_STATUSOK;

    if(TIMER_STATUS_ERROR == L2_TimerRestart(TIMER_ID4, TM_TIMER_MAX_MICROSECONDS-1))
    {
      Log(TST, "TestManager: MicroTimer Restart fail");
        Status = TM_STATUSFAIL;

    }
    return Status;
}

/* ========================================================================== */
/**
 * \brief   calculate the time elapsed
 *
 * \details  function calculates the time elapsed in Microseconds based on the start time of PIT 3 timer
 *              - Decrement timer with 60Mhz frequency (60 ticks = 1microsecond)
 *
 * \param   StartTick
 *
 * \return  float32_t - Returns the time in microseconds from StartTick to current Tick of PIT 3 timer
 *
 * \note The below function takes care for one timer overflow,
 *              Expectation is that elapsed time shall be < timer overflow time (~71.5sec)
 *
 * ========================================================================== */
static float32_t GetTimeElapsed(uint32_t StartTick)
{
    float32_t TimeElapsed;
    if (StartTick > GET_PIT_CVAL3_TICK)
    {
        TimeElapsed = (TM_TIMER_MAX_MICROSECONDS - (StartTick - GET_PIT_CVAL3_TICK))/60;
    }
    else
    {
        TimeElapsed = (GET_PIT_CVAL3_TICK - StartTick)/60;

    }
    return TimeElapsed;

}

/* ========================================================================== */
/**
 * \brief   Calculating the Elapsed Time
 *
 * \details  function calculates the time elapsed in Microseconds based on the start time
 *
 * \param   StartTick  - Intial tick of the CPU Timer in Micro Seconds
 *
 * \return  uint32_t - Returns the time in microseconds from StartTick to current Tick
 *
 * ========================================================================== */
static uint32_t GetServoTimeElapsed(uint32_t StartTick)
{
    uint32_t ElapsedTime;
    if (StartTick >= CPU_COUNTER_READ())
    {
        ElapsedTime = ((UINT32_MAX_VALUE - StartTick ) + CPU_COUNTER_READ());
    }
    else
    {
        ElapsedTime = (CPU_COUNTER_READ() - StartTick);
    }

    return ElapsedTime;
}

/* ========================================================================== */
/**
 * \brief   Update No init Ram and Reset
 *
 * \details
 *
 * \param   TestId  - Test to be simulated
 *
 * \param   TestData - Data to be simulated
 *
 * \return  None
 *
 * ========================================================================== */
static void TM_UpdateNoInitAndReset(uint8_t TestId, uint16_t TestData)
{
    TM_NoinitData.Key =  TM_CalculateKey();
    TM_NoinitData.TestID = TestId;
    TM_NoinitData.Testdata = TestData; //TM_TestData.OWDeviceBM;
    TM_NoinitData.TM_OnStarup = TM_ONSTARTUP;
    UpdateTestManagerNoinitData(&TM_NoinitData);
    Log(TST, "TestManger: Resetting the device to simulate during Intialization/Bootup Failures ");
    OSTimeDly(MSEC_100); // delay to ensure logging happens
    SoftReset();
}

/* ========================================================================== */
/**
 * \brief   Update TestManager Data
 *
 * \details This function updates the Test Manager data noInit RAM.
 *
 * \param *pData - Pointer to TestManagerNoinitData
 *
 * \retval  None
 *
 * ========================================================================== */
void UpdateTestManagerNoinitData(TestManagerNoinitData *pData)
{
    noInitRam.TM_KEY = pData->Key;
    noInitRam.TM_TestID = pData->TestID;
    noInitRam.TM_TestData = pData->Testdata;
    noInitRam.TM_TSTMODEONSTARTUP = pData->TM_OnStarup;
}

/* ========================================================================== */
/**
 * \brief   Get TestManager Data
 *
 * \details This function Reads the Test Manager data from noInit RAM.
 *
 * \param *pData - Pointer to TestManagerNoinitData
 *
 * \retval  None
 *
 * ========================================================================== */
void GetTestManagerNoinitData(TestManagerNoinitData *pData)
{
    pData->Key = noInitRam.TM_KEY;
    pData->TestID = noInitRam.TM_TestID;
    pData->Testdata = noInitRam.TM_TestData;
    pData->TM_OnStarup = noInitRam.TM_TSTMODEONSTARTUP;
}

/* ========================================================================== */
/**
 * \brief   Clear TestManager Data
 *
 * \details This function Clears the Test Manager data noInit RAM.
 *
 * \param
 *
 * \retval  None
 *
 * ========================================================================== */
void ClearTestManagerNoinitData(void)
{
    noInitRam.TM_KEY = 0;
    noInitRam.TM_TestID = 0;
    noInitRam.TM_TestData = 0;
    noInitRam.TM_TSTMODEONSTARTUP = 0;
}

/* ask QM to define the TestManager class -----------------------------------------*/

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::TestManager} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TestManager} .....................................................*/
/*.${AOs::TestManager::SM} .................................................*/
static QState TestManager_initial(TestManager * const me, void const * const par) {
    /*.${AOs::TestManager::SM::initial} */
    QEVENT_TEST_MSG *pTestEvt;
    GetTestManagerNoinitData(&TM_NoinitData);
    if (TM_ONSTARTUP == TM_NoinitData.TM_OnStarup){
        pTestEvt = AO_EvtNew(REQ_TEST_SIG , sizeof(QEVENT_TEST_MSG));
        pTestEvt->size = sizeof(TM_NoinitData.Testdata);
        pTestEvt->RxKey = TM_NoinitData.Key;
        pTestEvt->TestID = TM_NoinitData.TestID;
        memcpy (pTestEvt->Data, &TM_NoinitData.Testdata, pTestEvt->size);
        AO_Post(AO_TestManager,&pTestEvt->Event,NULL);
        Log(TST, "TestManager: TestMode request on startup");
    }

    return Q_TRAN(&TestManager_Idle);
}

/**
 * \brief   This is the startup state for the TestManager Active Object
 *
 * \details This state TaskManager waits for REQ_TEST event
 *   Upon receiving the event authentication is performed to check if the tester is valid.
 *    If the Authentication is passed then the TestMode is activated and state is transitioned to Active
 *
 * \param   me - Pointer to local data store
 * \param   e  - Pointer to present event
 *
 * \return  State transition status: Q_HANDLED(), Q_UNHANDLED(), Q_TRAN(), Q_SUPER()
 *
 * ========================================================================== */
/*.${AOs::TestManager::SM::Idle} ...........................................*/
static QState TestManager_Idle(TestManager * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::TestManager::SM::Idle::REQ_TEST} */
        case REQ_TEST_SIG: {
            QEVENT_TEST_MSG *pInfo = (QEVENT_TEST_MSG *)e;
            TM_TestID = pInfo->TestID;
            /*.${AOs::TestManager::SM::Idle::REQ_TEST::[AuthenticationPass]} */
            if ((pInfo->RxKey == TM_CalculateKey()) || (TM_ONSTARTUP == TM_NoinitData.TM_OnStarup)) {
                /* Authentication pass indicating connection to a valid tester */
                memcpy(&TM_TestData,pInfo->Data,pInfo->size);


                /// \todo 05/26/2022 BS: Send Response packet
                Log(TST, "TestManager: TestMode activated");
                status_ = Q_TRAN(&TestManager_Active);
            }
            /*.${AOs::TestManager::SM::Idle::REQ_TEST::[AuthenticatonFail]} */
            else {
                /* Recieved key did not match the calculated key*/

                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * \brief   This is the running state for the TestManager Active Object
 *
 * \details The TestManager object handles the execution
 *    of requested test
 *    The TestMode is exited after a timeout by performing a Soft Reset
 *
 * \param   me - Pointer to local data store
 * \param   e  - Pointer to present event
 *
 * \return  State transition status: Q_HANDLED(), Q_UNHANDLED(), Q_TRAN(), Q_SUPER()
 *
 * ========================================================================== */
/*.${AOs::TestManager::SM::Active} .........................................*/
static QState TestManager_Active(TestManager * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::TestManager::SM::Active} */
        case Q_ENTRY_SIG: {
            /* Start Test mode timeout timer */
            AO_TimerArm(&me->TMTimer, TM_TIMEOUT_TIME_MS, 0);
            TestModeActive = true;
            SetSystemStatus(SYSTEM_STATUS_TESTMODE);

            TM_Hook(HOOK_TM, NULL);
            if(TC_KEYSIMULATION == TM_TestID )
            {
                AO_TimerArm(&me->TMKeyHoldTmr, TM_TestData.KEYDATA.KeySeqDelay, TM_TestData.KEYDATA.KeySeqDelay);
            }
            else if(TC_MEMORY_FALUT_FLASH_INEGRITY == TM_TestID )
            {
                AO_TimerRearm(&me->TMTimer, TM_TIMEOUT_FLASH_INTEGRITY_CHECK);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TestManager::SM::Active::TM_TIMEOUT} */
        case TM_TIMEOUT_SIG: {
            /* Test Mode time out, perform a soft reset */
            Log(TST, "TestManager: TestMode Timeout, performing soft reset");
            TestModeActive = false;
            ClearSystemStatus();
            OSTimeDly(MSEC_50); // delay to ensure logging happens
            SoftReset();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::TestManager::SM::Active::REQ_TEST} */
        case REQ_TEST_SIG: {
            QEVENT_TEST_MSG *pInfo = (QEVENT_TEST_MSG *)e;

            /*.${AOs::TestManager::SM::Active::REQ_TEST::[AuthenticationPass]} */
            if (((TM_TestID == pInfo->TestID) && (pInfo->RxKey == TM_CalculateKey()))) {
                /* Authentication pass indicating connection to a valid tester */
                memcpy(&TM_TestData,pInfo->Data,pInfo->size);
                AO_TimerDisarm(&me->TMTimer);
                AO_TimerDisarm(&me->TMKeyHoldTmr);
                /// \todo 05/26/2022 BS: Send Response packet
                Log(TST, "TestManager: Subsequent test command accepted");
                status_ = Q_TRAN(&TestManager_Active);
            }
            /*.${AOs::TestManager::SM::Active::REQ_TEST::[AuthenticatonFail]} */
            else {
                /* Received key did not match the calculated key or
                TestID is different from the TestID in ongoing Test sesssion*/
                Log(TST, "TestManager: subsequent test commands not accepted");
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::TestManager::SM::Active::TM_KEYTIMEOUT} */
        case TM_KEYTIMEOUT_SIG: {
            SeqCount++;
            if(SeqCount >= TM_TestData.KEYDATA.KeySeqCount)
            {
                SeqCount = TM_TestData.KEYDATA.KeySeqCount-1;
                AO_TimerDisarm(&me->TMKeyHoldTmr);
                KeySimEnd = true;
            }
            WakeupPinCallback = L2_GpioGetPinConfig(GPIO_uP_PORT_C,GPIO_PIN_03);
            if(WakeupPinCallback != NULL)
            {
                WakeupPinCallback();
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::TestManager} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/******************************************************************************/
/*                             Global Function(s)                             */
/******************************************************************************/
/* ========================================================================== */
/**
 * \brief   Hook function
 *
 * \details The function is called from various instances of SW to execute the testcode
 *
 * \param   Id  - HOOKID
 *
 * \param   *pData - void pointer for the incoming data used by the testmanager
 *
 * \return  None
 *
 * ========================================================================== */
void TM_Hook(HOOKID Id, void *pData)
{
    do
    {
        BREAK_IF((!TestModeActive) || (!GetSystemStatus(SYSTEM_STATUS_TESTMODE)));

        if ( TestCaseIFTable[TM_TestID].TestCaseID != TM_TestID){
            Log(TST, "TestManager: Error in TestCaseIFTable, TestID dosen't match");
            break;
        }
        if(NULL != TestCaseIFTable[TM_TestID].TestCaseInterface)
        {
            TestCaseIFTable[TM_TestID].TestCaseInterface( pData, &TM_TestData, Id);
        }
    } while(false);
}

/*.$define${AOs::TestManagerCtor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::TestManagerCtor} .................................................*/
void TestManagerCtor(void) {
    TestManager *me = (TestManager *)AO_TestManager;

    AO_TimerCtor(&me->TMTimer, &me->super, TM_TIMEOUT_SIG);  // Build timer
    AO_TimerCtor(&me->TMKeyHoldTmr, &me->super, TM_KEYTIMEOUT_SIG);  // Build timer

    AO_Start(AO_TestManager,                             // Pointer to QActive object (AO)
             Q_STATE_CAST(&TestManager_initial),         // Pointer to initial transition
             TASK_PRIORITY_TM,                  // Task priority
             TMEventQueue,                      // Pointer to event queue
             TM_EVQ_SIZE,                       // Size of event queue (in entries) This could be Q_DIM(MotorDevStubs_queueSto
             TMStack,                           // Pointer to stack (bottom)
             TM_STACK_SIZE,                     // Stack size This could be Q_TIM(MotorDevStubs
             NULL,                                  // Pointer to object specific initialization parameters
             AOname);                               // Pointer to name of active object
}
/*.$enddef${AOs::TestManagerCtor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/**
 * \}
 */

#ifdef __cplusplus  /* header compatible with C++ project */
}
#endif