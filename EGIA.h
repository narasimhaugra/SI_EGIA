/*.$file${..\Source::EGIA.h} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: EGIA.qm
* File:  ${..\Source::EGIA.h}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-SP-170817A
* Issued to   : Covidien LP
* Framework(s): qpc
* Support ends: 2022-08-17
* Product(s)  :
* Signia Powered Stapler
*/
/*.$endhead${..\Source::EGIA.h} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifndef EGIA_H
#define EGIA_H

#ifdef __cplusplus  /* header compatible with C++ project */
extern "C"
{
#endif

/* ========================================================================== */
/**
 * \brief   Header file for EGIA superstate (part of App AO)
 *
 * \details Global defines and prototypes defined here.
 *
 * \copyright 2021 Covidien - Surgical Innovations. All Rights Reserved.
 *
 * \file    EGIA.h
 *
 * ========================================================================== */
/******************************************************************************/
/*                             Include                                        */
/******************************************************************************/
#include "Common.h"
#include "Signia_Motor.h"

/******************************************************************************/
/*                             Global Define(s) (Macros)                      */
/******************************************************************************/
#define ME ((Handle *)me)           ///< Cast me pointer to parent type

/// \todo 08/09/2021 DAZ - These values need to be adjusted. Note unimplemented items

/*
Unimplemented:
  Sled detect.
  AFT - Artic Angle Impact on Firing (What is this? Positions, force?)
  Enhanced Endstop Detection (or ordinary endstop detection)
  Cardinal zones
  Artic/Clamp compensation (Adjust clamp position due to articulation angle)

Artic Dimensions (without backlash)
Ticks from hard stop to center = 10.5 * 300
Ticks from hard stop to "home" position (no backlash) = 2 * 300
Ticks from center to full left artic = 9.5 * 300
Ticks from center to full right artic = 9.5 * 300
Ticks for maximum rotate = 4.35 * 300
Ticks for full clamp (from hardstop) = 11 * 300
Ticks for fire rod backlash = 0.95 * 300
Ticks for artic backlash = 0.95 * 300? (Use same value as fire rod for now)

*/
#define P_ARTIC_STOP_SIG            (P_MOTOR_0_STOP_INFO_SIG)  /// Motor0 stop signal
#define P_FIRE_STOP_SIG             (P_MOTOR_1_STOP_INFO_SIG)  /// Motor1 stop signal
#define P_ROTATE_STOP_SIG           (P_MOTOR_2_STOP_INFO_SIG)  /// Motor2 stop signal

#define EGIA_TIMEOUT_2_SEC          (2000u)                    /// EGIA startup timeout 2sec
#define EGIA_TIMEOUT_1_SEC          (1000u)                    /// Tone delay
#define TIME_DELAY_500              (500u)                     /// Tone play periodicity
#define EGIA_TIMEOUT_5_SEC          (5000u)                    /// EGIA Cartridge and Reload Check timeout
#define EGIA_TIMEOUT_3_SEC          (3000u)                    /// EGIA startup timeout 3sec
#define EGIA_TIMEOUT_6_SEC          (6000u)                    /// EGIA timeout for Emergency retraction handling
#define EGIA_TIMEOUT_500_MSEC       (500u)                     /// EGIA Timeout before clamptest
#define EGIA_TIMEOUT_1500_MSEC      (MSEC_500 * 3)
#define EGIA_TIMEOUT_3500_MSEC      (MSEC_500 * 7)

#define TIME_DELAY_100              (100u)                     /// Time Delay for Motor Start function
#define TIME_DELAY_200              (200u)                     /// Time Delay for Motor Start function
#define TIME_DELAY_30               (30u)                      /// Time Delay for Motor Start function
#define REPORT_INTERVAL             (0u)                       /// Report Interval for Motor Start function

#define TICKS_PER_TURN              (300)                      /// Motor ticks / shaft turn (This should be defined in motor...)
#define ARTIC_BACKLASH_TICKS        (0.95 * TICKS_PER_TURN)    ///< Estimated
#define FIRE_BACKLASH_TICKS         (0.95 * TICKS_PER_TURN)

#define ARTIC_SHAFT_RPM             (300u)        ///< Shaft RPM of motor /// \todo 08/09/2021 DAZ - Was 35. PWM too small for move
#define ARTIC_SHAFT_RPM_CLAMPED     (180u)        ///< Shaft RPM of motor while fully clamped, 60% of ARTIC_SHAFT_RPM
#define ARTIC_CALIB_SHAFT_RPM       (800u)        ///< Shaft RPM of motor during Calibration

#define ARTIC_SHORTDISTAL_POS       (10000)       ///< Position to move toward during Short distal jog
#define ARTIC_SHORTDISTAL_TIMEOUT   (200u)        ///< Max amount of time for motor to move during Shordistal

#define ARTIC_HARDSTOP_POS          (-22 * TICKS_PER_TURN)       ///< Target position to seek during Hardstop
#define ARTIC_CAL_HARDSTOP_POS      (-10.5 * TICKS_PER_TURN)     ///< Artic hard stop position (full left)
#define ARTIC_CAL_HARDSTOP_TIMEOUT  (8000u)                      ///< Max amount of time for motor to move during Hardstop
#define ARTIC_CAL_CURRENTLIMIT      (0x1ffu)                     ///< Current Limit for artic motor cal
#define ARTIC_CAL_CURRENTTRIP       (4000u)                      ///< Current trip for artic motor cal

#define ARTIC_HOMING_POS            (0 + ARTIC_BACKLASH_TICKS)   ///< Position to move to during Homing (Center)
#define ARTIC_HOMING_TIMEOUT        (6000u)                      ///< Max amount of time for motor to move during Homing
#define ARTIC_HOMING_CURRENTTRIP    (8000u)                      ///< Current trip for artic home (A bit higher than for hardstop)
#define ARTIC_HOMING_CURRENTLIMIT   (0x1ffu)                     ///< Current limit for homing

#define ARTIC_CTR_FROM_LEFT         (ARTIC_HOMING_POS)                               ///< Artic Center position when moving from left of center
#define ARTIC_CTR_FROM_RIGHT        (0)                                              ///< Artic Center position when moving from right of center
#define ARTIC_FULL_RIGHT_POS        ((-9.5 * TICKS_PER_TURN) + ARTIC_BACKLASH_TICKS) ///< Artic full Right position (including backlash)
#define ARTIC_FULL_LEFT_POS         (9.5 * TICKS_PER_TURN)                           ///< Artic full Left position
#define ARTIC_ERROR                 (20)
#define ARTIC_CENTER                (0)


#define ARTIC_TIMEOUT               (8000u)                      ///< Max amount of time for motor to move during left end pos
#define ARTIC_CURRENTTRIP           (20000u)                      ///< Current trip for artic left end
#define ARTIC_CURRENTLIMIT          (0x1ffu)                     ///< Current limit for Left Direction

/// \todo 08/10/2021 DAZ - Fire rod position values are based on 60mm dumb reload. Actual fire values will be read from smart reloads.
/// \todo 08/10/2021 DAZ - Fire rod fire position is estimated since end stop detection is not yet available.

#define FIRE_SHAFT_RPM              (200u)                    ///< Shaft RPM of motor /// \todo 08/09/2021 DAZ - Was 35. PWM too small for move
#define FIRE_CALIB_SHAFT_RPM        (800u)                    ///< Shaft RPM of motor during Calibration

#define FIRE_HARDSTOP_POS           (150 * TICKS_PER_TURN)    ///< Target position to seek during Hardstop (60mm)
#define FIRE_CAL_HARDSTOP_POS       (0)                       ///< Fire rod hard stop position
#define FIRE_CAL_HARDSTOP_TIMEOUT   (30000u)                  ///< Max amount of time for motor to move during Hardstop
#define FIRE_CAL_CURRENTLIMIT       (0x1ffu)                  ///< Current Limit for fire hard stop
#define FIRE_CAL_CURRENTTRIP        (4000u)                   ///< Current trip for fire hard stop

#define FIRE_HOMING_POS             (-((2 * TICKS_PER_TURN) + FIRE_BACKLASH_TICKS)) ///< Position to move to for home position (fully open)
#define FIRE_HOMING_TIMEOUT         (6000u)                                         ///< Max amount of time for motor to move during Homing
#define FIRE_HOMING_CURRENTLIMIT    (0x1ffu)                                        ///< Current limit for fire home
#define FIRE_HOMING_CURRENTTRIP     (8000u)                                         ///< Current trip for fire home (A bit higher than for hardstop)


#define FIRE_FULL_OPEN_POS          (-(2 * TICKS_PER_TURN))                            ///< Position for full open (no backlash)
#define FIRE_FULL_CLOSE_POS         (-((13 * TICKS_PER_TURN) + FIRE_BACKLASH_TICKS))   ///< Position for full close
#define FIRE_RETRACT_POS            (-(13 * TICKS_PER_TURN))                           ///< Position for retract (no backlash)
#define FIRE_FULL_FIRE_POS          (-((60 * TICKS_PER_TURN) + FIRE_BACKLASH_TICKS))  ///< Position for 60mm full fire (est)
#define CLAMP_MIDPOINT              ((FIRE_FULL_OPEN_POS + FIRE_FULL_CLOSE_POS) / 2)  ///< Position Midpoint of Open and Close for Firerod
/// \todo 08/20/2021 NP - Need to be adjusted in final code
// Clamptest and Clamping
#define FIRE_MOTOR_SHAFT_RETRACT_RPM  (1500u)   	///< firing motor shaft rpm during retraction
#define FIRE_MOTOR_SHAFT_RPM          (500u)    	///< firing motor shaft rpm
#define FIRE_MOTOR_CURRLIMIT          (0x1ffu)  	///< Current Limit for firing motor
#define FIRE_MOTOR_HARDSTOP_TIMEOUT   (60000u)		///< Max amount of time for motor to move during Distal Hardstop
#define FIRE_MOTOR_HOMING_TIMEOUT     (6000u)     	///< Max amount of time for motor to move during Homing (Proximal)
#define FIRE_MOTOR_CURRTRIP_6000      (6000u)     	///< Current trip for fire home (A bit higher than for hardstop)
#define FIRE_MOTOR_CURRTRIP_7080      (7080u)     	///< Current trip for fire home (A bit higher than for hardstop)


#define FIRE_LAZYJAW_TURNS            (1.5f)        ///< Number of turns we want to back off of the home position for lazyjaw
#define FIRE_LAZYJAW_TIMEOUT          (2000u)       ///< Max amount of time for motor to move for lazyjaw


#define ROTATE_MOTOR_SHAFT_RPM              (150u)        ///< ROTATE MOTOR RPM
#define ROTATE_MOTOR_CURRTRIP               (2500u)       ///< Current trip for rotate motor. Note: As per requirement this shoudl be 2500. With 2500, always facing Excessive Current
#define EGIA_ROTATE_TURNS                   (4.4)         ///< Turns to Rotate before stopping. Note: Taken From Legacy
#define ROTATE_MOTOR_ONE_EIGHTY_DEGREE_CW   (-(EGIA_ROTATE_TURNS * TICKS_PER_TURN ))   ///< Position in Clockwise Direction
#define ROTATE_MOTOR_ONE_EIGHTY_DEGREE_CCW  ( (EGIA_ROTATE_TURNS*TICKS_PER_TURN   ))   ///< Position in Anti-Clockwise Direction
#define ROTATE_MOTOR_ROTATION_TIMEOUT       (SEC_30)                                   ///< Rotation Timeout. Note: Taken From Legacy
#define ROTATE_MOTOR_ROTATION_CURRENTLIMIT  (0x1ffu)                                   ///< Current Limiting for Rotation Motor. Take from other Motors
#define FIRE_RETRACT_CURRLIMIT        (0x1ffu)                                          ///< Current Limit while retracting firing motor-318721

#define FIRING_GREENLED_TOGGLE_TIME   (500u)
#define FIRE_MOTOR_FIRING_TIMEOUT     (65535u)     ///< Max amount of time for motor to move during Homing (Proximal)
#define FIRING_SCREEN_UPDATE_TIME            (300u)

/// \todo 08/16/2021 NP - Reload length to be used for handling Screens-to be relooked
#define RELOAD_LEN_30               (30u)
#define RELOAD_LEN_45               (45u)
#define RELOAD_LEN_60               (60u)

#define BATTERY_RSOC_LOW            (25u)         ///< 9% < Battery <= 25% inicates Low Battery
#define BATTERY_RSOC_INSUFFICIENT   (9u)          ///< Battery <= 9% indicates Insufficient Battery

#define FIRE_FULLOPEN_CLOSE         (-700)

#define EGIA_CLAMPCYCLE_CLAMPTEST_DONE   (0x01)     // Clamp Cycle - Clamptest done
#define EGIA_CLAMPCYCLE_LAZYJAW_PROXIMAL (0x02)     // Clamp Cycle - Firing motor is moved to lazyjaw position
#define EGIA_CLAMPCYCLE_LAZYJAW_DISTAL   (0x03)     // Clamp Cycle - Firing motor backs off of lazyjaw position
#define EGIA_CLAMPCYCLE_CLAMPING_CLOSE   (0x04)     // Clamp Cycle - Reload is Clamped
#define EGIA_CLAMPCYCLE_CLAMPING_OPEN    (0x05)     // Clamp Cycle - Reload is Opened
#define EGIA_CLAMPCYCLE_DONE             (0x06)     // Clamp Cycle - Done
#define EGIA_CLAMPCYCLE_CLAMPTEST_FAIL   (0x00)     // Clamp Cycle - ClampTest Fail

#define CLAMP_TEST_MIN_DELTA_COUNTS      (5u)       // minimum difference of strain gauge reading in A/D counts between close and open clamp test
#define LOG_FIREMOTOR_COUNT              (10u)      // number of safety led toggles between firing motor position logging

#define DeviceMem_EEPROMRead(x,y,z) {x.pHandle->Read(); memcpy (&z, (uint8_t *) &x.pHandle->Data.y, sizeof (x.pHandle->Data.y));}
#define DeviceMem_READStatus(x,s)   { s = x.pHandle->Status; }
#define DeviceMem_READSULU(x, y)  {MemoryLayoutEgiaSulu_Ver2 *pReloadData; pReloadData = (MemoryLayoutEgiaSulu_Ver2 *)&pMe->Reload.pHandle->Data;memcpy (&y, (uint8_t *) &pReloadData->x, sizeof (y));}
#define DeviceMem_READMULU(x, y)  {MemoryLayoutEgiaMulu_Ver2 *pReloadData; pReloadData = (MemoryLayoutEgiaMulu_Ver2 *)&pMe->Reload.pHandle->Data;memcpy (&y, (uint8_t *) &pReloadData->x, sizeof (y));}

/// \todo 03/31/2022 NP -Handle Fire Count update Retry Timer to be relooked
#define FIRE_COUNT_UPDATE_TIME      (1000u)       // Handle Fire Count update Retry Timer
#define FIRE_COUNT_UPDATE_DEFAULT   (0x00)        // Handle Fire Count - Default Value
#define FIRE_COUNT_UPDATE_SUCCESS   (0x01)        // Handle Fire Count - Updated Successfully
#define FIRE_COUNT_UPDATE_FAILED    (0x02)        // Handle Fire Count - Update Failed

#define P_OPEN_PRESS_SIG              (P_TOGGLE_UP_PRESS_SIG)       // Toggle Up Press
#define P_OPEN_RELEASE_SIG            (P_TOGGLE_UP_RELEASE_SIG)     // Toggle Up Release
#define P_FIRE_PRESS_SIG              (P_TOGGLE_DOWN_PRESS_SIG)     // Toggle Down Press
#define P_FIRE_RELEASE_SIG            (P_TOGGLE_DOWN_RELEASE_SIG)   // Toggle Down Release
#define NO_OF_RELOAD_TYPES            (0x3u)                        ///< Number of Reload Types
#define CARTRIDGE_NOT_USED            (0u)                          ///< Fire count zero for unused cartridge
#define CARTRIDGE_USED                (1u)                          ///< Used Cartridge has Fire count one (or greater)

//DEFAULTS for parameters to be read from adapter data flash (EGIA)
#define STRAIN_GAUGE_GAIN_DEFAULT         (1.0f)
#define STRAIN_GAUGE_OFFSET_DEFAULT       (0.0f)
#define STRAIN_GAUGE_2ND_ORDER_DEFAULT    (0.0f)      //no second order term (0) for default

#define EGIA_FIRE_BL_CAL_TURNS     (0.95f)  // Firerod Cal Backlash turns
#define EGIA_ARTIC_CAL_TURNS       (10.5f)  // Artic Calibration turns from hardstop
#define EGIA_FIRE_CAL_TURNS        (2.0f)   // FireRod Calibration turns from hardstop
#define EGIA_ARTIC_LEFT_TURNS      (9.5f)   // Max Turns Left from midpoint
#define EGIA_ARTIC_RIGHT_TURNS     (9.5f)   // Max Turns Right from midpoint
#define EGIA_CLAMP_TURNS           (11.0f)  // Clamp Turns from Calibration Point

#define STRAIN_GAUGE_TARE_LOW_COUNT_DRIFT    (-391.0f)    //tare is checked in counts as per EGIA group request
#define STRAIN_GAUGE_TARE_HIGH_COUNT_DRIFT   (337.0f)     //tare will be checked as deviation from the factory zero counts. factory zero counts is derived from -b/m
#define TARE_COUNT_CEILING                   (1675u)      //SG ADC count max limit of raw count before taring
#define TARE_COUNT_FLOOR                     (2u)         //SG ADC count minimum limit of raw count before taring

#define EGIA_ADC_MAX_COUNT                   (4093u)

#define MAX_SG_COUNT                 (4093u)    ///< Maximum Strain Gauge ADC Count
#define MAX_FORCE_SG                 (133u)     ///< Maximum Force in LBS

#define CLAMPINGFORCE_RANGE_0        (0u)       ///< Clamping Force Range0 - 0
#define CLAMPINGFORCE_RANGE_1        (33u)      ///< Clamping Force Range1 - 33 lbs
#define CLAMPINGFORCE_RANGE_2        (72u)      ///< Clamping Force Range2 - 72 lbs
#define CLAMPINGFORCE_RANGE_3        (133u)     ///< Clamping Force Range3 - 133 lbs

#define FIRINGFORCE_RANGE_0          (0u)      ///< Firing Force Range0 - 0
#define FIRINGFORCE_RANGE_1          (65u)     ///< Firing Force Range1 - 65 lbs
#define FIRINGFORCE_RANGE_2          (80u)     ///< Firing Force Range2 - 80 lbs - ID 318714 (Default)
#define FIRINGFORCE_RANGE_3          (133u)    ///< Firing Force Range3 - 133 lbs

#define FIRING_SPEED_FAST_VALUE      (1348u)   ///< Firing Speed FAST
#define FIRING_SPEED_MEDIUM_VALUE    (755u)    ///< Firing Speed MEDIUM
#define FIRING_SPEED_SLOW_VALUE      (377u)    ///< Firing Speed SLOW

#define LOW_BATT_FIRINGLIMIT         (2u)      ///< Allowed 2-Firings in LOW Battery condition
#define VALUE_100                    (100u)    ///< Value 100
#define MOTOR_POS_GET_TIME           (10u)     ///< To get the time interval for motor position read
#define MAX_RETRY                    (3u)      ///< Retry Count for SG Data Lost Check
#define MULTIPLY_TWO                 (2u)      ///< For +/- Check, multifying twice for current motor position
#define EGIA_BAT_INSUFFICIENT   (9u)    ///< RSOC 9%
#define EGIA_BAT_LOW            (25)    ///< RSOC 25%
#define BAT_COMM_FAULT          (4u)    ///< Battery communication fault code

#define SCREEN_INDEX            (4u)
#define PERCENT_VALUE_ZONE1     (0u)
#define PERCENT_VALUE_ZONE2     (1u)
#define PERCENT_VALUE_ZONE3     (2u)
#define PERCENT_VALUE_DEFAULT   (0xFFu)
#define PERCENT_VALUE_RANGE1    (33u)
#define PERCENT_VALUE_RANGE2    (66u)
#define PERCENT_VALUE_RANGE3    (100u)

#define NO_CARTRIDGE            (0xFF)
#define MAX_PERCENT             (2u)
#define NOT_USED                (0xFF)
#define CARTRIDGE_CHECK_TIME    (2500u)

#define ADAPTER_RESTART_DELAY_IN_MS             (100u)
#define ADAPTER_COMMAND_RESPONSE_NODELAY        (0u)
#define ADAPTER_ENTERMAIN_DELAY_IN_MS           (200u)
/******************************************************************************/
/*                             Global Type(s) / Function Prototypes           */
/******************************************************************************/
// EGIA specific data

/// \note All EGIA local variables must be declared here, NOT in QM! This typedef becomes
///       part of a union in the App model which defines the local data structure and allocates
///       storage for it. All the variables declared below are part of the egia structure of
///       the Adapter union. Thus access to these variables is via (App *)me->Adapter.egia.variable_name.
///       For convenience, the user may declare a pointer to this union member.
///       (ie. APP_EGIA_DATA *pEgia = &me->Adapter.egia)

/* Transition to be allowed
   COMMANDED ==> START
   COMMANDED ==> STOPPED
   START     ==> STOPPED
   START     ==> PAUSED
   PAUSED    ==> RESUME
   PAUSED    ==> STOPPED
   RESUME    ==> STOPPED
   STOPPED   ==> COMMANDED
*/

typedef enum                               /// ROTATION STATES
{
    MOTOR_START,                           /// ROTATION IS IN PROGRESS
    MOTOR_STOP                             /// ROTATION STOPPED, LATERAL KEY is Rleased
} MOTOR_COMMAND;

typedef enum                               /// CALIBRATION FAILED STATUS
{
   CALIBRATION_NOTSTARTED,                 /// Calibration Not Started
   CALIBRATION_INPROGRESS,                 /// Calibration In Progress
   CALIBRATION_FAILED_MOTOR,               /// Calibration Failed Due to Motor Not in Stop position
   CALIBRATION_FAILED_FORCETARE,           /// Calibration Failed Due to Adapter Force Tare
   CALIBRATION_FAILED_RELOADCONNECTED,     /// Calibration Failed due to Reload Connected
   CALIBRATION_SUCCESS                     /// Calibration Success
} CALIBRATION_STATE;

typedef enum                                ///< Retraction Status
{
    RETRACTION_NOTSTARTED,                  ///< Retraction Not Started
    RETRACTION_INPROGRESS,                  ///< Retraction In Progress
    RETRACTION_FAILED,                      ///< Retraction Failed
    RETRACTION_SUCCESS,                     ///< Retraction Success
    RETRACTION_NOTALLOWED                   ///< Retraction not allowed post Timeout
} RETRACTION_STATE;

typedef enum
{
    FIRINGSPEED_FAST,
    FIRINGSPEED_MEDIUM,
    FIRINGSPEED_SLOW,
    FIRINGSPEED_LAST
} FIRINGSPEED;

// Reload Type
typedef enum
{
   RELOAD_NONINTELLIGENT,       ///< Non Intelligent Reload
   RELOAD_SULUINTELLIGENT,      ///< Intelligent SULU Reload
   RELOAD_MULUINTELLIGENT,      ///< Intelligent MULU Reload
   RELOAD_UNSUPPORTED,
   RELOAD_NONE
} RELOADTYPE;

///< This structure is used to create Force To Fire Speed table
typedef struct
{
    float32_t  FiringForce;     ///< Firing Force In LBS
    uint16_t   FiringSpeed;     ///< Firing Speed In RPM
} FIREMODE_FORCETOSPEED;

typedef struct                       ///< Firing Info
{
    FIRINGSPEED FiringSpeedState;    ///< Firing Speed active State
    KEY_ID      Key;                 ///< Holds Bottom Rotation key pressed KeyId
    uint8_t     SameKeyCount;        ///< Increments when Bottom Key is Pressed
    int32_t     KeyPressTime;        ///< Captures time instance when Bottom Rotation key is pressed
    bool        FiringInProgress;    ///< True: Fire Motor is Firing, false: Fire Motor is not Firing
} FIRING_INFO;

///< This is the structure will be used by the App to access EGIA Adapter Data Flash
///< the order of parameters below is in order with the flash values. This should not be changed
///< refer to structures FACTORY_STRAINGAUGE_CAL, FACTORY_ADAPTER_CALPARMS, FACTORY_ADAPTER_LOT,
///< FACTORY_ADAPTER_BOARDPARMS, FACTORY_GTIN in L4_AdapterDefn.c
typedef struct
{
    float32_t  Multiplier;
    float32_t  Offset;
    float32_t  SecondOrder;
}STRAINGAUGE_CAL;

typedef struct
{
    float32_t  FirerodBacklashTurns;
    float32_t  FirerodCalTurns;             ///< FireRod Calibration turns from hardstop
    float32_t  ClampTurns;                  ///< Clamp Turns from hardstop
    float32_t  ArticCalTurns;               ///< Artic Calibration turns from hardstop
    float32_t  MaxLeftTurns;                ///< artic max turns left from midpoint
    float32_t  MaxRightTurns;               ///< artic max turns right from midpoint
    float32_t  MaxRotateTurns;              ///< Turns to rotate before stopping
}ADAPTER_CALPARMS;

typedef struct
{
    float32_t  TareDriftHigh;               ///< maximum positive drift allowable to tare off
    float32_t  TareDriftLow;                ///< maximum drift allowable to tare off
    float32_t  ZBCountCeiling;              ///< maximum value for zero pound count (before tare at rod calibration)
    float32_t  ZBCountFloor;                ///< maximum value for zero pound count (before tare at rod calibration)
}ADAPTER_BOARDPARMS;


typedef struct
{
    STRAINGAUGE_CAL    StrainGauge;
    ADAPTER_CALPARMS   CalibParam;
    int8_t            Lot_number[ADAPTER_LOT_CHARS];
    ADAPTER_BOARDPARMS BoardParam;
    int8_t               GTIN[GTIN_CHAR_COUNT];
} CALIB_FLASH_CONTENT;

typedef struct
{
    FIRINGSPEED FiringState;                   ///< Firing Speed State: Low, Medium, Fast
    uint16_t FiringRpm;                        ///< Firing Speed
    bool   SGOutOfRangeSet;                    ///< SG Out Of Range handling flag
    uint32_t TotalTicks;                       ///< Total Ticks
    uint32_t StartTicks;                       ///< Start Ticks
    uint8_t FiringPercentageComplete;          ///< Firing completion in Percentage for Progress Bar
    bool    SGLost;                            ///< SG Data Read Lost
} ASA_INFO;

typedef struct
{
    uint8_t ReloadLen;
    uint8_t CartColor;
    uint8_t ClampStatus;
    uint8_t ProcedureCount;
    uint8_t FiringCount;
    uint8_t PercentComplete;
}SCREEN_INFO;

typedef struct                    /// EGIA specific Data
{
    // NOTE: Do not declare any timers here till further notice. DAZ 08/06/2021.
    //       Need to figure out timer construction/destruction. For now, use only
    //       timers declared by App.
    MOTOR_ID      MotorId;
    uint16_t      ShaftRpm;
    int32_t       Ticks;
    uint16_t      Timeout;
    int16_t       CurrentLimit;
    uint16_t      CurrentTrip;
    int16_t       TimeDelay;
    bool          InitCurrent;
    MOTOR_SUPPLY  MotorVoltage;
    PID           Pid;
    uint32_t      ArticCalPosition;
    uint8_t       MidArtic;
    uint16_t      HardstopCl;       /*Hardstop Current Limit */
    uint16_t      ArticSpeed;
    uint32_t      CalTicks;
    uint32_t      BacklashTicks;
    RELOADTYPE    ReloadType;
    uint8_t       ReloadLen;
    DEVICE_ID_ENUM CartridgeLen;               /* Cartridge length */
    uint8_t       ClampCycle;
    bool          Reload_connected;           /* Flag to indicate reload is connected       */
    CALIBRATION_STATE CalibrationStatus;      /* Calibration State. Holds reason for calibration Failure. Used in Re-Calibration, disallows rotation before/during calibration */
    RETRACTION_STATE  RetractionStatus;       /* Retraction State. Used to disallow Calibration during Retraction */
    bool          PerformClampTest;           /* Flag to indicate perform clamp test  */
    bool          SufficientBattery;
    uint16_t      AdapterFiringCounter;
    uint16_t      AdapterFiringLimit;
    uint64_t      AdapterDeviceID;
    uint16_t      AdapterProcedureLimit;
    uint16_t      AdapterProcedureCounter;
    float32_t     BatteryLevel;
    bool          CoefficientsStatus;
    float32_t     CalibrationTareCounts;
    uint8_t       BatCommState;
    SG_FORCE      SGForceClampFullOpen;      /* Strain Gauge Read when Reload Clamp Test is Full Open */
    SG_FORCE      SGForceClampFullClose;     /* Strain Gauge Read when Reload Clamp Test is Full Close*/
    SG_FORCE      SGForce;
    bool          DownKeypress;
    bool          UpKeypress;
    bool          FiringMode;
    bool          MotorStopped;
    bool          RotateAllowed;             /* Is reload rotation allowed? */
    bool          ArticAllowed;              /* Is reload articulation allowed? */
    SWITCH_DATA   PrevSwitch;
    bool          MuluFireCountTestPass;     /* True: MULU RELOAD fire count test passed. FALSE: MULU RELOAD firecount test failed */
    bool          UsedCartridgeTestPass;     /* True: Used Cartridge test passed.         FALSE: Used Cartridge test failed */
    AM_DEVICE_STATUS   PrevOWReloadStatus;   /* Holds previous Reload Status */
    uint8_t       HandleFireCountUpdated;    /* Holds Handle Firing Counter Validation flag */
    uint16_t      PrevHandleFireCounter;     /* Holds Current Firing Counter Value */
    uint16_t      NewHandleFireCounter;      /* Holds Updated Firing Counter Value */
    uint8_t       MULUReloadEOL;
    AUTHENTICATION_STATE ReloadAuthenticated;
    bool          ReloadDeviceWriteStatus;
    AUTHENTICATION_STATE CartridgeAuthenticated;
    FIRING_INFO   FiringInfo;
    uint8_t       AdapterProcCountUpdated;  /* Holds Adapter Procedure Counter Validation flag */
    uint8_t       AdapterFireCountUpdated;  /* Holds Adapter Fire Counter Validation flag */
    uint16_t      PrevAdapterProcCounter;   /* Holds Adapter Current Procedure(Autoclave) Counter Value */
    uint16_t      PrevAdapterFireCounter;   /* Holds Adapter Current Firing Counter Value */
    bool          AdapterTestPass;          /* Adapter Test for Increment Adapter Firing and Autoclave counter */
    CALIB_FLASH_CONTENT CalibParam;
    float32_t     FiringMaxForceRead;       /* Firing Max force Read from SULU/MULU */
    float32_t     FiringForce;
    ASA_INFO      AsaInfo;
    float32_t     MaxClampForce;
    bool          ExcessiveLoad;            /* Allow firing for excessive load condition - false/stop firing - true */
    uint8_t       AdapterErrCause;          /* Reason for adapter error */
    bool          IsCartridgeCompatible;    /* Cartridge Compatible Check flag -true-Comaptible false-incompatible */
    bool          FPGAResetFireMode;        /* FPGA Reset check during FIRE MODE */
    bool          FiringComplete;
    bool          ExtraTimeForReloadCheck;  /* Extra Timeout to check for reload/cartridge connect signal */
    bool          NonIntReloadEOL;          /* Non Intelligent Reload EOL status */
    bool          FullyClamped;             /* Reload fully clamped in Clamptest */
    uint8_t       ReloadCartColor;          /* Intelligent Reload Cartridge color */
    bool          CartridgeColor;
    SCREEN_INFO   ScreenInfo;
    bool          ManualFireModeExit;       /* Safety key press for manual fire exit */
    uint16_t      HandleProcRemaining;      /* Handle Procedure Count Remaining */
    uint16_t      AdapterProcRemaining;     /* Adapter Procedure Count Remaining */
    uint16_t      FiringStateLast;
    MOT_CURTRIP_PROFILE ITripProfile;
    bool          FullyUnClamped;
} APP_EGIA_DATA;

/*.$declare${AOs::EGIA} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

// NOTE: This structure is not used. This model is simply a
//       substate of the Handle model. It's me pointer points
//       to a structure of type Handle, defined in the Handle
//       model. See the structure definition in Handle.qm
//       for the definition for this object.
/*.${AOs::EGIA} ............................................................*/
typedef struct {
/* protected: */
    QActive super;
} EGIA;

/* protected: */
QState EGIA_initial(EGIA * const me, void const * const par);

/* ========================================================================== */
QState EGIA_Operate(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_Calibrate(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_ArticCal_Hardstop(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_ArticCal_Homing(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_FiringCalibration_Homing(EGIA * const me, QEvt const * const e);

/**
 *
 *  \brief    Retract the RELOAD by driving the Firing Shaft proximally until it stops at its mechanical limit
 *
 *  \details  This is the first step in Retracting a Reload Automatically. Motor 1 is rotated till the hardstop
 *            position is reached.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
QState EGIA_AutomaticRetract_ProximalEndStop(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_ArticCal_ShortDistal(EGIA * const me, QEvt const * const e);

/**
 *
 *  \brief        Drive the Firing Shaft distally to its home position
 *
 *  \details      This is the second step during Automatic Retraction. Motor 1 will be rotated till the homing
 *                position is reached
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
QState EGIA_AutomaticRetract_DistallyHoming(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_FiringCalibration_Hardstop(EGIA * const me, QEvt const * const e);

/**
 *
 *  \brief        Firing Shaft distally to its home position
 *
 *  \details      This is the last step during Automatic Retraction.
 *
 *
 *  \param    me - pointer to extended state variables of the EGIA object ..
 *  \param    e   - pointer to event signal that caused state machine to execute
 *
 *  \return   QSTATE
 *
 ============================================================================== */
QState EGIA_AutomaticRetract_Completed(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_Clamptest(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_Clamptest_Full_Close(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_Clamptest_Full_Open(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_Lazyjaw_Distal(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_Lazyjaw_Proximal(EGIA * const me, QEvt const * const e);
QState EGIA_Firing_Retract(EGIA * const me, QEvt const * const e);
QState EGIA_Firing(EGIA * const me, QEvt const * const e);
QState EGIA_PostFire(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_Clamping(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_PreFire(EGIA * const me, QEvt const * const e);

/* ========================================================================== */
QState EGIA_FireIdle(EGIA * const me, QEvt const * const e);
QState EGIA_Adapter_Error(EGIA * const me, QEvt const * const e);
/*.$enddecl${AOs::EGIA} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/******************************************************************************/
/*                             Global Constant Declaration(s)                 */
/******************************************************************************/

/******************************************************************************/
/*                             Global Variable Declaration(s)                 */
/******************************************************************************/

/******************************************************************************/
/*                             Global Function Prototype(s)                   */
/******************************************************************************/

extern APP_EGIA_DATA * EGIA_GetDataPtr(void);

#ifdef __cplusplus  /* header compatible with C++ project */
}
#endif

#endif