/*.$file${.::Handle.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: Handle.qm
* File:  ${.::Handle.c}
*
* This code has been generated by QM 5.1.0 <www.state-machine.com/qm/>.
* DO NOT EDIT SECTIONS BETWEEN THE COMMENTS "$...vvv".."$end...^^^".
* All your changes in these sections will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-SP-170817A
* Issued to   : Covidien LP
* Framework(s): qpc
* Support ends: 2022-08-17
* Product(s)  :
* Signia Powered Stapler
*/
/*.$endhead${.::Handle.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#ifdef __cplusplus  /* header compatible with C++ project */
extern "C"
{
#endif

/* ========================================================================== */
/**
 * \addtogroup Handle
 * \{
 *
 * \brief   This is the application Active Object.
 *
 * \details This file provides the AO data and task definition and the top level
 *          state machine. It provides detection logic and switching to the appropriate
 *          substate, which is implemented in an external model.
 *
 * \copyright 2021 Covidien - Surgical Innovations. All Rights Reserved.
 *
 * \file    Handle.c
 *
 * ========================================================================== */
/******************************************************************************/
/*                             Include                                        */
/******************************************************************************/
#include "Common.h"
#include "Handle.h"
#include "Signia.h"
#include "HandleStubs.h"
#include "HandleUtil.h"
#include "Screen_AdapterCheck.h"
#include "Signia_ChargerManager.h"
#include "L3_GpioCtrl.h"
#include "BackgroundDiagTask.h"
#include "Screen_AdapterUnsupported.h"
#include "L4_DisplayManager.h"
/******************************************************************************/
/*                             Global Constant Definitions(s)                 */
/******************************************************************************/

/******************************************************************************/
/*                             Local Define(s) (Macros)                       */
/******************************************************************************/
#define HANDLE_STACK_SIZE                               (512u)     // AO stack size
#define HANDLE_EVQ_SIZE                                 (10u)      // AO event queue size
#define HANDLE_DEFER_EVQ_SIZE                           (10u)      // Defer Queue size
#define BANNER_DISPLAY_TIME                             (SEC_5)    // Banner display time
#define CLAMSHELL_ONEWIRE_SHORT_TIMEOUT                 (SEC_3)    // Clamshell 1W short, handle to wait before goes sleep

#define LOG_BATT_INFO(m)  Log(DBG, "Battery RSOC: %0.1f%, Voltage: %dmV, Current: %dmA, Temp: %.1fC",\
                            m->Info.BatteryLevel, m->Info.BatteryVoltage,\
                            m->Info.BatteryCurrent, m->Info.BatteryTemperature)

#define ROTATION_CONFIG_TIMEOUT                 (3000u) // Rotation screen timeout time
#define ROTATION_CONFIG_2SEC_TIMEOUT            (2000u) // Rotation screen activation/deactivation time of 2sec
#define ROTATION_CONFIG_SCREEN_COUNTDOWNTIME    (1000u) // Rotation config screen countdown time of 1sec

// Enable for the motor fault test
//#define MOTOR_FAULT  (1u)

/******************************************************************************/
/*                             Global Variable Definitions(s)                 */
/******************************************************************************/
OS_STK      HandleStack[HANDLE_STACK_SIZE + MEMORY_FENCE_SIZE_DWORDS];          // Stack for AO
/******************************************************************************/
/*                    Local Type Definition(s)                                */
/******************************************************************************/

/******************************************************************************/
/*                             Local Variable Definition(s)                   */
/******************************************************************************/
/* Instantiate the Handle active object ------------------------------------*/
static Handle LocalHandle;                                  // Local data area
QActive * const AO_Handle = &LocalHandle.super;             // Opaque pointer to Handle Active Object
static QEvt const *HandleEventQueue[HANDLE_EVQ_SIZE];       // Event Queue for AO
static QEvt const *HandleDeferQueue[HANDLE_DEFER_EVQ_SIZE]; // Event Deferred Queue for AO
static uint8_t    *AOname = "Handle";                       // Active Object name
static bool DisplayAlternateScreen;                         // Display alternate Screen
const QEvt RetryTimeoutSig = { RETRY_TIMEOUT_SIG, 0, 0 };   /* RetryTimeoutSig signal  */
static uint32_t CompatAdapterScreenDuration = ADAPT_COMPAT_SCREEN_DUR_ON_STARTUP; /* Used to Screen to show during Startup/run time */
/// \todo 5/26/2022 CPK Remove FIX_ROTATION_CONFIG  once Rotation Key Pattern updates are available
#ifdef FIX_ROTATION_CONFIG
static QEVENT_KEY *pRotKeyEvent;                            /* Rotation Key Event */
#endif
static bool InsuffBattery = false;                          // Insufficient Battery condition
static bool LowBattery = false;                             // Low Battery Condition

/******************************************************************************/
/*                             Local Function Prototype(s)                    */
/******************************************************************************/

/******************************************************************************/
/*                             Local Function(s)                              */
/******************************************************************************/

/* Ask QM to define the Handle class (State machine) -----------------------*/

#pragma cstat_disable ="PTR-null-cmp-bef"
/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 680U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.8.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::Handle} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::Handle} ..........................................................*/
/*.${AOs::Handle::SM} ......................................................*/
QState Handle_initial(Handle * const me, void const * const par) {
    /*.${AOs::Handle::SM::initial} */
    // Handle object initializations
    //
    // Create timer attribute
    // Initialize Adapter, Clamshell, Reload, Cartridge conditions

    AO_Subscribe(AO_Handle, P_ADAPTER_CONNECTED_SIG);
    AO_Subscribe(AO_Handle, P_ADAPTER_REMOVED_SIG);
    AO_Subscribe(AO_Handle, P_CLAMSHELL_CONNECTED_SIG);
    AO_Subscribe(AO_Handle, P_CLAMSHELL_REMOVED_SIG);
    AO_Subscribe(AO_Handle, P_RELOAD_CONNECTED_SIG);
    AO_Subscribe(AO_Handle, P_RELOAD_REMOVED_SIG);
    AO_Subscribe(AO_Handle, P_EGIA_RELOAD_CONNECTED_SIG);
    AO_Subscribe(AO_Handle, P_EGIA_RELOAD_REMOVED_SIG);
    AO_Subscribe(AO_Handle, P_CARTRIDGE_CONNECTED_SIG);
    AO_Subscribe(AO_Handle, P_CARTRIDGE_REMOVED_SIG);
    AO_Subscribe(AO_Handle, P_MOTOR_0_STOP_INFO_SIG);
    AO_Subscribe(AO_Handle, P_MOTOR_1_STOP_INFO_SIG);
    AO_Subscribe(AO_Handle, P_MOTOR_2_STOP_INFO_SIG);
    AO_Subscribe(AO_Handle, P_KEYPRESS_SIG);
    AO_Subscribe(AO_Handle, P_MOVEMENT_SIG);
    AO_Subscribe(AO_Handle, P_USED_SHELL_SIG);
    AO_Subscribe(AO_Handle, P_ERR_SHELL_SIG);
    AO_Subscribe(AO_Handle, P_ERR_BATT_LOW_SIG);
    AO_Subscribe(AO_Handle, P_BATTERY_LEVEL_INSUFF_SIG);
    AO_Subscribe(AO_Handle, P_BATT_COMM_SIG);
    AO_Subscribe(AO_Handle, P_BATT_SHUTDN_SIG);
    AO_Subscribe(AO_Handle, P_ERRBAT_DISABLED_SIG);
    AO_Subscribe(AO_Handle, P_HANDLE_EOL_SIG);
    AO_Subscribe(AO_Handle, P_PERM_FAIL_WOP_SIG);
    AO_Subscribe(AO_Handle, P_PERM_FAIL_SIG);
    AO_Subscribe(AO_Handle, P_REQ_RST_SIG);
    AO_Subscribe(AO_Handle, P_UNSUPPORTED_ADAPTER_SIG);
    AO_Subscribe(AO_Handle, P_ADAPTER_ERROR_SIG);
    AO_Subscribe(AO_Handle, P_ERRFILE_SYS_SIG);
    AO_Subscribe(AO_Handle, P_ACCELERR_SIG);
    AO_Subscribe(AO_Handle, P_USB_CONNECTED_SIG);
    AO_Subscribe(AO_Handle, P_USB_REMOVED_SIG);
    AO_Subscribe(AO_Handle, P_MOTOR_IDLE_SIG);
    AO_Subscribe(AO_Handle, P_MOTOR_MOVING_SIG);
    AO_Subscribe(AO_Handle, P_SHIPMODE_REQ_SIG);
    AO_Subscribe(AO_Handle, P_ROTATION_CONFIG_PRESS_SIG);
    AO_Subscribe(AO_Handle, P_ROTATION_CONFIG_RELEASE_SIG);
    AO_Subscribe(AO_Handle, P_ROTATION_DEACTIVATED_SIG);
    AO_Subscribe(AO_Handle, P_ROTATION_CONFIG_COMPLETED_SIG);
    AO_Subscribe(AO_Handle, P_ONCHARGER_WAKEFROMSLEEP_SIG);
    AO_Subscribe(AO_Handle, P_SYSTEM_FAULT_SIG);
    AO_Subscribe(AO_Handle, P_SDCARD_ERROR_SIG);
    AO_Subscribe(AO_Handle, P_HANDLE_MEM_SIG);
    AO_Subscribe(AO_Handle, P_ERROR_OWSHORT_NO_DEVICE_SIG);

    /// \todo 9/26/2021 - SE Below signals will be removed once KeyPattern is Updated
    AO_Subscribe(AO_Handle, P_LATERAL_RIGHT_UP_PRESS_SIG);
    AO_Subscribe(AO_Handle, P_LATERAL_RIGHT_UP_RELEASE_SIG);
    AO_Subscribe(AO_Handle, P_LATERAL_LEFT_UP_PRESS_SIG);
    AO_Subscribe(AO_Handle, P_LATERAL_LEFT_UP_RELEASE_SIG);
    AO_Subscribe(AO_Handle, P_BATT_TEMP_SIG);
    AO_Subscribe(AO_Handle, P_HANDLE_FIRE_PROCEDURE_COUNT_TEST_SIG);
    AO_Subscribe(AO_Handle, P_ADAPTER_COM_RESP_RECEIVED_SIG);
    AO_Subscribe(AO_Handle, P_ADAPTER_COM_RETRY_FAIL_SIG);


    me->Handle.Status = AM_DEVICE_DISCONNECTED;
    me->Adapter.Status = AM_DEVICE_DISCONNECTED;
    me->Adapter.DevID = DEVICE_ID_UNKNOWN;
    me->Clamshell.Status = AM_DEVICE_DISCONNECTED;

    Signia_AccelEnable(true, 0, HNutil_ProcessAccelEvents);
    Signia_ChargerManagerSetChargeLimits(100, 93);
    Signia_ChargerManagerRegEventHandler(HNutil_ProcessChargerEvents, 10000);
    me->pChargerInfo = Signia_ChargerManagerGetChargerInfo();
    me->HandleProcFireCountTestFailed = false;
    // Hook into adapter detection callback
    //Signia_AdapterManagerRegisterHandler(AdapterMgrCallback);

    /* Raise StartUp Error Events */
    Signia_StartupErrorEventPublish();  //  temporary placeholder? - merge with faulthandler once finalized?

    return Q_TRAN(&Handle_Startup);
}

// Top level state.
//
// WARNING: This state name is accessed
//          by external routines. Be sure
//          to update all instances if
//          renaming.
/*.${AOs::Handle::SM::Operate} .............................................*/
QState Handle_Operate(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::IDLE_TIMEOUT} */
        case IDLE_TIMEOUT_SIG: {
            // Idle timeout - Go into standby mode
            do
            {
                Signia_PowerModeSet(POWER_MODE_STANDBY);
                Log(DEV, "Transition: Idle->Standby");

                // Start Sleep timer if Clamshell is not Connected
                if (AM_DEVICE_DISCONNECTED == me->Clamshell.Status)
                {
                    AO_TimerArm(&me->SleepTimer, IDLE_TIME_TO_SLEEP, 0);
                }
            } while (false);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ADAPTER_REMOVED} */
        case P_ADAPTER_REMOVED_SIG: {
            // Indicate adapter disconnected
            QEVENT_FAULT *pSignalEvent;
            SIGNAL CurrentSig;
            HNutil_ProcessDeviceConnEvents(me, e);

            AO_TimerRearm(&me->IdleTimer, IDLE_TIME_BEFORE_STANDBY_WITH_CSHELL_ADAPTER);
            // Update display as required

            // Stop all motors
            Signia_MotorStop(MOTOR_ID0);
            Signia_MotorStop(MOTOR_ID1);
            Signia_MotorStop(MOTOR_ID2);
            L3_GpioCtrlClearSignal(GPIO_GN_LED);
            me->Adapter.ConnectorBusShort = false;
            if(me->Clamshell.ClamshellBusShort)
            {
                CurrentSig = P_ERR_SHELL_SIG;
                pSignalEvent = AO_EvtNew(CurrentSig, sizeof(QEVENT_FAULT));
                pSignalEvent->ErrorCause = ERR_CLAMSHELL_ONEWIRE_SHORT;
                pSignalEvent->ErrorStatus = true;
                AO_Publish(pSignalEvent, NULL);
            }
            else if (me->Handle.HandleBusShort)
            {
                CurrentSig = P_PERM_FAIL_SIG;
                pSignalEvent = AO_EvtNew(CurrentSig, sizeof(QEVENT_FAULT));
                pSignalEvent->ErrorCause = ERR_PERMANENT_FAIL_ONEWIRE_SHORT;
                pSignalEvent->ErrorStatus = true;
                AO_Publish(pSignalEvent, NULL);
            }
            InitAppHandler();

            status_ = Q_TRAN(&Handle_Idle);
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_CLAMSHELL_REMOVED} */
        case P_CLAMSHELL_REMOVED_SIG: {

            uint8_t BatteryLevel;     /* Variable to Hold the Current battery level*/

            Signia_ChargerManagerGetBattRsoc(&BatteryLevel);

            me->ActiveFaultsInfo.IsErrShell = false;

            // Indicate Clamshell disconnected
            HNutil_ProcessDeviceConnEvents(me, e);
            // Check without CLAMSHELL attached is in the ST_ERR_BATT_INSUFF state.
            if(BatteryLevel <= BATTERY_LIMIT_INSUFFICIENT)
            {
                AO_TimerArm(&me->FaultTimer, BATT_INSUFF_WITHOUT_CS_TIMEOUT, 0);
            }
            else if(BatteryLevel <= BATTERY_LIMIT_LOW)
            {
                AO_TimerArm(&me->BatteryLowTimer, BATT_LOW_WITHOUT_CS_TIMEOUT, 0);
            }
            else
            {
                CompatAdapterScreenDuration = ADAPT_COMPAT_SCREEN_DUR_RUNTIME;
            }
            status_ = Q_TRAN(&Handle_Idle);
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_RELOAD_REMOVED, P_CARTRIDGE_RE~} */
        case P_RELOAD_REMOVED_SIG: /* intentionally fall through */
        case P_CARTRIDGE_REMOVED_SIG: {
            // Indicate reload/cartridge disconnected
            HNutil_ProcessDeviceConnEvents(me, e);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_CARTRIDGE_CONNECTED} */
        case P_CARTRIDGE_CONNECTED_SIG: {
            HNutil_ProcessDeviceConnEvents(me, e);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_RELOAD_CONNECTED} */
        case P_RELOAD_CONNECTED_SIG: {
            HNutil_ProcessDeviceConnEvents(me, e);

            AO_TimerDisarm(&me->IdleTimer);
            Signia_PowerModeSet(POWER_MODE_ACTIVE);
            /// \todo 11/03/2021 NP-Handle to transition to Clamp test only when calibration is completed
            //status_ = Q_TRAN(EGIA_Clamptest_Full_Close);

            /// \todo 11/16/2021 NP- Whoever published RELOAD_CONNECTED_SIG should have done authentication & included results in the event.
            /// \todo 11/16/2021 NP- In that case, HNutil_ProcessDeviceConnEvents should take care of updating authentication status as well.
            // me->ReloadAuth needs to be set.
            // Determine what to do if not authentic/used
            // Also save data area here for future use
            // \todo - Any display updates here?

            if ( me->ActiveFaultsInfo.IsPermFailWop )
            {
                // Reload Connected when PERMFAIL WOP is active
                Signia_PlayTone(SNDMGR_TONE_FAULT);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_BATTERY_INFO} */
        case P_BATTERY_INFO_SIG: {
            QEVENT_CHARGER *pInfo = (QEVENT_CHARGER *)e;
            bool ReloadConnected;
            LOG_BATT_INFO(pInfo);

            if ((BATT_TEMP_HI_LIMIT < pInfo->Info.BatteryTemperature) || (BATT_TEMP_LO_LIMIT > pInfo->Info.BatteryTemperature))
            {
                /// \todo 12/02/2021 BS - System Reaction to Battery temperature out of limit to be defined?
                Log(DBG, "Battery Temperature out of Limits");
            }


            /* Check if Reload connected - Battery error status is updated based on Reload Connection status */
            if ( (AM_DEVICE_CONNECTED == me->Reload.Status) ||
                (AM_DEVICE_CONNECTED == me->EgiaReload.Status) )
            {
                ReloadConnected = true;
            }
            else
            {
                ReloadConnected = false;
            }
            /* Check Battery Voltage Low, Insufficient or Shutdown Errors */
            Signia_BatteryUpdateErrors(&pInfo->Info, me, ReloadConnected);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ON_CHARGER} */
        case P_ON_CHARGER_SIG: {
            me->OnChargerTimetoSleep = ONCHARGER_TIMETOFIRSTSLEEP;
            Signia_BatteryHealthCheckReset();

            ///\todo: 3/14/2022 BS- check TCA flag, if set Reset BQchip

            status_ = Q_TRAN(&Handle_OnCharger);
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_SHIPMODE_REQ} */
        case P_SHIPMODE_REQ_SIG: {
            /*.${AOs::Handle::SM::Operate::P_SHIPMODE_REQ::[Status_OK]} */
            if (AM_DEVICE_CONNECTED != me->Adapter.Status) {
                /* Allow entry into ship mode when Adapter is not connected */
                Log(TRC, "Handle is powering down (entering ship mode) ");
                AO_TimerDisarm(&me->IdleTimer);
                Signia_PlayTone(SNDMGR_TONE_SHUTDOWN);
                OSTimeDly(SEC_3);   //Allow Shutdown  tone (~2sec) to play and log messages
                Signia_PowerModeSet(POWER_MODE_SHIP);  /// \\todo 03/09/2022 KIA: will log message be written before handle powers down?
                status_ = Q_TRAN(&Handle_PowerDown);
            }
            /*.${AOs::Handle::SM::Operate::P_SHIPMODE_REQ::[Status_FAIL]} */
            else {
                /* Disallow entry into shipmode when Adapter is connected */
                Log(REQ,"Disallowed entry into SHIP MODE, Reason: Adapter Connected");
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::Handle::SM::Operate::SLEEP_TIMEOUT} */
        case SLEEP_TIMEOUT_SIG: {
            // NOTE: This event does NOT transition to sleep so that
            //       control will return to the currently active state
            //       if Signia_PowerModeSet fails.

            if (!me->Handle.HandleComConnected)
            {
                Log(DEV, "Standby idle, entering Sleep Mode");
                Signia_PowerModeSet(POWER_MODE_SLEEP);
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate:: P_CLAMSHELL_CONNECTED, P_ADAPTE~} */
        case  P_CLAMSHELL_CONNECTED_SIG: /* intentionally fall through */
        case P_ADAPTER_CONNECTED_SIG: {
            uint8_t BatteryLevel;

            Signia_ChargerManagerGetBattRsoc(&BatteryLevel);
            do
            {
                /* Clamshell or Adapter connected */
                HNutil_ProcessDeviceConnEvents(me, e);    // Process Signia Device connection as appropriate
                if ( P_CLAMSHELL_CONNECTED_SIG == e->sig && me->ActiveFaultsInfo.IsPermFailWop )
                {
                    // Clamshell Connected when PERMFAIL WOP is active
                    Signia_PlayTone(SNDMGR_TONE_FAULT);
                }


                // Play Battery Tones
                if (BatteryLevel <= BATTERY_LIMIT_INSUFFICIENT)
                {
                    Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
                    InsuffBattery = true;
                }
                else if (BatteryLevel <= BATTERY_LIMIT_LOW)
                {
                    Signia_PlayTone(SNDMGR_TONE_LOW_BATTERY);
                    LowBattery = true;
                }
                else
                {
                    // Do nothing
                }

                BREAK_IF (CHRG_MNGR_STATE_DISCONNECTED != Signia_ChargerManagerGetState())
                BREAK_IF ((AM_DEVICE_CONNECTED == me->Clamshell.Status) && (AM_DEVICE_DISCONNECTED == me->Adapter.Status))

                if (AM_DEVICE_CONNECTED == me->Adapter.Status)
                {
                    Signia_PowerModeSet(POWER_MODE_ACTIVE);
                    AO_TimerRearm(&me->IdleTimer, IDLE_TIME_BEFORE_STANDBY_WITH_CSHELL_ADAPTER);
                    break;
                }
            }
            while (false);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_KEYPRESS, P_MOVEMENT} */
        case P_KEYPRESS_SIG: /* intentionally fall through */
        case P_MOVEMENT_SIG: {
            QEVENT_KEY *pKeyEvents;
            pKeyEvents = (QEVENT_KEY *)e;

            /* Disarm any active timers */
            AO_TimerDisarm(&me->IdleTimer);
            AO_TimerDisarm(&me->SleepTimer);

            if (P_KEYPRESS_SIG == e->sig)
            {
                /* Read Key State */
                me->KeyState = pKeyEvents->KeyState;
            }

            /* User Action - Set timeout to IDLE_TIME_BEFORE_STANDBY_WITH_CSHELL_ADAPTER when either Adapter or Clamshell are connected */
            if ((AM_DEVICE_CONNECTED == me->Adapter.Status) || (AM_DEVICE_CONNECTED == me->Clamshell.Status))
            {
                AO_TimerArm(&me->IdleTimer, IDLE_TIME_BEFORE_STANDBY_WITH_CSHELL_ADAPTER,0);
                /* Set power mode to Active  */
                Signia_PowerModeSet(POWER_MODE_ACTIVE);
            }
            else /* Only Handle */
            {
                if (P_KEYPRESS_SIG == e->sig)
                {
                    /* Set power mode to Active  */
                    Signia_PowerModeSet(POWER_MODE_ACTIVE);
                }
                // Keypress activity, Show Compatible Adapter Screen Ref: Platform SRS ID# 295441
                if ((P_KEYPRESS_SIG == e->sig) && (KEY_STATE_PRESS == pKeyEvents->State))
                {
                    // Display PROCEDURE_COMPAT_ADAPT_SCREEN
                    Show_AdapterCompatibleScreen(me->HandleRemainingProcedures);
                }

                    // Keyrelease activity, Show Insert Clamshell Screen Ref: Platform SRS ID# 295441
                if ((P_KEYPRESS_SIG == e->sig) && (!pKeyEvents->KeyState))
                {
                        // Display INSERT_CLAMSHELL_SCREEN Animation Screen
                        Show_InsertClamshellScreen();
                }

                /* TimerArm - making this oneshot timer */
                AO_TimerArm(&me->IdleTimer, IDLE_TIME_BEFORE_STANDBY_NO_CLAMSHELL,0);
                AO_TimerArm(&me->SleepTimer, IDLE_TIME_TO_SLEEP,0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_BATTERY_LEVEL_INSUFF, FAULT_TI~} */
        case P_BATTERY_LEVEL_INSUFF_SIG: /* intentionally fall through */
        case FAULT_TIMEOUT_SIG: {
             uint8_t BatteryLevel;     /* Variable to Hold the Current battery level*/

            Signia_ChargerManagerGetBattRsoc(&BatteryLevel);
            /* Play tone and log only once entering MOO_ERR_BATT_INSUFF */
            if (!InsuffBattery)
            {
                Log(REQ, "Entered MOO_ERR_BATT_INSUFF");
                Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
                InsuffBattery = true;
            }

            /* To show alternative screens */
            DisplayAlternateScreen = !DisplayAlternateScreen;
            /* HANDLE without CLAMSHELL attached is in the MOO_ERR_BATT_INSUFF condition */
            if ( (AM_DEVICE_CONNECTED != me->Clamshell.Status) &&
                 (BatteryLevel <= BATTERY_LIMIT_INSUFFICIENT) )
            {
                /* Battery level Insufficient and No Clamshell prasent */
                Gui_AlterInsuffBattNoClamshell_Screen();
                /* Start timer to alternate screens */
                AO_TimerArm(&me->FaultTimer, BATT_INSUFF_WITHOUT_CS_TIMEOUT, 0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_BATT_COMM} */
        case P_BATT_COMM_SIG: {
            /* Play Error Tone */
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            /* Display Battery Connection Error Screen */
            Gui_BattConnectionErr_Screen();
            /* Update Heart Beat Led On Off Time to 5 seconds*/
            HNutil_UpdateHeartBeatPeriod(e);
            status_ = Q_TRAN(&Handle_Fault);
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_USED_SHELL} */
        case P_USED_SHELL_SIG: {
            me->Clamshell.ClamshellEOL = true;
            // Display USED_CS_SCREEN
            Gui_Used_CS_Screen();

            /* Play Caution Tone */
            Signia_PlayTone(SNDMGR_TONE_CAUTION);

            Log(DBG, "USED_CS_SCREEN - Used Clamshell Connected");

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ERR_SHELL} */
        case P_ERR_SHELL_SIG: {
            // Play the TONE_ERR_FAULT tone and show Clamshell Error screen
            QEVENT_FAULT *pClamshellErr;
            pClamshellErr = (QEVENT_FAULT *)e;

            do
            {

                /*  Monitor the CLAMSHELL 1_WIRE_BUS for shorts when a CLAMSHELL is connected without an ADAPTER.*/
                if ((AM_DEVICE_DISCONNECTED == me->Adapter.Status) && (AM_DEVICE_CONNECTED == me->Clamshell.Status))
                {
                    Log(DEV, "Clamshell onewire Short detected");
                }

                if (ERR_CLAMSHELL_ONEWIRE_SHORT ==  pClamshellErr->ErrorCause)
                {
                    //then run the timer of 2 sec to enter into sleep mode
                    if (AM_DEVICE_CONNECTED == me->Adapter.Status)
                    {
                        me->Clamshell.ClamshellBusShort = true;
                        break;
                    }
                    else
                    {
                        AO_TimerArm(&me->ClamshellOWShortTimer, CLAMSHELL_ONEWIRE_SHORT_TIMEOUT, 0);
                    }
                }
                else
                {
                    me->ActiveFaultsInfo.IsErrShell = true;
                }

                Log(DBG,"***** Entering Clamshell Error State *****");
                Signia_PlayTone(SNDMGR_TONE_FAULT);
                Gui_InsertClamshellErrorScreen();
            }while (false);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_BATTERY_LOW,  P_ERR_BATT_LOW} */
        case P_BATTERY_LOW_SIG: /* intentionally fall through */
        case P_ERR_BATT_LOW_SIG: {
            QEVENT_CHARGER *pInfo = (QEVENT_CHARGER *)e;

            LOG_BATT_INFO(pInfo);

            /* Log an event Low Battery status */
            Log(DEV, "Entered ERR_BATT_LOW state ");
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::BATTERY_LOW_TIMEOUT} */
        case BATTERY_LOW_TIMEOUT_SIG: {
            /* Play tone only once enter into P_ST_ERR_BATT_LOW_SIG state */

            if (!LowBattery)
            {
                /* Play Low Battery Tone only once in ST_ERR_BATT_LOW state */
                Signia_PlayTone(SNDMGR_TONE_LOW_BATTERY);
                LowBattery = true;
            }

            /* Display Battery Low Battery Screens based on the clamshell status */
            if (AM_DEVICE_CONNECTED == me->Clamshell.Status)
            {
                // Log Low Battery Event
                Log(DBG, "LOW_BATTERY_SCREEN - Clamshell Connected");
            }
            else /* Clamshell is not connected */
            {
                DisplayAlternateScreen = !DisplayAlternateScreen;
                /* Display  alternately LOW_BATT_PR1_COMPAT_ADAPT_SCREEN and LOW_BATT_PR2_SCREEN */
                Gui_AlterLowBattNoClamshell_Screen(me->HandleRemainingProcedures);
                /* Start timer to alternate screens */
                AO_TimerArm(&me->BatteryLowTimer, BATT_LOW_WITHOUT_CS_TIMEOUT, 0);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ERRBAT_DISABLED} */
        case P_ERRBAT_DISABLED_SIG: {
            Log(DBG, "Battery Fault Signal Received");
            Signia_BatDisableFault();
            AO_TimerDisarm(&me->IdleTimer);
            AO_TimerDisarm(&me->SleepTimer);
            AO_TimerDisarm(&me->Timer);
            Signia_KeypadScanPause();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_HANDLE_EOL} */
        case P_HANDLE_EOL_SIG: {
            /* Play Error Tone */
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            /* Display Battery End of Life Screen */
            Gui_HandleEndOfLife_Screen();
            /* Update Heart Beat Led On Off Time to 5 seconds*/
            HNutil_UpdateHeartBeatPeriod(e);
            status_ = Q_TRAN(&Handle_Fault);
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_PERM_FAIL_WOP} */
        case P_PERM_FAIL_WOP_SIG: {
            Gui_HandleErrorScreen();
            /* Play Error Tone */
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            /* Update HeartBeat Led with 2 seconds on, 2 seconds off*/
            HNutil_UpdateHeartBeatPeriod(e);
            /* Permanent Failure WOP is active */
            me->ActiveFaultsInfo.IsPermFailWop = true;

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_REQ_RST, P_SYSTEM_FAULT} */
        case P_REQ_RST_SIG: /* intentionally fall through */
        case P_SYSTEM_FAULT_SIG: {
            POWER_MODE PowerMode;
            AO_TimerDisarm(&me->FaultTimer);  // Time will be reset by HNutil_DisplayRequestScreenSeq // ReqScreeenTimer?
            /* Play Error Tone */
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            /* Update HeartBeat Led with 3 seconds on, 3 seconds off*/
            HNutil_UpdateHeartBeatPeriod(e);

            me->ReqRstScreenInfo.ReqRstSeq       = REQRSTSCREEN_SEQA;
            me->ReqRstScreenInfo.ReqRstScreen    = REQRST_SCREEN_ONE;
            me->ReqRstScreenInfo.ScreenDispCount = 0;

            PowerMode = Signia_PowerModeGet();
            if ( POWER_MODE_STANDBY == PowerMode )
            {
                Signia_PowerModeSet (POWER_MODE_ACTIVE);
            }

            HNutil_DisplayRequestScreenSeq(me);  // This function sets fault timer.
            status_ = Q_TRAN(&Handle_Fault);
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ERRFILE_SYS, P_ACCELERR} */
        case P_ERRFILE_SYS_SIG: /* intentionally fall through */
        case P_ACCELERR_SIG: {
            if ( P_ERRFILE_SYS_SIG == e->sig )
            {
                me->ActiveFaultsInfo.IsFileSysErr = true;
            }
            else
            {
                me->ActiveFaultsInfo.IsAccelErr = true;
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_BATT_SHUTDN} */
        case P_BATT_SHUTDN_SIG: {
            /// \todo 01092022 KIA: disable USB. Need API to disable USB
            Log(TRC, "Powering Down");
            /* Set power mode to active to play tones and gui*/
            Signia_PowerModeSet(POWER_MODE_ACTIVE);
            Signia_KeypadScanPause();
            Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
            Gui_DepletedBatt_Screen();
            OSTimeDly(SEC_5); // time for tone and display to playout
            Signia_PlayTone(SNDMGR_TONE_INSUFFICIENT_BATTERY);
            OSTimeDly(SEC_1); // time for tone to playout
            Signia_PowerModeSet(POWER_MODE_SHUTDOWN);
            status_ = Q_TRAN(&Handle_PowerDown);
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_MOTOR_IDLE} */
        case P_MOTOR_IDLE_SIG: {
            /// \todo 02/09/2022 DAZ - Should we do all this in platform? Is it even needed anymore?

            // Timeout every 4 hours as long as motor isn't running.

            Log(DEV, "All Motors off, battery level %.1f%%", me->pChargerInfo->BatteryLevel);
            AO_TimerArm(&me->MotorIdleTimer, HOUR_4, HOUR_4);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::MOTOR_IDLE_TIMEOUT} */
        case MOTOR_IDLE_TIMEOUT_SIG: {
            if ( me->pChargerInfo->BatteryLevel > BATTERY_LIMIT_LOW )
            {
                // NOTE: This timeout provides a current pulse
                //       for every 4 hours of motor inactivity
                //       by enabling the Allegro chips for 2 seconds. This
                //       current pulse causes the BQ chip to perform a
                //       recalibrate operation.

                Log(DEV, "Motor Idle timeout - Enable Motor");

                Signia_MotorEnable(MOTOR_ID0);
                Signia_MotorEnable(MOTOR_ID1);
                Signia_MotorEnable(MOTOR_ID2);

                // This event intentionally blocks for 2 seconds
                // in order to ignore keystrokes that may occur
                // during this time. Any keystrokes that DO occur
                // will be processed after this event has been processed.

                OSTimeDly(SEC_2);

                Log(DEV, "Motor Idle timeout - Disable Motor");
                Signia_MotorDisable(MOTOR_ID0);
                Signia_MotorDisable(MOTOR_ID1);
                Signia_MotorDisable(MOTOR_ID2);
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_MOTOR_MOVING} */
        case P_MOTOR_MOVING_SIG: {
            AO_TimerDisarm(&me->MotorIdleTimer);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_BATT_TEMP} */
        case P_BATT_TEMP_SIG: {
            QEVENT_FAULT *pSignalEvent;
            pSignalEvent = (QEVENT_FAULT *)e;
            /* Battery Temperature Out of Range */
            do
            {
                /* Battery Temperature Error Set */
                if ( pSignalEvent->ErrorStatus )
                {
                    Log(REQ,"Entered Battery Temperature Error State");
                    /* Display Battery Connection Error Screen */
                    Gui_BattConnectionErr_Screen();
                    /* Play Error Tone */
                    Signia_PlayTone(SNDMGR_TONE_FAULT);
                    /* Set Battery Temperature Error */
                    me->ActiveFaultsInfo.BattTempError = true;
                }
                else
                {
                    /* Battery Temperatur Error Cleared */
                    Gui_BattConnectionErr_ScreenUnlock();
                    /* Clear Battery Temperature Error */
                    me->ActiveFaultsInfo.BattTempError = false;
                }

            }while(false);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_SDCARD_ERROR} */
        case P_SDCARD_ERROR_SIG: {
            QEVENT_FAULT *pSignalEvent;

            pSignalEvent = (QEVENT_FAULT *)e;

            if ( SDCARD_NOTPRESENT == pSignalEvent->ErrorCause )
            {
                /* SD CARD NOT PRESENT */
                Log(REQ, "ERROR: SD CARD NOT PRESENT");
            }
            else
            {
                /* Handle other causes */
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_PERM_FAIL} */
        case P_PERM_FAIL_SIG: {
            QEVENT_FAULT *pHandleErr;
            pHandleErr = (QEVENT_FAULT *)e;
            do
            {
                /* Transition if ErrorStatus is set, else remain in operate */
                if (ERR_PERMANENT_FAIL_ONEWIRE_SHORT == pHandleErr->ErrorCause)
                {
                    /* If Adapter Connected and Handle Bus short happens then set flag */
                    if (AM_DEVICE_CONNECTED == me->Adapter.Status)
                    {
                        me->Handle.HandleBusShort = true;
                        break;
                    }
                }
                Log(DBG,"**** Entering Permanent Error State ****");
                /* Display HANDLE_ERROR_SCREEN */
                Gui_HandleErrorScreen();

                /* Play Error Tone */
                Signia_PlayTone(SNDMGR_TONE_FAULT);

                /* Update HeartBeat Led with 2 seconds on, 2 seconds off*/
                HNutil_UpdateHeartBeatPeriod(e);
            }while (false);
            /*.${AOs::Handle::SM::Operate::P_PERM_FAIL::[!me->Handle.HandleBusShort]} */
            if (!me->Handle.HandleBusShort) {
                status_ = Q_TRAN(&Handle_Fault);
            }
            /*.${AOs::Handle::SM::Operate::P_PERM_FAIL::[else]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        /*.${AOs::Handle::SM::Operate::CLAMSHELL_1WSHORT_TIMEOUT} */
        case CLAMSHELL_1WSHORT_TIMEOUT_SIG: {
            Signia_PowerModeSet(POWER_MODE_SLEEP);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ERROR_OWSHORT_NO_DEVICE} */
        case P_ERROR_OWSHORT_NO_DEVICE_SIG: {
            /* No Device on Bus and Short Happened */
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            Log(DEV, "Clamshell/Connector Bus short without device on bus");
            Signia_PowerModeSet(POWER_MODE_SLEEP);


            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_USB_CONNECTED} */
        case P_USB_CONNECTED_SIG: {
            AO_TimerDisarm(&me->SleepTimer);  // Disable sleep while on USB
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_USB_REMOVED} */
        case P_USB_REMOVED_SIG: {
            /* The HANDLE shall transition from STANDBY_MODE to SLEEP_MODE
            from 2 minutes  to 7 minutes from loss of USB communication */
            if (AM_DEVICE_DISCONNECTED == me->Clamshell.Status)
            {
                AO_TimerRearm(&me->SleepTimer, IDLE_TIME_TO_SLEEP);
            }
            me->Handle.HandleComConnected = false;
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_HANDLE_FIRE_PROCEDURE_COUNT_TE~} */
        case P_HANDLE_FIRE_PROCEDURE_COUNT_TEST_SIG: {
            /* Handle Procedure / Fire Count test failed */
            /* Play Fault Tone */
            me->HandleProcFireCountTestFailed = true;
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            /// \todo 01/20/2023 BS - Below screen not working (screen stuck). need to be fixed, for now commenting
            //Gui_HandleErrorScreen();
            Log(DBG, "Handle Procedure/Fire Count Test Failed");
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ADAPTER_COM_RESP_RECEIVED} */
        case P_ADAPTER_COM_RESP_RECEIVED_SIG: {
            QEVENT_ADAPTERCOM *pSignalEvent;

            pSignalEvent = (QEVENT_ADAPTERCOM *)e;
            if(ADAPTER_GET_TYPE == pSignalEvent->AdapterCmd)
            {
                if(!me->Adapter.Authenticated)
                {
                    me->Adapter.DevID = (DEVICE_ID_ENUM)Signia_GetUartAdapterType();//use UART adapter type
                }
            }
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::P_ADAPTER_COM_RETRY_FAIL} */
        case P_ADAPTER_COM_RETRY_FAIL_SIG: {
            QEVENT_ADAPTERCOM *pSignalEvent;

            pSignalEvent = (QEVENT_ADAPTERCOM *)e;

            me->Adapter.Status= AM_DEVICE_ACCESS_FAIL;
            if(ADAPTER_UPDATE_MAIN == pSignalEvent->AdapterCmd)
            {
                Gui_AdapterErrorScreen();
                Signia_PlayTone(SNDMGR_TONE_FAULT);
                  /// \todo 08/feb/2022 JA use this to generate a FW upgrade fail signal to retract the
                  ///FIRING_ROD to the load position and prevent ARTICULATION CALIBRATION
                  /// requirement SIGNIASR-1630 ID:317051

            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Idle state
 *
 * \details This state waits for a valid adapter/clamshell to be attached, and transitions to
 *          the appropriate state for application processing.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::Idle} .......................................*/
QState Handle_Idle(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::Idle} */
        case Q_ENTRY_SIG: {
            /**
             * \warning The RETRY_TIMEOUT signal is borrowed in this state insure that the adapter connected test is
             *          invoked when the state is entered. This is done to handle the case where a clamshell and
             *          adapter have already been detected. In this case, there will be no adapter/clamshell connected
             *          events to invoke this processing.
             */
            uint8_t             BatteryLevel;  // Variable used to read the current battery level
            AM_HANDLE_IF        *pHandle;

            Log(DEV, "Handle - Idle state entered");

            Signia_ChargerManagerGetBattRsoc(&BatteryLevel);

            // Disable the Accelerometer until clamshell is detected
            Signia_AccelEnable(false, 0, NULL);

            // Let Handle be completely active
            Signia_PowerModeSet(POWER_MODE_ACTIVE);

            // Check for Com status. This is required if USB is connected on startup, we are missing the P_USB_CONNECTED_SIG
            me->Handle.HandleComConnected = L4_CommStatusActive();

            // Get handle Information
            pHandle = HandleGetIF();
            me->HandleRemainingProcedures = ((pHandle->Data.ProcedureLimit) - (pHandle->Data.ProcedureCount));

            AO_TimerDisarm(&me->Timer);           // Stop the timer restart it after the showing screen.
            AO_TimerDisarm(&me->FaultTimer);      // Stop the FaultTimer restart
            AO_TimerDisarm(&me->BatteryLowTimer); // Stop the BatteryLowTimer restart

            if( (AM_DEVICE_CONNECTED != me->Clamshell.Status) &&
                (BatteryLevel <= BATTERY_LIMIT_INSUFFICIENT))
            {
                AO_TimerArm(&me->FaultTimer, BATT_INSUFF_WITHOUT_CS_TIMEOUT, 0);
            }

            // Battery level <= LOW and Clamshell not connected.
            // Alternately display the LOW_BATT_PR2_SCREEN and LOW_BATT_PR1_COMPAT_ADAPT_SCREEN
            else if( (AM_DEVICE_CONNECTED != me->Clamshell.Status) && (BatteryLevel <= BATTERY_LIMIT_LOW))
            {
                AO_TimerArm(&me->BatteryLowTimer, BATT_LOW_WITHOUT_CS_TIMEOUT, 0);
            }

            // Battery level above LOW and Clamshell not connected.
            // Show Insert Clamshell screen
            else if((AM_DEVICE_CONNECTED != me->Clamshell.Status) && (BatteryLevel > BATTERY_LIMIT_LOW))
            {
                // Show Adapter compatible screen and display usage count as well
                Show_AdapterCompatibleScreen(me->HandleRemainingProcedures);

                // Start screen show duration timer, on expiry will switch to idle state
                AO_TimerRearm(&me->Timer, CompatAdapterScreenDuration);
            }

            AO_TimerDisarm(&me->IdleTimer);
            AO_TimerArm(&me->IdleTimer, IDLE_TIME_BEFORE_STANDBY_NO_CLAMSHELL, 0);

            // A fake timeout signal is posted here in the event that the adapter and clamshell are already attached
            // when we get here. The timeout signal forces the initial Adapter/Clamshell present check.
            if ((AM_DEVICE_CONNECTED == me->Adapter.Status) || (AM_DEVICE_CONNECTED == me->Clamshell.Status))
            {
                AO_Post(AO_Handle, &RetryTimeoutSig, NULL);    // Post dummy signal to force initial Clamshell/Adapter check.
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::TIMEOUT} */
        case TIMEOUT_SIG: {
            // Show Appropriate Screens
            AO_TimerDisarm(&me->Timer);

            if (AM_DEVICE_DISCONNECTED == me->Clamshell.Status)
            {
                if (!L4_DmScreenUnlockTemp_New())
                {
                    L4_DmCurrentScreenLockUnLock_New(SCREEN_LOCK_OFF);
                    Show_InsertClamshellScreen();
                }
            }
            else if (AM_DEVICE_DISCONNECTED == me->Adapter.Status)
            {
                // Show Adapter Screen only if Clamshell is Unused and not in Error state
                if ( (!me->Clamshell.ClamshellEOL) && (!me->ActiveFaultsInfo.IsErrShell))
                {
                    /* Unlock the screen if screen locked temperary */
                    if (!L4_DmScreenUnlockTemp_New())
                    {
                        L4_DmCurrentScreenLockUnLock_New(SCREEN_LOCK_OFF);
                        Show_AdapterRequestScreen(me->HandleRemainingProcedures);
                    }
                }
            }

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::P_UNSUPPORTED_ADAPTER} */
        case P_UNSUPPORTED_ADAPTER_SIG: {
            Log(DEV, "Unsupported Adapter: Adapter is not an EGIA");

            //Show Unsupported Adapter Screen
            Gui_AdapterUnsupported();

            /* Play Fault Tone */
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::P_ADAPTER_ERROR} */
        case P_ADAPTER_ERROR_SIG: {
            Log(DEV, "Adapter Error: Authentication Fail/CRC Fail/BusError/1-WireShort detected");
            //Show Adapter Error screen
            Gui_AdapterErrorScreen();
            /* Play Fault Tone */
            Signia_PlayTone(SNDMGR_TONE_FAULT);

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::COUNTDOWN_SCREEN_TIMEOUT} */
        case COUNTDOWN_SCREEN_TIMEOUT_SIG: {
            /* Update the Rotation Count Down Activation/Deactivation screens for every one second */
            HNutil_RotationConfigDisplayCountDownScreens(me);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::ROTATION_CONFIG_SCREEN_TIMEOUT} */
        case ROTATION_CONFIG_SCREEN_TIMEOUT_SIG: {
            /* Display Previous Screen */
            /// \todo 9/26/2021 SE call display previous screen API once it is available

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::P_ROTATION_DEACTIVATED} */
        case P_ROTATION_DEACTIVATED_SIG: {
            /* Display Rotation Activation Screens based on the Side */
                if(me->KeySide == KEY_SIDE_LEFT)
                {
                    //Gui_RB_ActivateIndicatorL_ScreenSet();
                    Gui_RotateActivateLeft_ScreenSet();
                }
                else
                {
                    //Gui_RB_ActivateIndicatorR_ScreenSet();
                    Gui_RotateActivateRight_ScreenSet();
                }

            /* Start 2 seconds Timer */
            AO_TimerArm(&me->RotationConfigScreenTimer, ROTATION_CONFIG_2SEC_TIMEOUT, NULL);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::P_ROTATION_CONFIG_COMPLETED} */
        case P_ROTATION_CONFIG_COMPLETED_SIG: {
            /* Stop  Count Down Screen Timer */
            AO_TimerDisarm(&me->CountDownScreenTimer);

            /* Display Rotation Configuration Screens based on Activation/Deactivation */
            if(me->IsKeySideRotationDisabled == false)
            {
                /* Display Rotation Deactivation Screens based on the Side */
                if(me->KeySide == KEY_SIDE_LEFT)
                {
                    Gui_RotateDeactLeft_ScreenSet();
                }
                else
                {
                    Gui_RotateDeactRight_ScreenSet();
                }
            }
            else
            {
                /* Display Rotation Activation Count Down 1 Screens based on the Side */
                if(me->KeySide == KEY_SIDE_LEFT)
                {
                    Gui_RotationACtivatedLeft_ScreenSet();
                }
                else
                {
                    Gui_RotationACtivatedRight_ScreenSet();
                }
            }

            /* Start 2 seconds Timer to display Activated / Deactivated Screen */
            AO_TimerArm(&me->RotationConfigScreenTimer, ROTATION_CONFIG_2SEC_TIMEOUT, NULL);

            //Update the status of rotation configuration for the side
            Signia_UpdateRotationConfigStatus(me->KeySide);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::P_ROTATION_CONFIG_PRESS, P_LATER~} */
        case P_ROTATION_CONFIG_PRESS_SIG: /* intentionally fall through */
        case P_LATERAL_RIGHT_UP_PRESS_SIG: /* intentionally fall through */
        case P_LATERAL_LEFT_UP_PRESS_SIG: {
            /// \todo 9/26/2021 SE Remove P_LATERAL_RIGHT_UP_PRESS and P_LATERAL_LEFT_UP_PRESS Signals once Rotation Key Pattern updates are available
            /// \todo 5/26/2022 CPK Remove FIX_ROTATION_CONFIG  once Rotation Key Pattern updates are available
            #ifdef FIX_ROTATION_CONFIG
            do
            {
                if(me->ActiveFaultsInfo.IsErrShell || me->Clamshell.ClamshellEOL)
                {
                    Log(DEV, "Handle - Ignore Rotation Configuration req");
                    Log(DEV, "IsErrShell = %d, IsUsedClamshell = %d", me->ActiveFaultsInfo.IsErrShell, me->Clamshell.ClamshellEOL);
                    break;
                }

                // Check if both side keys are enabled, display both enabled screen
                if( !Signia_GetRotationConfigStatus(KEY_SIDE_LEFT) && !Signia_GetRotationConfigStatus(KEY_SIDE_RIGHT) )
                {
                   // Display ROTATION_ACTIVATED_BOTH_SCREEN
                   Log(DEV, "Handle - Display Both Side Rotation Activated screen");
                   Gui_RotationActivatedBoth_ScreenSet();
                }

                pRotKeyEvent = (QEVENT_KEY *)e;
                me->KeySide = pRotKeyEvent->KeySide;
                me->IsKeySideRotationDisabled = Signia_GetRotationConfigStatus(me->KeySide);

                /* Start 3 second Rotation Config Timer */
                AO_TimerArm(&me->RotationConfigTimer, ROTATION_CONFIG_TIMEOUT, NULL);

                HNutil_RotationConfigDisplayCountDownScreens(me);

                /* Start one second Periodic Timer to display Count down Display Screens */
                AO_TimerArm(&me->CountDownScreenTimer, ROTATION_CONFIG_SCREEN_COUNTDOWNTIME, ROTATION_CONFIG_SCREEN_COUNTDOWNTIME);
            } while(false);
            #endif

            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::P_ROTATION_CONFIG_RELEASE, P_LAT~} */
        case P_ROTATION_CONFIG_RELEASE_SIG: /* intentionally fall through */
        case P_LATERAL_RIGHT_UP_RELEASE_SIG: /* intentionally fall through */
        case P_LATERAL_LEFT_UP_RELEASE_SIG: {
            /// \todo 9/26/2021 SE Remove P_LATERAL_RIGHT_UP_RELEASE and P_LATERAL_LEFT_UP_RELEASE Signals once Rotation Key Pattern updates are available
            /* Disarm All the timers */
            AO_TimerDisarm(&me->RotationConfigScreenTimer);
            AO_TimerDisarm(&me->CountDownScreenTimer);
            AO_TimerDisarm(&me->RotationConfigTimer);
            /* Display Previous Screen */
            /// todo SE 21-Sept-21 call display previous screen API once it is available
            /// As of now calling  AdapterCalib  for testing
            //L4_DmShowScreen(&ScreenAdapterCalib);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::RETRY_TIMEOUT, P_ADAPTER_CONNECT~} */
        case RETRY_TIMEOUT_SIG: /* intentionally fall through */
        case P_ADAPTER_CONNECTED_SIG: /* intentionally fall through */
        case P_CLAMSHELL_CONNECTED_SIG: {
            // Process adapter or clamshell as
            // approproate. Update display as
            // required.
            HNutil_ProcessDeviceConnEvents(me, e);
            Signia_PowerModeSet(POWER_MODE_ACTIVE);
            Signia_StartRotationConfigPatternWatch();

            if ( (AM_DEVICE_CONNECTED == me->Adapter.Status) || (AM_DEVICE_ACCESS_FAIL == me->Adapter.Status) )
            {
                // Standby and Sleep mode area disabled when an adapter is connected/1-wire read failed
                //   Hence disable standby and sleep timers
                AO_TimerDisarm(&me->SleepTimer);

                // Enable idle timer of 15min, if adapter not used for that 15min after connection,
                // handle will go to Standby Mode
                AO_TimerRearm(&me->IdleTimer, IDLE_TIME_BEFORE_STANDBY_WITH_CSHELL_ADAPTER);
            }
            else
            {
                if (AM_DEVICE_CONNECTED == me->Clamshell.Status)
                {
                    if(me->Clamshell.ClamshellBusShort)
                    {
                        //Clamshell Shorted
                        Gui_InsertClamshellErrorScreen();
                        me->Clamshell.ClamshellBusShort = false;
                    }
                    else if ((me->Clamshell.ClamshellEOL) && (!L4_DmScreenUnlockTemp_New()))
                    {
                        // Display USED_CS_SCREEN and Screen Lock is temporary
                        Gui_Used_CS_Screen();
                    }
                    else if (me->ActiveFaultsInfo.IsErrShell)
                    {
                        // Display HANDLE_CS_ERR_SCREEN
                        Gui_InsertClamshellErrorScreen();
                    }
                    else
                    {
                        /* REQUEST_ADAPTER_SCREEN after a detected CLAMSHELL is authenticated, not used,
                           and an ADAPTER is not attached - wait for adapter detection before screen display */
                        AO_TimerRearm(&me->Timer, ADAPT_REQUEST_SCREEN_DUR);
                    }

                    AO_TimerRearm(&me->IdleTimer, IDLE_TIME_BEFORE_STANDBY_WITH_CSHELL_ADAPTER);
                    AO_TimerDisarm(&me->SleepTimer);
                }
            }

            if ( me->ActiveFaultsInfo.IsPermFailWop )
            {
                // Clamshell/Adapter Connected when PERMFAIL WOP is active
                Signia_PlayTone(SNDMGR_TONE_FAULT);
            }
            if (me->Adapter.AdapterUnsupported)
            {
                FaultHandlerSetFault(UNSUPPORTED_ADAPTER_DETECTED, SET_ERROR);
            }
            /*.${AOs::Handle::SM::Operate::Idle::RETRY_TIMEOUT, P~::[Supported]} */
            if (((me->Adapter.Status != AM_DEVICE_DISCONNECTED) && (!me->Adapter.AdapterUnsupported))) {
                /// \todo 1/23/2023 BS: clampshell not detected by adapter detected, show the screen accordingly
                status_ = Q_TRAN(&Handle_AdapterTypeCheck);
            }
            /*.${AOs::Handle::SM::Operate::Idle::RETRY_TIMEOUT, P~::[Unsupported]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Operate);
            break;
        }
    }
    return status_;
}

/**
 * \brief   AdapterTypeCheck state
 *
 * \details This state checks for Adapter Type. if the type
 *          is already known from Onewire we continue, else
 *	 if we wait to read the Adapter Type from Adpater   	 *           Flash to continue
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck} .....................*/
QState Handle_AdapterTypeCheck(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck} */
        case Q_ENTRY_SIG: {
            AO_TimerArm(&me->AdapterCheckTimer, 10,0);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck::ADAPTER_TYPE_CHECK_TIMEOUT} */
        case ADAPTER_TYPE_CHECK_TIMEOUT_SIG: {
            /*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck::ADAPTER_TYPE_CHE~::[AdapterKnown]} */
            if ((DEVICE_ID_UNKNOWN != me->Adapter.DevID ) && !(me->Adapter.pHandle->pIsAdapComInProgress())) {
                /*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck::ADAPTER_TYPE_CHE~::[AdapterKnown]::[EGIA]} */
                if (DEVICE_ID_ADAPTER_EGIA == me->Adapter.DevID) {
                    if ((AM_DEVICE_ACCESS_FAIL == me->Adapter.Status) || \
                        (AM_DEVICE_AUTH_FAIL == me->Adapter.Status))
                    {
                        //1-wire authentication failed, move to EGIA operate just for emergency retraction
                        //disable all key inputs here
                        Signia_KeypadScanPause();
                    }
                    // Valid EGIA adapter found, transition
                    // to external EGIA substate

                    // The If statement below is included to avoid
                    // compiler warning about unreachable code

                    if (me)
                    {
                        status_ = Q_TRAN(EGIA_Operate);    // Transition to external EGIA superstate
                        break;
                    }
                    status_ = Q_TRAN(&Handle_EGIA_Operate);
                }
                /*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck::ADAPTER_TYPE_CHE~::[AdapterKnown]::[EEA]} */
                else if (DEVICE_ID_ADAPTER_EEA == me->Adapter.DevID) {
                    // Valid EGIA adapter found, transition
                    // to external EEA substate

                    // The If statement below is included to avoid
                    // compiler warning about unreachable code

                    if (me)
                    {
                        status_ = Q_TRAN(EEA_Operate);    // Transition to external EEA superstate
                        break;
                    }
                    status_ = Q_TRAN(&Handle_EEA_Operate);
                }
                /*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck::ADAPTER_TYPE_CHE~::[AdapterKnown]::[UNKN]} */
                else {
                    // Unsupported adapter
                    // Update display as required
                    status_ = Q_HANDLED();
                }
            }
            /*.${AOs::Handle::SM::Operate::Idle::AdapterTypeCheck::ADAPTER_TYPE_CHE~::[else]} */
            else {
                AO_TimerRearm(&me->AdapterCheckTimer, 10);
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Idle);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Display startup banner
 *
 * \details This state initiates the display of the startup banner and maintains
 *          it for a set time before moving on th the next state.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::Banner} .....................................*/
QState Handle_Banner(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::Banner} */
        case Q_ENTRY_SIG: {
            Log(DEV, "Handle - Startup banner display");

            AO_TimerDisarm(&me->IdleTimer);
            AO_TimerDisarm(&me->SleepTimer);

            AO_TimerRearm(&me->Timer, BANNER_DISPLAY_TIME);
            WelcomeScreenShow(PLATFORM_VERSION);

            HNutil_SystemClockUpdate();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Banner::TIMEOUT} */
        case TIMEOUT_SIG: {
            Log(DEV, "Handle - Startup banner display complete");  /// \todo - Remove after test

            /*.${AOs::Handle::SM::Operate::Banner::TIMEOUT::[AdapterON]} */
            if ((AM_DEVICE_CONNECTED == me->Adapter.Status)) {
                // If an adapter is already connected, skip the motor test.
                status_ = Q_TRAN(&Handle_Idle);
            }
            /*.${AOs::Handle::SM::Operate::Banner::TIMEOUT::[AdapterOFF]} */
            else {
                // No adapter found - start motor test
                status_ = Q_TRAN(&Handle_MotorTest);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Operate);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Perform motor test
 *
 * \details This state moves each motor a specified amount and tests for successful
 *          completion. If the motor test passes, the appropriate display / sound
 *          is issued and control passes to the idle state. If the motor test fails,
 *          the appropriate displays/sounds are issued, and control is transferred
 *          to the fault state.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::MotorTest} ..................................*/
QState Handle_MotorTest(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::MotorTest} */
        case Q_ENTRY_SIG: {
            me->MotorsOK = 0;        // Initialize test maps
            me->MotorsChecked = 0;

            Log(DEV, "Handle - Motor test start");  /// \todo - Remove when real display in
            AO_TimerDisarm(&me->IdleTimer);      // Give test time to run
            HNutil_StartMotorTest(me, e);               // Start moving all motors
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::MotorTest} */
        case Q_EXIT_SIG: {
            // All motors off
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::MotorTest::P_MOTOR_0_STOP_INFO, P_MOTOR_1_S~} */
        case P_MOTOR_0_STOP_INFO_SIG: /* intentionally fall through */
        case P_MOTOR_1_STOP_INFO_SIG: /* intentionally fall through */
        case P_MOTOR_2_STOP_INFO_SIG: {
            QEVENT_MOTOR_STOP_INFO *pStop;

            pStop = (QEVENT_MOTOR_STOP_INFO *)e;    // Cast event pointer to proper format

            Log(DBG, "Handle - Motor %d stop signal received", pStop->MotorNum);

            me->MotorsChecked |= (1 << pStop->MotorNum);  // Mark motor N as stopped
            if(pStop->StopStatus & MOT_STOP_STATUS_IN_POS)
            {
            me->MotorsOK |= (1 << pStop->MotorNum);       // Mark motor N as OK
            }
            /*.${AOs::Handle::SM::Operate::MotorTest::P_MOTOR_0_STOP_I~::[TestFail]} */
            if ((me->MotorsChecked == 7) &&
                (me->MotorsOK != 7))
            {
                Log(DEV, "Handle - Motor test failed");

                // Create Fault for Motor Test Fail
                FaultHandlerSetFault(REQRST_MOTOR_TEST, SET_ERROR);

                status_ = Q_HANDLED();
            }
            /*.${AOs::Handle::SM::Operate::MotorTest::P_MOTOR_0_STOP_I~::[TestOK]} */
            else if ((me->MotorsChecked == 7) &&
                     (me->MotorsOK == 7))
            {
                Log(DEV, "Handle - Motor test OK");
                AO_TimerDisarm(&me->Timer);
                Signia_PlayTone(SNDMGR_TONE_ALL_GOOD);    // Test passed - Play all good tone
                status_ = Q_TRAN(&Handle_Idle);
            }
            /*.${AOs::Handle::SM::Operate::MotorTest::P_MOTOR_0_STOP_I~::[Testing]} */
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Operate);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Hard fault
 *
 * \details An unrecoverable error has occurred. Remain in this state until the unit
 *          is restarted.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::Fault} ......................................*/
QState Handle_Fault(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::Fault} */
        case Q_ENTRY_SIG: {
            Log(DEV, "Handle - Enter Fault State");  /// \todo DAZ - Remove after demo



            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Fault::P_ON_CHARGER} */
        case P_ON_CHARGER_SIG: {
            me->OnChargerTimetoSleep = ONCHARGER_TIMETOFIRSTSLEEP;
            Signia_BatteryHealthCheckReset();

            ///\todo: 3/14/2022 BS- check TCA flag, if set Reset BQchip

            status_ = Q_TRAN(&Handle_OnCharger);
            break;
        }
        /*.${AOs::Handle::SM::Operate::Fault::P_ADAPTER_CONNECTED, P_CLAMSHELL~} */
        case P_ADAPTER_CONNECTED_SIG: /* intentionally fall through */
        case P_CLAMSHELL_CONNECTED_SIG: /* intentionally fall through */
        case P_RELOAD_CONNECTED_SIG: {
            /* Enable one wire on Adapter */
            HNutil_ProcessDeviceConnEvents(me, e);

            /* Clamshell/Adapter/Reload Connected: Play Error Tone*/
            Signia_PlayTone(SNDMGR_TONE_FAULT);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Fault::FAULT_TIMEOUT} */
        case FAULT_TIMEOUT_SIG: {
            /* Display Reset screens*/
            HNutil_DisplayRequestScreenSeq(me);
            status_ = Q_HANDLED();
            break;
        }
        default: {
            /*.${AOs::Handle::SM::Operate::Fault::CATCH_ALL} */
            if (e->sig < Q_USER_SIG) {
                status_ = Q_SUPER(&Handle_Operate);
            }
            else {
                // Do not respond to any signals until restart
                status_ = Q_HANDLED();
            }
            break;
        }
    }
    return status_;
}

/**
 * \brief   Initial transition termination
 *
 * \details This state provides a termination of the initialization task context.
 *          It sets a short timer event and returns to the caller. When the timer
 *          expires, this state runs in the AO's context instead of the initilization
 *          task's context. The timeout then transfers to the rest of the application.
 *          All future events are processed in the AO's context.
 *
 *          This workaround is not required if it is acceptable to execute the
 *          entry code of the top level state in the initialization task's context
 *          on initialization.
 *
 * \note    These parameters are common to all states, so they are only shown here.
 *
 * \param   me - Pointer to AO's local data structure. (This includes the AO descriptor)
 * \param   e  - Pointer to event
 *
 * \return  State status
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::Startup} ....................................*/
QState Handle_Startup(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::Startup} */
        case Q_ENTRY_SIG: {
            Log(DEV, "Handle App starting");
            AO_TimerArm(&me->Timer, 1, 0);
            AO_TimerDisarm(&me->IdleTimer);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Startup::TIMEOUT} */
        case TIMEOUT_SIG: {
            AO_TimerDisarm(&me->Timer);
            /*.${AOs::Handle::SM::Operate::Startup::TIMEOUT::[OnCharger]} */
            if ((CHRG_MNGR_STATE_CONNECTED == Signia_ChargerManagerGetState())) {
                // This test is performed here in the event that
                // the P_ON_CHARGER event was published before
                // Handle could subscribe to it. All future instances
                // are handled by the P_ON_CHARGER event.
                status_ = Q_TRAN(&Handle_OnCharger);
            }
            /*.${AOs::Handle::SM::Operate::Startup::TIMEOUT::[OffCharger]} */
            else if ((CHRG_MNGR_STATE_CONNECTED != Signia_ChargerManagerGetState())) {
                status_ = Q_TRAN(&Handle_Banner);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Operate);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Power down the handle (ship mode)
 *
 * \details Power to the handle is removed. Power may only be restored by
 *          inserting the handle into the charger. At that point, the processor
 *          is reset and the system is reinitialized.
 *          objects that have subscribed to it.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::PowerDown} ..................................*/
QState Handle_PowerDown(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::PowerDown} */
        case Q_ENTRY_SIG: {
            /* Do nothing */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Operate);
            break;
        }
    }
    return status_;
}

/**
 * \brief   AdapterConnected state
 *
 * \details This state serves as a superstate for all Adapter specific logic. It
 *          contains event processing common to all adapters, and is not intended
 *          to be entered as an active state.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::AdapterConnected} ...........................*/
QState Handle_AdapterConnected(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::AdapterConnected} */
        case Q_ENTRY_SIG: {
            Log(DEV, "Handle - Adapter Connected State entered");
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::AdapterConnected::P_KEYPRESS} */
        case P_KEYPRESS_SIG: {
            // Prevent arming of standby/idle timers while adapter attached.
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Operate);
            break;
        }
    }
    return status_;
}

// EEA state
//
// Control EEA adapter.
//
// This is simply a placeholder for the external model. It is never executed.
/*.${AOs::Handle::SM::Operate::AdapterConnected::EEA_Operate} ..............*/
QState Handle_EEA_Operate(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        default: {
            status_ = Q_SUPER(&Handle_AdapterConnected);
            break;
        }
    }
    return status_;
}

// EGIA state
//
// Control EGIA adapter.
//
// This is simply a placeholder for the external model. It is never executed.
/*.${AOs::Handle::SM::Operate::AdapterConnected::EGIA_Operate} .............*/
QState Handle_EGIA_Operate(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::AdapterConnected::EGIA_Operate} */
        case Q_ENTRY_SIG: {
            /* Check if ST_ERR_USED_SHEEL status. If it is SET play TONE_ERR_CAUTION */
            if ( me->Clamshell.ClamshellEOL )
            {
                /* Play Caution Tone */
                Signia_PlayTone(SNDMGR_TONE_CAUTION);
            }

            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_AdapterConnected);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Processing when on the charger
 *
 * \details This state is entered when a charger is detected. All charger related
 *          logic is performed here.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::OnCharger} ..................................*/
QState Handle_OnCharger(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::OnCharger} */
        case Q_ENTRY_SIG: {
            uint16_t ProcedureCount;
            uint16_t ProcedureLimit;
            uint64_t LastClamshellAddr;

            if (!GetSystemStatus(SYSTEM_STATUS_DEEP_SLEEP_ACTIVATED))
            {
                me->PrevStateUSB = 0xFF;
                Log(DBG, "Entered OnCharger State");
                SecurityLog("Charger Connected");

                AO_TimerDisarm(&me->IdleTimer);
                /* The HANDLE shall remain in STANDBY_MODE while the USB port is connected,
                   while the HANDLE is connected to the CHARGER. */
                AO_TimerDisarm(&me->Timer);
                AO_TimerDisarm(&me->SleepTimer);
                AO_TimerArm(&me->IdleModeTimer, CHARGER_IDLEMODE_TIMEOUT, 0);
                AO_TimerArm(&me->Timer, BAT_READ_TIMEOUT_ONCHARGER, 0);
                AO_TimerArm(&me->SleepTimer,me->OnChargerTimetoSleep,0);

                DeviceMem_READ(me->Handle,ProcedureLimit,ProcedureLimit);
                DeviceMem_READ(me->Handle,ProcedureCount,ProcedureCount);

                if (GetSystemStatus( SYSTEM_STATUS_PROCEDURE_HAS_FIRED_FLAG))
                {
                    //check firing flag status. Increment handle procedure count if firing flag set
                    ProcedureCount++;
                    DeviceMem_WRITE(me->Handle,ProcedureCount,ProcedureCount);
                    ClearNoinitProcedureHasFiredFlag(); //reset firing flag once handle procedure count is incremented
                }

                if( ProcedureCount >= ProcedureLimit)
                {
                    Signia_PowerModeSet(POWER_MODE_ACTIVE);
                    FaultHandlerSetFault(HANDLE_EOL_ZEROPROCEDURECOUNT, SET_ERROR);
                }
                // Delete the ID of the previously attached CLAMSHELL from HANDLE memory
                LastClamshellAddr = 0;
                DeviceMem_WRITE(me->Handle,LastClamshellAddress,LastClamshellAddr);
            }
            else
            {
                AO_TimerRearm(&me->SleepTimer,me->OnChargerTimetoSleep);
            }
            Signia_BatteryHealthCheck(me->pChargerInfo);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::OnCharger::CHARGER_IDLEMODE_TIMEOUT} */
        case CHARGER_IDLEMODE_TIMEOUT_SIG: {
            Log(DBG, " Entering Idle Charger Mode ");
            me->PrevStateUSB = 0xFF;
            AO_TimerDisarm(&me->Timer);
            AO_TimerDisarm(&me->IdleModeTimer);
            AO_TimerRearm(&me->Timer,BAT_READ_TIMEOUT_ONCHARGER);
            Signia_ChargerManagerSleep();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::OnCharger::TIMEOUT} */
        case TIMEOUT_SIG: {
            uint8_t UsbCommStatus;
            UsbCommStatus = L4_USBConnectionStatus();

            if (me->PrevStateUSB != UsbCommStatus)
            {
                if (!UsbCommStatus)
                {
                    Signia_PowerModeSet(POWER_MODE_STANDBY);
                }
                else
                {
                    Signia_PowerModeSet(POWER_MODE_ACTIVE);
                }
                me->PrevStateUSB = UsbCommStatus;
            }
            AO_TimerRearm(&me->Timer, BAT_READ_TIMEOUT_ONCHARGER);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::OnCharger::P_OFF_CHARGER} */
        case P_OFF_CHARGER_SIG: {
            uint8_t BatteryLevel;
            Signia_ChargerManagerGetBattRsoc(&BatteryLevel);
            status_ = Q_TRAN(&Handle_Reset);
            break;
        }
        /*.${AOs::Handle::SM::Operate::OnCharger::SLEEP_TIMEOUT} */
        case SLEEP_TIMEOUT_SIG: {

            // Set the sleep cause as Charger
            Signia_PowerModeSetSleepCause(SLEEP_CAUSE_CHARGER);
            /*.${AOs::Handle::SM::Operate::OnCharger::SLEEP_TIMEOUT::[ComDisconnected]} */
            if (!me->Handle.HandleComConnected) {
                status_ = Q_TRAN(&Handle_Sleep);
            }
            /*.${AOs::Handle::SM::Operate::OnCharger::SLEEP_TIMEOUT::[ComConnected]} */
            else {
                status_ = Q_TRAN(&Handle_WaitForBH);
            }
            break;
        }
        default: {
            /*.${AOs::Handle::SM::Operate::OnCharger::CATCH_ALL} */
            if (e->sig < Q_USER_SIG) {
                status_ = Q_SUPER(&Handle_Operate);
            }
            else {
                // We will only get here if the processor was not put into sleep mode.
                // (PowerModeSet failed)

                me->Handle.HandleComConnected = L4_CommStatusActive();
                status_ = Q_HANDLED();
            }
            break;
        }
    }
    return status_;
}

/**
 * \brief   Wait state for Battery Healthcheck
 *
 * \details This state is entered when Sleep timer is elapsed and USB is connected.
 *	 As USB communication is Active Handle shall not go to Sleep, hence the Oncharger enters this waitstate for the next Battery health check cycle
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::OnCharger::WaitForBH} .......................*/
QState Handle_WaitForBH(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::OnCharger::WaitForBH} */
        case Q_ENTRY_SIG: {
            Log(DEV,"OnCharger: Battery Health wait state, Wait Time = %d sec", Signia_BatteryHealthGetNextSleepTime()/1000 );
            AO_TimerArm(&me->WaitforBHTimer, Signia_BatteryHealthGetNextSleepTime(),0);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::OnCharger::WaitForBH::WAIT_FOR_BH_TIMEOUT} */
        case WAIT_FOR_BH_TIMEOUT_SIG: {
            /*The timer Handles the Battery Health check intervals in case of COM active*/
            me->OnChargerTimetoSleep = me->pChargerInfo->pBattParam->MinWakeTimeinms;

            Log(DEV, "OnCharger: Battery Health wait Timeout");

            AO_TimerDisarm(&me->WaitforBHTimer);
            AO_TimerRearm(&me->SleepTimer,me->OnChargerTimetoSleep);
            Signia_BatteryHealthCheck(me->pChargerInfo);
            status_ = Q_TRAN(&Handle_OnCharger);
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_OnCharger);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Power down the handle (ship mode)
 *
 * \details Power to the handle is removed. Power may only be restored by
 *          inserting the handle into the charger. At that point, the processor
 *          is reset and the system is reinitialized.
 *          objects that have subscribed to it.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::Reset} ......................................*/
QState Handle_Reset(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::Reset} */
        case Q_ENTRY_SIG: {
            Log(DBG, "Entering Handle reset state");

            ClearSystemStatus();

            SoftReset();  //reset device
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Handle_Operate);
            break;
        }
    }
    return status_;
}

/**
 * \brief   Invoke sleep mode
 *
 * \details Sleep mode stops the CPU clock. It is started when a LLWU (Low Level
 *          Wake Up) signal is asserted. The code that services the LLWWU signal
 *          causes the processor to be reset. Execution comes to this state
 *          (completes entry processing) only if Signia_PowerModeSet fails and the
 *          unit does not sleep.
 *
 * ========================================================================== */
/*.${AOs::Handle::SM::Operate::Sleep} ......................................*/
QState Handle_Sleep(Handle * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::Handle::SM::Operate::Sleep} */
        case Q_ENTRY_SIG: {
            // Sleep mode stops the CPU clock.
            // Waking up from sleep mode should happen with the peripheral wake up pin signal.
            // Sleep mode sets the periphral WU pin to wake on any key press or charger connect.
            // A wake will result in a SW reset

            Log(DEV, "Entered Sleep mode");
            Signia_PowerModeSet(POWER_MODE_SLEEP);
            // Control is not returned to this point.
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::Handle::SM::Operate::Sleep::P_ONCHARGER_WAKEFROMSLEEP} */
        case P_ONCHARGER_WAKEFROMSLEEP_SIG: {
            me->OnChargerTimetoSleep = me->pChargerInfo->pBattParam->MinWakeTimeinms;
            status_ = Q_TRAN(&Handle_OnCharger);
            break;
        }
        /*.${AOs::Handle::SM::Operate::Sleep::P_OFF_CHARGER} */
        case P_OFF_CHARGER_SIG: {
            Log(DBG, "Exiting on OnCharger State");
            SecurityLog("Charger Disconnected");

            AO_TimerDisarm(&me->SleepTimer);
            ClearSystemStatus();

            status_ = Q_TRAN(&Handle_Reset);
            break;
        }
        default: {
            /*.${AOs::Handle::SM::Operate::Sleep::CATCH_ALL} */
            if (e->sig < Q_USER_SIG) {
                status_ = Q_SUPER(&Handle_Operate);
            }
            else {
                // We will only get here if the processor was not put into sleep mode.
                // (PowerModeSet failed)

                /// \todo 02/08/2022 DAZ - What do we want to do here? Force reset?
                status_ = Q_HANDLED();
            }
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::Handle} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#pragma cstat_enable ="PTR-null-cmp-bef"

/******************************************************************************/
/*                             Global Function(s)                             */
/******************************************************************************/
#pragma cstat_disable ="PTR-null-cmp-bef"
/*.$define${AOs::HandleCtor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/

/**
 * \brief   Constructor for the Handle Active Object
 *
 * \details Establishes the Active Object (AO) and executes the initial transition
 *          and state entry code. Other AO specific objects, such as timers, may
 *          be initialized here (AO_TimerCtor()).
 * \n \n
 *          The Handle "constructor" is provided outside of the Handle class so that it
 *          can be used independently from the class. This is part of the "opaque pointer"
 *          design idiom.
 * \n \n
 *          Establishing the AO encompasses the following activities:
 *              - Initialize and register the task control block with Micrium.
 *                  - Set the stack
 *                  - Set the priority
 *                  - Set the name
 *              - Initialize and register the active object control block with QP/C.
 *                  - Set the event queue
 *                  - Pass user defined initialization parameters
 *
 * \note    The initial transition and state entry code (the 1st time) are executed
 *          in the calling task's context so care must be taken to consider the calling
 *          task's stack constraints and task dependent defaults, if any, when writing
 *          that code. This is usually not a problem, but when using certain features of
 *          Micrium (such as the file system), Micrium keeps certain configuration information
 *          in the task control block.
 *
 * \param   < None >
 *
 * \return  None
 *
 * ========================================================================== */
/*.${AOs::HandleCtor} ......................................................*/
void HandleCtor(void) {
    Handle *me = &LocalHandle;

    AO_TimerCtor(&me->ReloadSwitchTimer, AO_Handle, SWITCH_STATE_TIMEOUT_SIG); // Create timer
    AO_TimerCtor(&me->Timer, AO_Handle, TIMEOUT_SIG);              // Create timer
    AO_TimerCtor(&me->IdleTimer, AO_Handle, IDLE_TIMEOUT_SIG);     // Create Idle timer
    AO_TimerCtor(&me->SleepTimer, AO_Handle, SLEEP_TIMEOUT_SIG);   // Create Sleep timer
    AO_TimerCtor(&me->FaultTimer, AO_Handle, FAULT_TIMEOUT_SIG);   // Create Fault Timer
    AO_TimerCtor(&me->BatteryLowTimer, AO_Handle, BATTERY_LOW_TIMEOUT_SIG); // Create Battery Low Timer
    AO_TimerCtor(&me->IdleModeTimer, AO_Handle, CHARGER_IDLEMODE_TIMEOUT_SIG);   // Create charger IDLE MODE timer
    AO_TimerCtor(&me->MotorIdleTimer, AO_Handle, MOTOR_IDLE_TIMEOUT_SIG);
    AO_TimerCtor(&me->CountDownScreenTimer, AO_Handle, COUNTDOWN_SCREEN_TIMEOUT_SIG);   // Create CountDown Screen timer
    AO_TimerCtor(&me->RotationConfigScreenTimer, AO_Handle, ROTATION_CONFIG_SCREEN_TIMEOUT_SIG);   // Create Rotation Config Screen timer
    AO_TimerCtor(&me->RotationConfigTimer, AO_Handle, P_ROTATION_CONFIG_COMPLETED_SIG);   // Create Rotation Config Screen timer
    AO_TimerCtor(&me->RetryFireCountUpdateTimer, AO_Handle, RETRY_FIRE_COUNT_UPDATE_TIMEOUT_SIG);    // Create timer for Update Handle Fire Count
    AO_TimerCtor(&me->FiringTimer, AO_Handle, FIREMODE_TIMEOUT_SIG); // Create timer for firing progression update on reload recognition bar
    AO_TimerCtor(&me->ClamshellOWShortTimer, AO_Handle, CLAMSHELL_1WSHORT_TIMEOUT_SIG); // Create timer
    AO_TimerCtor(&me->WaitforBHTimer, AO_Handle, WAIT_FOR_BH_TIMEOUT_SIG); // Create timer for Battery Health Check wait in case of Active COM
    AO_TimerCtor(&me->AdapterCheckTimer,AO_Handle,ADAPTER_TYPE_CHECK_TIMEOUT_SIG);

    AO_Start(AO_Handle,                             // Pointer to QActive object (AO)
             Q_STATE_CAST(&Handle_initial),     // Pointer to initial transition
             TASK_PRIORITY_HANDLE,               // Task priority
             HandleEventQueue,                      // Pointer to event queue
             HANDLE_EVQ_SIZE,                       // Size of event queue (in entries) This could be Q_DIM(HandleEventQueue)
             HandleStack,                           // Pointer to stack (bottom)
             HANDLE_STACK_SIZE,                     // Stack size This could be Q_DIM(HandleStack)
             NULL,                                  // Pointer to object specific initialization parameters
             AOname);                               // Pointer to name of active object

    /* DeferQueue Initialization */
    AO_QueueInit(&me->DeferQueue, HandleDeferQueue, HANDLE_DEFER_EVQ_SIZE);

    /**
     * \}   <if using addtogroup above>
     */

}
/*.$enddef${AOs::HandleCtor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#pragma cstat_enable ="PTR-null-cmp-bef"
